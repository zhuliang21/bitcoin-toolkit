/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/bbqr/dist/bbqr.js":
/*!****************************************!*\
  !*** ./node_modules/bbqr/dist/bbqr.js ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   detectFileType: () => (/* binding */ m1),\n/* harmony export */   joinQRs: () => (/* binding */ E1),\n/* harmony export */   renderQRImage: () => (/* binding */ x1),\n/* harmony export */   splitQRs: () => (/* binding */ k1)\n/* harmony export */ });\nfunction Aa(e) {\n  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, \"default\") ? e.default : e;\n}\nvar Tt = {}, yn, $r;\nfunction ko() {\n  return $r || ($r = 1, yn = function() {\n    return typeof Promise == \"function\" && Promise.prototype && Promise.prototype.then;\n  }), yn;\n}\nvar An = {}, ot = {}, Pr;\nfunction Et() {\n  if (Pr) return ot;\n  Pr = 1;\n  let e;\n  const r = [\n    0,\n    // Not used\n    26,\n    44,\n    70,\n    100,\n    134,\n    172,\n    196,\n    242,\n    292,\n    346,\n    404,\n    466,\n    532,\n    581,\n    655,\n    733,\n    815,\n    901,\n    991,\n    1085,\n    1156,\n    1258,\n    1364,\n    1474,\n    1588,\n    1706,\n    1828,\n    1921,\n    2051,\n    2185,\n    2323,\n    2465,\n    2611,\n    2761,\n    2876,\n    3034,\n    3196,\n    3362,\n    3532,\n    3706\n  ];\n  return ot.getSymbolSize = function(i) {\n    if (!i) throw new Error('\"version\" cannot be null or undefined');\n    if (i < 1 || i > 40) throw new Error('\"version\" should be in range from 1 to 40');\n    return i * 4 + 17;\n  }, ot.getSymbolTotalCodewords = function(i) {\n    return r[i];\n  }, ot.getBCHDigit = function(t) {\n    let i = 0;\n    for (; t !== 0; )\n      i++, t >>>= 1;\n    return i;\n  }, ot.setToSJISFunction = function(i) {\n    if (typeof i != \"function\")\n      throw new Error('\"toSJISFunc\" is not a valid function.');\n    e = i;\n  }, ot.isKanjiModeEnabled = function() {\n    return typeof e < \"u\";\n  }, ot.toSJIS = function(i) {\n    return e(i);\n  }, ot;\n}\nvar Sn = {}, qr;\nfunction Ir() {\n  return qr || (qr = 1, function(e) {\n    e.L = { bit: 1 }, e.M = { bit: 0 }, e.Q = { bit: 3 }, e.H = { bit: 2 };\n    function r(t) {\n      if (typeof t != \"string\")\n        throw new Error(\"Param is not a string\");\n      switch (t.toLowerCase()) {\n        case \"l\":\n        case \"low\":\n          return e.L;\n        case \"m\":\n        case \"medium\":\n          return e.M;\n        case \"q\":\n        case \"quartile\":\n          return e.Q;\n        case \"h\":\n        case \"high\":\n          return e.H;\n        default:\n          throw new Error(\"Unknown EC Level: \" + t);\n      }\n    }\n    e.isValid = function(i) {\n      return i && typeof i.bit < \"u\" && i.bit >= 0 && i.bit < 4;\n    }, e.from = function(i, f) {\n      if (e.isValid(i))\n        return i;\n      try {\n        return r(i);\n      } catch {\n        return f;\n      }\n    };\n  }(Sn)), Sn;\n}\nvar Rn, Kr;\nfunction mo() {\n  if (Kr) return Rn;\n  Kr = 1;\n  function e() {\n    this.buffer = [], this.length = 0;\n  }\n  return e.prototype = {\n    get: function(r) {\n      const t = Math.floor(r / 8);\n      return (this.buffer[t] >>> 7 - r % 8 & 1) === 1;\n    },\n    put: function(r, t) {\n      for (let i = 0; i < t; i++)\n        this.putBit((r >>> t - i - 1 & 1) === 1);\n    },\n    getLengthInBits: function() {\n      return this.length;\n    },\n    putBit: function(r) {\n      const t = Math.floor(this.length / 8);\n      this.buffer.length <= t && this.buffer.push(0), r && (this.buffer[t] |= 128 >>> this.length % 8), this.length++;\n    }\n  }, Rn = e, Rn;\n}\nvar Tn, Yr;\nfunction yo() {\n  if (Yr) return Tn;\n  Yr = 1;\n  function e(r) {\n    if (!r || r < 1)\n      throw new Error(\"BitMatrix size must be defined and greater than 0\");\n    this.size = r, this.data = new Uint8Array(r * r), this.reservedBit = new Uint8Array(r * r);\n  }\n  return e.prototype.set = function(r, t, i, f) {\n    const n = r * this.size + t;\n    this.data[n] = i, f && (this.reservedBit[n] = !0);\n  }, e.prototype.get = function(r, t) {\n    return this.data[r * this.size + t];\n  }, e.prototype.xor = function(r, t, i) {\n    this.data[r * this.size + t] ^= i;\n  }, e.prototype.isReserved = function(r, t) {\n    return this.reservedBit[r * this.size + t];\n  }, Tn = e, Tn;\n}\nvar zn = {}, Qr;\nfunction Ao() {\n  return Qr || (Qr = 1, function(e) {\n    const r = Et().getSymbolSize;\n    e.getRowColCoords = function(i) {\n      if (i === 1) return [];\n      const f = Math.floor(i / 7) + 2, n = r(i), a = n === 145 ? 26 : Math.ceil((n - 13) / (2 * f - 2)) * 2, l = [n - 7];\n      for (let s = 1; s < f - 1; s++)\n        l[s] = l[s - 1] - a;\n      return l.push(6), l.reverse();\n    }, e.getPositions = function(i) {\n      const f = [], n = e.getRowColCoords(i), a = n.length;\n      for (let l = 0; l < a; l++)\n        for (let s = 0; s < a; s++)\n          l === 0 && s === 0 || // top-left\n          l === 0 && s === a - 1 || // bottom-left\n          l === a - 1 && s === 0 || f.push([n[l], n[s]]);\n      return f;\n    };\n  }(zn)), zn;\n}\nvar Cn = {}, Vr;\nfunction So() {\n  if (Vr) return Cn;\n  Vr = 1;\n  const e = Et().getSymbolSize, r = 7;\n  return Cn.getPositions = function(i) {\n    const f = e(i);\n    return [\n      // top-left\n      [0, 0],\n      // top-right\n      [f - r, 0],\n      // bottom-left\n      [0, f - r]\n    ];\n  }, Cn;\n}\nvar In = {}, jr;\nfunction Ro() {\n  return jr || (jr = 1, function(e) {\n    e.Patterns = {\n      PATTERN000: 0,\n      PATTERN001: 1,\n      PATTERN010: 2,\n      PATTERN011: 3,\n      PATTERN100: 4,\n      PATTERN101: 5,\n      PATTERN110: 6,\n      PATTERN111: 7\n    };\n    const r = {\n      N1: 3,\n      N2: 3,\n      N3: 40,\n      N4: 10\n    };\n    e.isValid = function(f) {\n      return f != null && f !== \"\" && !isNaN(f) && f >= 0 && f <= 7;\n    }, e.from = function(f) {\n      return e.isValid(f) ? parseInt(f, 10) : void 0;\n    }, e.getPenaltyN1 = function(f) {\n      const n = f.size;\n      let a = 0, l = 0, s = 0, h = null, u = null;\n      for (let d = 0; d < n; d++) {\n        l = s = 0, h = u = null;\n        for (let g = 0; g < n; g++) {\n          let v = f.get(d, g);\n          v === h ? l++ : (l >= 5 && (a += r.N1 + (l - 5)), h = v, l = 1), v = f.get(g, d), v === u ? s++ : (s >= 5 && (a += r.N1 + (s - 5)), u = v, s = 1);\n        }\n        l >= 5 && (a += r.N1 + (l - 5)), s >= 5 && (a += r.N1 + (s - 5));\n      }\n      return a;\n    }, e.getPenaltyN2 = function(f) {\n      const n = f.size;\n      let a = 0;\n      for (let l = 0; l < n - 1; l++)\n        for (let s = 0; s < n - 1; s++) {\n          const h = f.get(l, s) + f.get(l, s + 1) + f.get(l + 1, s) + f.get(l + 1, s + 1);\n          (h === 4 || h === 0) && a++;\n        }\n      return a * r.N2;\n    }, e.getPenaltyN3 = function(f) {\n      const n = f.size;\n      let a = 0, l = 0, s = 0;\n      for (let h = 0; h < n; h++) {\n        l = s = 0;\n        for (let u = 0; u < n; u++)\n          l = l << 1 & 2047 | f.get(h, u), u >= 10 && (l === 1488 || l === 93) && a++, s = s << 1 & 2047 | f.get(u, h), u >= 10 && (s === 1488 || s === 93) && a++;\n      }\n      return a * r.N3;\n    }, e.getPenaltyN4 = function(f) {\n      let n = 0;\n      const a = f.data.length;\n      for (let s = 0; s < a; s++) n += f.data[s];\n      return Math.abs(Math.ceil(n * 100 / a / 5) - 10) * r.N4;\n    };\n    function t(i, f, n) {\n      switch (i) {\n        case e.Patterns.PATTERN000:\n          return (f + n) % 2 === 0;\n        case e.Patterns.PATTERN001:\n          return f % 2 === 0;\n        case e.Patterns.PATTERN010:\n          return n % 3 === 0;\n        case e.Patterns.PATTERN011:\n          return (f + n) % 3 === 0;\n        case e.Patterns.PATTERN100:\n          return (Math.floor(f / 2) + Math.floor(n / 3)) % 2 === 0;\n        case e.Patterns.PATTERN101:\n          return f * n % 2 + f * n % 3 === 0;\n        case e.Patterns.PATTERN110:\n          return (f * n % 2 + f * n % 3) % 2 === 0;\n        case e.Patterns.PATTERN111:\n          return (f * n % 3 + (f + n) % 2) % 2 === 0;\n        default:\n          throw new Error(\"bad maskPattern:\" + i);\n      }\n    }\n    e.applyMask = function(f, n) {\n      const a = n.size;\n      for (let l = 0; l < a; l++)\n        for (let s = 0; s < a; s++)\n          n.isReserved(s, l) || n.xor(s, l, t(f, s, l));\n    }, e.getBestMask = function(f, n) {\n      const a = Object.keys(e.Patterns).length;\n      let l = 0, s = 1 / 0;\n      for (let h = 0; h < a; h++) {\n        n(h), e.applyMask(h, f);\n        const u = e.getPenaltyN1(f) + e.getPenaltyN2(f) + e.getPenaltyN3(f) + e.getPenaltyN4(f);\n        e.applyMask(h, f), u < s && (s = u, l = h);\n      }\n      return l;\n    };\n  }(In)), In;\n}\nvar ln = {}, Xr;\nfunction Sa() {\n  if (Xr) return ln;\n  Xr = 1;\n  const e = Ir(), r = [\n    // L  M  Q  H\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    2,\n    2,\n    1,\n    2,\n    2,\n    4,\n    1,\n    2,\n    4,\n    4,\n    2,\n    4,\n    4,\n    4,\n    2,\n    4,\n    6,\n    5,\n    2,\n    4,\n    6,\n    6,\n    2,\n    5,\n    8,\n    8,\n    4,\n    5,\n    8,\n    8,\n    4,\n    5,\n    8,\n    11,\n    4,\n    8,\n    10,\n    11,\n    4,\n    9,\n    12,\n    16,\n    4,\n    9,\n    16,\n    16,\n    6,\n    10,\n    12,\n    18,\n    6,\n    10,\n    17,\n    16,\n    6,\n    11,\n    16,\n    19,\n    6,\n    13,\n    18,\n    21,\n    7,\n    14,\n    21,\n    25,\n    8,\n    16,\n    20,\n    25,\n    8,\n    17,\n    23,\n    25,\n    9,\n    17,\n    23,\n    34,\n    9,\n    18,\n    25,\n    30,\n    10,\n    20,\n    27,\n    32,\n    12,\n    21,\n    29,\n    35,\n    12,\n    23,\n    34,\n    37,\n    12,\n    25,\n    34,\n    40,\n    13,\n    26,\n    35,\n    42,\n    14,\n    28,\n    38,\n    45,\n    15,\n    29,\n    40,\n    48,\n    16,\n    31,\n    43,\n    51,\n    17,\n    33,\n    45,\n    54,\n    18,\n    35,\n    48,\n    57,\n    19,\n    37,\n    51,\n    60,\n    19,\n    38,\n    53,\n    63,\n    20,\n    40,\n    56,\n    66,\n    21,\n    43,\n    59,\n    70,\n    22,\n    45,\n    62,\n    74,\n    24,\n    47,\n    65,\n    77,\n    25,\n    49,\n    68,\n    81\n  ], t = [\n    // L  M  Q  H\n    7,\n    10,\n    13,\n    17,\n    10,\n    16,\n    22,\n    28,\n    15,\n    26,\n    36,\n    44,\n    20,\n    36,\n    52,\n    64,\n    26,\n    48,\n    72,\n    88,\n    36,\n    64,\n    96,\n    112,\n    40,\n    72,\n    108,\n    130,\n    48,\n    88,\n    132,\n    156,\n    60,\n    110,\n    160,\n    192,\n    72,\n    130,\n    192,\n    224,\n    80,\n    150,\n    224,\n    264,\n    96,\n    176,\n    260,\n    308,\n    104,\n    198,\n    288,\n    352,\n    120,\n    216,\n    320,\n    384,\n    132,\n    240,\n    360,\n    432,\n    144,\n    280,\n    408,\n    480,\n    168,\n    308,\n    448,\n    532,\n    180,\n    338,\n    504,\n    588,\n    196,\n    364,\n    546,\n    650,\n    224,\n    416,\n    600,\n    700,\n    224,\n    442,\n    644,\n    750,\n    252,\n    476,\n    690,\n    816,\n    270,\n    504,\n    750,\n    900,\n    300,\n    560,\n    810,\n    960,\n    312,\n    588,\n    870,\n    1050,\n    336,\n    644,\n    952,\n    1110,\n    360,\n    700,\n    1020,\n    1200,\n    390,\n    728,\n    1050,\n    1260,\n    420,\n    784,\n    1140,\n    1350,\n    450,\n    812,\n    1200,\n    1440,\n    480,\n    868,\n    1290,\n    1530,\n    510,\n    924,\n    1350,\n    1620,\n    540,\n    980,\n    1440,\n    1710,\n    570,\n    1036,\n    1530,\n    1800,\n    570,\n    1064,\n    1590,\n    1890,\n    600,\n    1120,\n    1680,\n    1980,\n    630,\n    1204,\n    1770,\n    2100,\n    660,\n    1260,\n    1860,\n    2220,\n    720,\n    1316,\n    1950,\n    2310,\n    750,\n    1372,\n    2040,\n    2430\n  ];\n  return ln.getBlocksCount = function(f, n) {\n    switch (n) {\n      case e.L:\n        return r[(f - 1) * 4 + 0];\n      case e.M:\n        return r[(f - 1) * 4 + 1];\n      case e.Q:\n        return r[(f - 1) * 4 + 2];\n      case e.H:\n        return r[(f - 1) * 4 + 3];\n      default:\n        return;\n    }\n  }, ln.getTotalCodewordsCount = function(f, n) {\n    switch (n) {\n      case e.L:\n        return t[(f - 1) * 4 + 0];\n      case e.M:\n        return t[(f - 1) * 4 + 1];\n      case e.Q:\n        return t[(f - 1) * 4 + 2];\n      case e.H:\n        return t[(f - 1) * 4 + 3];\n      default:\n        return;\n    }\n  }, ln;\n}\nvar Dn = {}, Ht = {}, Jr;\nfunction To() {\n  if (Jr) return Ht;\n  Jr = 1;\n  const e = new Uint8Array(512), r = new Uint8Array(256);\n  return function() {\n    let i = 1;\n    for (let f = 0; f < 255; f++)\n      e[f] = i, r[i] = f, i <<= 1, i & 256 && (i ^= 285);\n    for (let f = 255; f < 512; f++)\n      e[f] = e[f - 255];\n  }(), Ht.log = function(i) {\n    if (i < 1) throw new Error(\"log(\" + i + \")\");\n    return r[i];\n  }, Ht.exp = function(i) {\n    return e[i];\n  }, Ht.mul = function(i, f) {\n    return i === 0 || f === 0 ? 0 : e[r[i] + r[f]];\n  }, Ht;\n}\nvar Wr;\nfunction zo() {\n  return Wr || (Wr = 1, function(e) {\n    const r = To();\n    e.mul = function(i, f) {\n      const n = new Uint8Array(i.length + f.length - 1);\n      for (let a = 0; a < i.length; a++)\n        for (let l = 0; l < f.length; l++)\n          n[a + l] ^= r.mul(i[a], f[l]);\n      return n;\n    }, e.mod = function(i, f) {\n      let n = new Uint8Array(i);\n      for (; n.length - f.length >= 0; ) {\n        const a = n[0];\n        for (let s = 0; s < f.length; s++)\n          n[s] ^= r.mul(f[s], a);\n        let l = 0;\n        for (; l < n.length && n[l] === 0; ) l++;\n        n = n.slice(l);\n      }\n      return n;\n    }, e.generateECPolynomial = function(i) {\n      let f = new Uint8Array([1]);\n      for (let n = 0; n < i; n++)\n        f = e.mul(f, new Uint8Array([1, r.exp(n)]));\n      return f;\n    };\n  }(Dn)), Dn;\n}\nvar Ln, Gr;\nfunction Co() {\n  if (Gr) return Ln;\n  Gr = 1;\n  const e = zo();\n  function r(t) {\n    this.genPoly = void 0, this.degree = t, this.degree && this.initialize(this.degree);\n  }\n  return r.prototype.initialize = function(i) {\n    this.degree = i, this.genPoly = e.generateECPolynomial(this.degree);\n  }, r.prototype.encode = function(i) {\n    if (!this.genPoly)\n      throw new Error(\"Encoder not initialized\");\n    const f = new Uint8Array(i.length + this.degree);\n    f.set(i);\n    const n = e.mod(f, this.genPoly), a = this.degree - n.length;\n    if (a > 0) {\n      const l = new Uint8Array(this.degree);\n      return l.set(n, a), l;\n    }\n    return n;\n  }, Ln = r, Ln;\n}\nvar Bn = {}, Mn = {}, Nn = {}, ei;\nfunction Ra() {\n  return ei || (ei = 1, Nn.isValid = function(r) {\n    return !isNaN(r) && r >= 1 && r <= 40;\n  }), Nn;\n}\nvar Qe = {}, ti;\nfunction Ta() {\n  if (ti) return Qe;\n  ti = 1;\n  const e = \"[0-9]+\", r = \"[A-Z $%*+\\\\-./:]+\";\n  let t = \"(?:[u3000-u303F]|[u3040-u309F]|[u30A0-u30FF]|[uFF00-uFFEF]|[u4E00-u9FAF]|[u2605-u2606]|[u2190-u2195]|u203B|[u2010u2015u2018u2019u2025u2026u201Cu201Du2225u2260]|[u0391-u0451]|[u00A7u00A8u00B1u00B4u00D7u00F7])+\";\n  t = t.replace(/u/g, \"\\\\u\");\n  const i = \"(?:(?![A-Z0-9 $%*+\\\\-./:]|\" + t + `)(?:.|[\\r\n]))+`;\n  Qe.KANJI = new RegExp(t, \"g\"), Qe.BYTE_KANJI = new RegExp(\"[^A-Z0-9 $%*+\\\\-./:]+\", \"g\"), Qe.BYTE = new RegExp(i, \"g\"), Qe.NUMERIC = new RegExp(e, \"g\"), Qe.ALPHANUMERIC = new RegExp(r, \"g\");\n  const f = new RegExp(\"^\" + t + \"$\"), n = new RegExp(\"^\" + e + \"$\"), a = new RegExp(\"^[A-Z0-9 $%*+\\\\-./:]+$\");\n  return Qe.testKanji = function(s) {\n    return f.test(s);\n  }, Qe.testNumeric = function(s) {\n    return n.test(s);\n  }, Qe.testAlphanumeric = function(s) {\n    return a.test(s);\n  }, Qe;\n}\nvar ni;\nfunction kt() {\n  return ni || (ni = 1, function(e) {\n    const r = Ra(), t = Ta();\n    e.NUMERIC = {\n      id: \"Numeric\",\n      bit: 1,\n      ccBits: [10, 12, 14]\n    }, e.ALPHANUMERIC = {\n      id: \"Alphanumeric\",\n      bit: 2,\n      ccBits: [9, 11, 13]\n    }, e.BYTE = {\n      id: \"Byte\",\n      bit: 4,\n      ccBits: [8, 16, 16]\n    }, e.KANJI = {\n      id: \"Kanji\",\n      bit: 8,\n      ccBits: [8, 10, 12]\n    }, e.MIXED = {\n      bit: -1\n    }, e.getCharCountIndicator = function(n, a) {\n      if (!n.ccBits) throw new Error(\"Invalid mode: \" + n);\n      if (!r.isValid(a))\n        throw new Error(\"Invalid version: \" + a);\n      return a >= 1 && a < 10 ? n.ccBits[0] : a < 27 ? n.ccBits[1] : n.ccBits[2];\n    }, e.getBestModeForData = function(n) {\n      return t.testNumeric(n) ? e.NUMERIC : t.testAlphanumeric(n) ? e.ALPHANUMERIC : t.testKanji(n) ? e.KANJI : e.BYTE;\n    }, e.toString = function(n) {\n      if (n && n.id) return n.id;\n      throw new Error(\"Invalid mode\");\n    }, e.isValid = function(n) {\n      return n && n.bit && n.ccBits;\n    };\n    function i(f) {\n      if (typeof f != \"string\")\n        throw new Error(\"Param is not a string\");\n      switch (f.toLowerCase()) {\n        case \"numeric\":\n          return e.NUMERIC;\n        case \"alphanumeric\":\n          return e.ALPHANUMERIC;\n        case \"kanji\":\n          return e.KANJI;\n        case \"byte\":\n          return e.BYTE;\n        default:\n          throw new Error(\"Unknown mode: \" + f);\n      }\n    }\n    e.from = function(n, a) {\n      if (e.isValid(n))\n        return n;\n      try {\n        return i(n);\n      } catch {\n        return a;\n      }\n    };\n  }(Mn)), Mn;\n}\nvar ri;\nfunction Io() {\n  return ri || (ri = 1, function(e) {\n    const r = Et(), t = Sa(), i = Ir(), f = kt(), n = Ra(), a = 7973, l = r.getBCHDigit(a);\n    function s(g, v, c) {\n      for (let R = 1; R <= 40; R++)\n        if (v <= e.getCapacity(R, c, g))\n          return R;\n    }\n    function h(g, v) {\n      return f.getCharCountIndicator(g, v) + 4;\n    }\n    function u(g, v) {\n      let c = 0;\n      return g.forEach(function(R) {\n        const S = h(R.mode, v);\n        c += S + R.getBitsLength();\n      }), c;\n    }\n    function d(g, v) {\n      for (let c = 1; c <= 40; c++)\n        if (u(g, c) <= e.getCapacity(c, v, f.MIXED))\n          return c;\n    }\n    e.from = function(v, c) {\n      return n.isValid(v) ? parseInt(v, 10) : c;\n    }, e.getCapacity = function(v, c, R) {\n      if (!n.isValid(v))\n        throw new Error(\"Invalid QR Code version\");\n      typeof R > \"u\" && (R = f.BYTE);\n      const S = r.getSymbolTotalCodewords(v), b = t.getTotalCodewordsCount(v, c), x = (S - b) * 8;\n      if (R === f.MIXED) return x;\n      const m = x - h(R, v);\n      switch (R) {\n        case f.NUMERIC:\n          return Math.floor(m / 10 * 3);\n        case f.ALPHANUMERIC:\n          return Math.floor(m / 11 * 2);\n        case f.KANJI:\n          return Math.floor(m / 13);\n        case f.BYTE:\n        default:\n          return Math.floor(m / 8);\n      }\n    }, e.getBestVersionForData = function(v, c) {\n      let R;\n      const S = i.from(c, i.M);\n      if (Array.isArray(v)) {\n        if (v.length > 1)\n          return d(v, S);\n        if (v.length === 0)\n          return 1;\n        R = v[0];\n      } else\n        R = v;\n      return s(R.mode, R.getLength(), S);\n    }, e.getEncodedBits = function(v) {\n      if (!n.isValid(v) || v < 7)\n        throw new Error(\"Invalid QR Code version\");\n      let c = v << 12;\n      for (; r.getBCHDigit(c) - l >= 0; )\n        c ^= a << r.getBCHDigit(c) - l;\n      return v << 12 | c;\n    };\n  }(Bn)), Bn;\n}\nvar Zn = {}, ii;\nfunction Do() {\n  if (ii) return Zn;\n  ii = 1;\n  const e = Et(), r = 1335, t = 21522, i = e.getBCHDigit(r);\n  return Zn.getEncodedBits = function(n, a) {\n    const l = n.bit << 3 | a;\n    let s = l << 10;\n    for (; e.getBCHDigit(s) - i >= 0; )\n      s ^= r << e.getBCHDigit(s) - i;\n    return (l << 10 | s) ^ t;\n  }, Zn;\n}\nvar On = {}, Hn, ai;\nfunction Lo() {\n  if (ai) return Hn;\n  ai = 1;\n  const e = kt();\n  function r(t) {\n    this.mode = e.NUMERIC, this.data = t.toString();\n  }\n  return r.getBitsLength = function(i) {\n    return 10 * Math.floor(i / 3) + (i % 3 ? i % 3 * 3 + 1 : 0);\n  }, r.prototype.getLength = function() {\n    return this.data.length;\n  }, r.prototype.getBitsLength = function() {\n    return r.getBitsLength(this.data.length);\n  }, r.prototype.write = function(i) {\n    let f, n, a;\n    for (f = 0; f + 3 <= this.data.length; f += 3)\n      n = this.data.substr(f, 3), a = parseInt(n, 10), i.put(a, 10);\n    const l = this.data.length - f;\n    l > 0 && (n = this.data.substr(f), a = parseInt(n, 10), i.put(a, l * 3 + 1));\n  }, Hn = r, Hn;\n}\nvar Un, oi;\nfunction Bo() {\n  if (oi) return Un;\n  oi = 1;\n  const e = kt(), r = [\n    \"0\",\n    \"1\",\n    \"2\",\n    \"3\",\n    \"4\",\n    \"5\",\n    \"6\",\n    \"7\",\n    \"8\",\n    \"9\",\n    \"A\",\n    \"B\",\n    \"C\",\n    \"D\",\n    \"E\",\n    \"F\",\n    \"G\",\n    \"H\",\n    \"I\",\n    \"J\",\n    \"K\",\n    \"L\",\n    \"M\",\n    \"N\",\n    \"O\",\n    \"P\",\n    \"Q\",\n    \"R\",\n    \"S\",\n    \"T\",\n    \"U\",\n    \"V\",\n    \"W\",\n    \"X\",\n    \"Y\",\n    \"Z\",\n    \" \",\n    \"$\",\n    \"%\",\n    \"*\",\n    \"+\",\n    \"-\",\n    \".\",\n    \"/\",\n    \":\"\n  ];\n  function t(i) {\n    this.mode = e.ALPHANUMERIC, this.data = i;\n  }\n  return t.getBitsLength = function(f) {\n    return 11 * Math.floor(f / 2) + 6 * (f % 2);\n  }, t.prototype.getLength = function() {\n    return this.data.length;\n  }, t.prototype.getBitsLength = function() {\n    return t.getBitsLength(this.data.length);\n  }, t.prototype.write = function(f) {\n    let n;\n    for (n = 0; n + 2 <= this.data.length; n += 2) {\n      let a = r.indexOf(this.data[n]) * 45;\n      a += r.indexOf(this.data[n + 1]), f.put(a, 11);\n    }\n    this.data.length % 2 && f.put(r.indexOf(this.data[n]), 6);\n  }, Un = t, Un;\n}\nvar Fn, fi;\nfunction Mo() {\n  if (fi) return Fn;\n  fi = 1;\n  const e = kt();\n  function r(t) {\n    this.mode = e.BYTE, typeof t == \"string\" ? this.data = new TextEncoder().encode(t) : this.data = new Uint8Array(t);\n  }\n  return r.getBitsLength = function(i) {\n    return i * 8;\n  }, r.prototype.getLength = function() {\n    return this.data.length;\n  }, r.prototype.getBitsLength = function() {\n    return r.getBitsLength(this.data.length);\n  }, r.prototype.write = function(t) {\n    for (let i = 0, f = this.data.length; i < f; i++)\n      t.put(this.data[i], 8);\n  }, Fn = r, Fn;\n}\nvar $n, li;\nfunction No() {\n  if (li) return $n;\n  li = 1;\n  const e = kt(), r = Et();\n  function t(i) {\n    this.mode = e.KANJI, this.data = i;\n  }\n  return t.getBitsLength = function(f) {\n    return f * 13;\n  }, t.prototype.getLength = function() {\n    return this.data.length;\n  }, t.prototype.getBitsLength = function() {\n    return t.getBitsLength(this.data.length);\n  }, t.prototype.write = function(i) {\n    let f;\n    for (f = 0; f < this.data.length; f++) {\n      let n = r.toSJIS(this.data[f]);\n      if (n >= 33088 && n <= 40956)\n        n -= 33088;\n      else if (n >= 57408 && n <= 60351)\n        n -= 49472;\n      else\n        throw new Error(\n          \"Invalid SJIS character: \" + this.data[f] + `\nMake sure your charset is UTF-8`\n        );\n      n = (n >>> 8 & 255) * 192 + (n & 255), i.put(n, 13);\n    }\n  }, $n = t, $n;\n}\nvar Pn = { exports: {} }, si;\nfunction Zo() {\n  return si || (si = 1, function(e) {\n    var r = {\n      single_source_shortest_paths: function(t, i, f) {\n        var n = {}, a = {};\n        a[i] = 0;\n        var l = r.PriorityQueue.make();\n        l.push(i, 0);\n        for (var s, h, u, d, g, v, c, R, S; !l.empty(); ) {\n          s = l.pop(), h = s.value, d = s.cost, g = t[h] || {};\n          for (u in g)\n            g.hasOwnProperty(u) && (v = g[u], c = d + v, R = a[u], S = typeof a[u] > \"u\", (S || R > c) && (a[u] = c, l.push(u, c), n[u] = h));\n        }\n        if (typeof f < \"u\" && typeof a[f] > \"u\") {\n          var b = [\"Could not find a path from \", i, \" to \", f, \".\"].join(\"\");\n          throw new Error(b);\n        }\n        return n;\n      },\n      extract_shortest_path_from_predecessor_list: function(t, i) {\n        for (var f = [], n = i; n; )\n          f.push(n), t[n], n = t[n];\n        return f.reverse(), f;\n      },\n      find_path: function(t, i, f) {\n        var n = r.single_source_shortest_paths(t, i, f);\n        return r.extract_shortest_path_from_predecessor_list(\n          n,\n          f\n        );\n      },\n      /**\n       * A very naive priority queue implementation.\n       */\n      PriorityQueue: {\n        make: function(t) {\n          var i = r.PriorityQueue, f = {}, n;\n          t = t || {};\n          for (n in i)\n            i.hasOwnProperty(n) && (f[n] = i[n]);\n          return f.queue = [], f.sorter = t.sorter || i.default_sorter, f;\n        },\n        default_sorter: function(t, i) {\n          return t.cost - i.cost;\n        },\n        /**\n         * Add a new item to the queue and ensure the highest priority element\n         * is at the front of the queue.\n         */\n        push: function(t, i) {\n          var f = { value: t, cost: i };\n          this.queue.push(f), this.queue.sort(this.sorter);\n        },\n        /**\n         * Return the highest priority element in the queue.\n         */\n        pop: function() {\n          return this.queue.shift();\n        },\n        empty: function() {\n          return this.queue.length === 0;\n        }\n      }\n    };\n    e.exports = r;\n  }(Pn)), Pn.exports;\n}\nvar hi;\nfunction Oo() {\n  return hi || (hi = 1, function(e) {\n    const r = kt(), t = Lo(), i = Bo(), f = Mo(), n = No(), a = Ta(), l = Et(), s = Zo();\n    function h(b) {\n      return unescape(encodeURIComponent(b)).length;\n    }\n    function u(b, x, m) {\n      const k = [];\n      let L;\n      for (; (L = b.exec(m)) !== null; )\n        k.push({\n          data: L[0],\n          index: L.index,\n          mode: x,\n          length: L[0].length\n        });\n      return k;\n    }\n    function d(b) {\n      const x = u(a.NUMERIC, r.NUMERIC, b), m = u(a.ALPHANUMERIC, r.ALPHANUMERIC, b);\n      let k, L;\n      return l.isKanjiModeEnabled() ? (k = u(a.BYTE, r.BYTE, b), L = u(a.KANJI, r.KANJI, b)) : (k = u(a.BYTE_KANJI, r.BYTE, b), L = []), x.concat(m, k, L).sort(function(E, T) {\n        return E.index - T.index;\n      }).map(function(E) {\n        return {\n          data: E.data,\n          mode: E.mode,\n          length: E.length\n        };\n      });\n    }\n    function g(b, x) {\n      switch (x) {\n        case r.NUMERIC:\n          return t.getBitsLength(b);\n        case r.ALPHANUMERIC:\n          return i.getBitsLength(b);\n        case r.KANJI:\n          return n.getBitsLength(b);\n        case r.BYTE:\n          return f.getBitsLength(b);\n      }\n    }\n    function v(b) {\n      return b.reduce(function(x, m) {\n        const k = x.length - 1 >= 0 ? x[x.length - 1] : null;\n        return k && k.mode === m.mode ? (x[x.length - 1].data += m.data, x) : (x.push(m), x);\n      }, []);\n    }\n    function c(b) {\n      const x = [];\n      for (let m = 0; m < b.length; m++) {\n        const k = b[m];\n        switch (k.mode) {\n          case r.NUMERIC:\n            x.push([\n              k,\n              { data: k.data, mode: r.ALPHANUMERIC, length: k.length },\n              { data: k.data, mode: r.BYTE, length: k.length }\n            ]);\n            break;\n          case r.ALPHANUMERIC:\n            x.push([\n              k,\n              { data: k.data, mode: r.BYTE, length: k.length }\n            ]);\n            break;\n          case r.KANJI:\n            x.push([\n              k,\n              { data: k.data, mode: r.BYTE, length: h(k.data) }\n            ]);\n            break;\n          case r.BYTE:\n            x.push([\n              { data: k.data, mode: r.BYTE, length: h(k.data) }\n            ]);\n        }\n      }\n      return x;\n    }\n    function R(b, x) {\n      const m = {}, k = { start: {} };\n      let L = [\"start\"];\n      for (let z = 0; z < b.length; z++) {\n        const E = b[z], T = [];\n        for (let I = 0; I < E.length; I++) {\n          const D = E[I], C = \"\" + z + I;\n          T.push(C), m[C] = { node: D, lastCount: 0 }, k[C] = {};\n          for (let O = 0; O < L.length; O++) {\n            const N = L[O];\n            m[N] && m[N].node.mode === D.mode ? (k[N][C] = g(m[N].lastCount + D.length, D.mode) - g(m[N].lastCount, D.mode), m[N].lastCount += D.length) : (m[N] && (m[N].lastCount = D.length), k[N][C] = g(D.length, D.mode) + 4 + r.getCharCountIndicator(D.mode, x));\n          }\n        }\n        L = T;\n      }\n      for (let z = 0; z < L.length; z++)\n        k[L[z]].end = 0;\n      return { map: k, table: m };\n    }\n    function S(b, x) {\n      let m;\n      const k = r.getBestModeForData(b);\n      if (m = r.from(x, k), m !== r.BYTE && m.bit < k.bit)\n        throw new Error('\"' + b + '\" cannot be encoded with mode ' + r.toString(m) + `.\n Suggested mode is: ` + r.toString(k));\n      switch (m === r.KANJI && !l.isKanjiModeEnabled() && (m = r.BYTE), m) {\n        case r.NUMERIC:\n          return new t(b);\n        case r.ALPHANUMERIC:\n          return new i(b);\n        case r.KANJI:\n          return new n(b);\n        case r.BYTE:\n          return new f(b);\n      }\n    }\n    e.fromArray = function(x) {\n      return x.reduce(function(m, k) {\n        return typeof k == \"string\" ? m.push(S(k, null)) : k.data && m.push(S(k.data, k.mode)), m;\n      }, []);\n    }, e.fromString = function(x, m) {\n      const k = d(x, l.isKanjiModeEnabled()), L = c(k), z = R(L, m), E = s.find_path(z.map, \"start\", \"end\"), T = [];\n      for (let I = 1; I < E.length - 1; I++)\n        T.push(z.table[E[I]].node);\n      return e.fromArray(v(T));\n    }, e.rawSplit = function(x) {\n      return e.fromArray(\n        d(x, l.isKanjiModeEnabled())\n      );\n    };\n  }(On)), On;\n}\nvar ui;\nfunction Ho() {\n  if (ui) return An;\n  ui = 1;\n  const e = Et(), r = Ir(), t = mo(), i = yo(), f = Ao(), n = So(), a = Ro(), l = Sa(), s = Co(), h = Io(), u = Do(), d = kt(), g = Oo();\n  function v(z, E) {\n    const T = z.size, I = n.getPositions(E);\n    for (let D = 0; D < I.length; D++) {\n      const C = I[D][0], O = I[D][1];\n      for (let N = -1; N <= 7; N++)\n        if (!(C + N <= -1 || T <= C + N))\n          for (let U = -1; U <= 7; U++)\n            O + U <= -1 || T <= O + U || (N >= 0 && N <= 6 && (U === 0 || U === 6) || U >= 0 && U <= 6 && (N === 0 || N === 6) || N >= 2 && N <= 4 && U >= 2 && U <= 4 ? z.set(C + N, O + U, !0, !0) : z.set(C + N, O + U, !1, !0));\n    }\n  }\n  function c(z) {\n    const E = z.size;\n    for (let T = 8; T < E - 8; T++) {\n      const I = T % 2 === 0;\n      z.set(T, 6, I, !0), z.set(6, T, I, !0);\n    }\n  }\n  function R(z, E) {\n    const T = f.getPositions(E);\n    for (let I = 0; I < T.length; I++) {\n      const D = T[I][0], C = T[I][1];\n      for (let O = -2; O <= 2; O++)\n        for (let N = -2; N <= 2; N++)\n          O === -2 || O === 2 || N === -2 || N === 2 || O === 0 && N === 0 ? z.set(D + O, C + N, !0, !0) : z.set(D + O, C + N, !1, !0);\n    }\n  }\n  function S(z, E) {\n    const T = z.size, I = h.getEncodedBits(E);\n    let D, C, O;\n    for (let N = 0; N < 18; N++)\n      D = Math.floor(N / 3), C = N % 3 + T - 8 - 3, O = (I >> N & 1) === 1, z.set(D, C, O, !0), z.set(C, D, O, !0);\n  }\n  function b(z, E, T) {\n    const I = z.size, D = u.getEncodedBits(E, T);\n    let C, O;\n    for (C = 0; C < 15; C++)\n      O = (D >> C & 1) === 1, C < 6 ? z.set(C, 8, O, !0) : C < 8 ? z.set(C + 1, 8, O, !0) : z.set(I - 15 + C, 8, O, !0), C < 8 ? z.set(8, I - C - 1, O, !0) : C < 9 ? z.set(8, 15 - C - 1 + 1, O, !0) : z.set(8, 15 - C - 1, O, !0);\n    z.set(I - 8, 8, 1, !0);\n  }\n  function x(z, E) {\n    const T = z.size;\n    let I = -1, D = T - 1, C = 7, O = 0;\n    for (let N = T - 1; N > 0; N -= 2)\n      for (N === 6 && N--; ; ) {\n        for (let U = 0; U < 2; U++)\n          if (!z.isReserved(D, N - U)) {\n            let X = !1;\n            O < E.length && (X = (E[O] >>> C & 1) === 1), z.set(D, N - U, X), C--, C === -1 && (O++, C = 7);\n          }\n        if (D += I, D < 0 || T <= D) {\n          D -= I, I = -I;\n          break;\n        }\n      }\n  }\n  function m(z, E, T) {\n    const I = new t();\n    T.forEach(function(U) {\n      I.put(U.mode.bit, 4), I.put(U.getLength(), d.getCharCountIndicator(U.mode, z)), U.write(I);\n    });\n    const D = e.getSymbolTotalCodewords(z), C = l.getTotalCodewordsCount(z, E), O = (D - C) * 8;\n    for (I.getLengthInBits() + 4 <= O && I.put(0, 4); I.getLengthInBits() % 8 !== 0; )\n      I.putBit(0);\n    const N = (O - I.getLengthInBits()) / 8;\n    for (let U = 0; U < N; U++)\n      I.put(U % 2 ? 17 : 236, 8);\n    return k(I, z, E);\n  }\n  function k(z, E, T) {\n    const I = e.getSymbolTotalCodewords(E), D = l.getTotalCodewordsCount(E, T), C = I - D, O = l.getBlocksCount(E, T), N = I % O, U = O - N, X = Math.floor(I / O), Y = Math.floor(C / O), q = Y + 1, V = X - Y, ne = new s(V);\n    let ve = 0;\n    const be = new Array(O), de = new Array(O);\n    let he = 0;\n    const ge = new Uint8Array(z.buffer);\n    for (let W = 0; W < O; W++) {\n      const Ee = W < U ? Y : q;\n      be[W] = ge.slice(ve, ve + Ee), de[W] = ne.encode(be[W]), ve += Ee, he = Math.max(he, Ee);\n    }\n    const ue = new Uint8Array(I);\n    let re = 0, ie, G;\n    for (ie = 0; ie < he; ie++)\n      for (G = 0; G < O; G++)\n        ie < be[G].length && (ue[re++] = be[G][ie]);\n    for (ie = 0; ie < V; ie++)\n      for (G = 0; G < O; G++)\n        ue[re++] = de[G][ie];\n    return ue;\n  }\n  function L(z, E, T, I) {\n    let D;\n    if (Array.isArray(z))\n      D = g.fromArray(z);\n    else if (typeof z == \"string\") {\n      let X = E;\n      if (!X) {\n        const Y = g.rawSplit(z);\n        X = h.getBestVersionForData(Y, T);\n      }\n      D = g.fromString(z, X || 40);\n    } else\n      throw new Error(\"Invalid data\");\n    const C = h.getBestVersionForData(D, T);\n    if (!C)\n      throw new Error(\"The amount of data is too big to be stored in a QR Code\");\n    if (!E)\n      E = C;\n    else if (E < C)\n      throw new Error(\n        `\nThe chosen QR Code version cannot contain this amount of data.\nMinimum version required to store current data is: ` + C + `.\n`\n      );\n    const O = m(E, T, D), N = e.getSymbolSize(E), U = new i(N);\n    return v(U, E), c(U), R(U, E), b(U, T, 0), E >= 7 && S(U, E), x(U, O), isNaN(I) && (I = a.getBestMask(\n      U,\n      b.bind(null, U, T)\n    )), a.applyMask(I, U), b(U, T, I), {\n      modules: U,\n      version: E,\n      errorCorrectionLevel: T,\n      maskPattern: I,\n      segments: D\n    };\n  }\n  return An.create = function(E, T) {\n    if (typeof E > \"u\" || E === \"\")\n      throw new Error(\"No input text\");\n    let I = r.M, D, C;\n    return typeof T < \"u\" && (I = r.from(T.errorCorrectionLevel, r.M), D = h.from(T.version), C = a.from(T.maskPattern), T.toSJISFunc && e.setToSJISFunction(T.toSJISFunc)), L(E, D, I, C);\n  }, An;\n}\nvar qn = {}, Kn = {}, ci;\nfunction za() {\n  return ci || (ci = 1, function(e) {\n    function r(t) {\n      if (typeof t == \"number\" && (t = t.toString()), typeof t != \"string\")\n        throw new Error(\"Color should be defined as hex string\");\n      let i = t.slice().replace(\"#\", \"\").split(\"\");\n      if (i.length < 3 || i.length === 5 || i.length > 8)\n        throw new Error(\"Invalid hex color: \" + t);\n      (i.length === 3 || i.length === 4) && (i = Array.prototype.concat.apply([], i.map(function(n) {\n        return [n, n];\n      }))), i.length === 6 && i.push(\"F\", \"F\");\n      const f = parseInt(i.join(\"\"), 16);\n      return {\n        r: f >> 24 & 255,\n        g: f >> 16 & 255,\n        b: f >> 8 & 255,\n        a: f & 255,\n        hex: \"#\" + i.slice(0, 6).join(\"\")\n      };\n    }\n    e.getOptions = function(i) {\n      i || (i = {}), i.color || (i.color = {});\n      const f = typeof i.margin > \"u\" || i.margin === null || i.margin < 0 ? 4 : i.margin, n = i.width && i.width >= 21 ? i.width : void 0, a = i.scale || 4;\n      return {\n        width: n,\n        scale: n ? 4 : a,\n        margin: f,\n        color: {\n          dark: r(i.color.dark || \"#000000ff\"),\n          light: r(i.color.light || \"#ffffffff\")\n        },\n        type: i.type,\n        rendererOpts: i.rendererOpts || {}\n      };\n    }, e.getScale = function(i, f) {\n      return f.width && f.width >= i + f.margin * 2 ? f.width / (i + f.margin * 2) : f.scale;\n    }, e.getImageWidth = function(i, f) {\n      const n = e.getScale(i, f);\n      return Math.floor((i + f.margin * 2) * n);\n    }, e.qrToImageData = function(i, f, n) {\n      const a = f.modules.size, l = f.modules.data, s = e.getScale(a, n), h = Math.floor((a + n.margin * 2) * s), u = n.margin * s, d = [n.color.light, n.color.dark];\n      for (let g = 0; g < h; g++)\n        for (let v = 0; v < h; v++) {\n          let c = (g * h + v) * 4, R = n.color.light;\n          if (g >= u && v >= u && g < h - u && v < h - u) {\n            const S = Math.floor((g - u) / s), b = Math.floor((v - u) / s);\n            R = d[l[S * a + b] ? 1 : 0];\n          }\n          i[c++] = R.r, i[c++] = R.g, i[c++] = R.b, i[c] = R.a;\n        }\n    };\n  }(Kn)), Kn;\n}\nvar di;\nfunction Uo() {\n  return di || (di = 1, function(e) {\n    const r = za();\n    function t(f, n, a) {\n      f.clearRect(0, 0, n.width, n.height), n.style || (n.style = {}), n.height = a, n.width = a, n.style.height = a + \"px\", n.style.width = a + \"px\";\n    }\n    function i() {\n      try {\n        return document.createElement(\"canvas\");\n      } catch {\n        throw new Error(\"You need to specify a canvas element\");\n      }\n    }\n    e.render = function(n, a, l) {\n      let s = l, h = a;\n      typeof s > \"u\" && (!a || !a.getContext) && (s = a, a = void 0), a || (h = i()), s = r.getOptions(s);\n      const u = r.getImageWidth(n.modules.size, s), d = h.getContext(\"2d\"), g = d.createImageData(u, u);\n      return r.qrToImageData(g.data, n, s), t(d, h, u), d.putImageData(g, 0, 0), h;\n    }, e.renderToDataURL = function(n, a, l) {\n      let s = l;\n      typeof s > \"u\" && (!a || !a.getContext) && (s = a, a = void 0), s || (s = {});\n      const h = e.render(n, a, s), u = s.type || \"image/png\", d = s.rendererOpts || {};\n      return h.toDataURL(u, d.quality);\n    };\n  }(qn)), qn;\n}\nvar Yn = {}, _i;\nfunction Fo() {\n  if (_i) return Yn;\n  _i = 1;\n  const e = za();\n  function r(f, n) {\n    const a = f.a / 255, l = n + '=\"' + f.hex + '\"';\n    return a < 1 ? l + \" \" + n + '-opacity=\"' + a.toFixed(2).slice(1) + '\"' : l;\n  }\n  function t(f, n, a) {\n    let l = f + n;\n    return typeof a < \"u\" && (l += \" \" + a), l;\n  }\n  function i(f, n, a) {\n    let l = \"\", s = 0, h = !1, u = 0;\n    for (let d = 0; d < f.length; d++) {\n      const g = Math.floor(d % n), v = Math.floor(d / n);\n      !g && !h && (h = !0), f[d] ? (u++, d > 0 && g > 0 && f[d - 1] || (l += h ? t(\"M\", g + a, 0.5 + v + a) : t(\"m\", s, 0), s = 0, h = !1), g + 1 < n && f[d + 1] || (l += t(\"h\", u), u = 0)) : s++;\n    }\n    return l;\n  }\n  return Yn.render = function(n, a, l) {\n    const s = e.getOptions(a), h = n.modules.size, u = n.modules.data, d = h + s.margin * 2, g = s.color.light.a ? \"<path \" + r(s.color.light, \"fill\") + ' d=\"M0 0h' + d + \"v\" + d + 'H0z\"/>' : \"\", v = \"<path \" + r(s.color.dark, \"stroke\") + ' d=\"' + i(u, h, s.margin) + '\"/>', c = 'viewBox=\"0 0 ' + d + \" \" + d + '\"', S = '<svg xmlns=\"http://www.w3.org/2000/svg\" ' + (s.width ? 'width=\"' + s.width + '\" height=\"' + s.width + '\" ' : \"\") + c + ' shape-rendering=\"crispEdges\">' + g + v + `</svg>\n`;\n    return typeof l == \"function\" && l(null, S), S;\n  }, Yn;\n}\nvar gi;\nfunction $o() {\n  if (gi) return Tt;\n  gi = 1;\n  const e = ko(), r = Ho(), t = Uo(), i = Fo();\n  function f(n, a, l, s, h) {\n    const u = [].slice.call(arguments, 1), d = u.length, g = typeof u[d - 1] == \"function\";\n    if (!g && !e())\n      throw new Error(\"Callback required as last argument\");\n    if (g) {\n      if (d < 2)\n        throw new Error(\"Too few arguments provided\");\n      d === 2 ? (h = l, l = a, a = s = void 0) : d === 3 && (a.getContext && typeof h > \"u\" ? (h = s, s = void 0) : (h = s, s = l, l = a, a = void 0));\n    } else {\n      if (d < 1)\n        throw new Error(\"Too few arguments provided\");\n      return d === 1 ? (l = a, a = s = void 0) : d === 2 && !a.getContext && (s = l, l = a, a = void 0), new Promise(function(v, c) {\n        try {\n          const R = r.create(l, s);\n          v(n(R, a, s));\n        } catch (R) {\n          c(R);\n        }\n      });\n    }\n    try {\n      const v = r.create(l, s);\n      h(null, n(v, a, s));\n    } catch (v) {\n      h(v);\n    }\n  }\n  return Tt.create = r.create, Tt.toCanvas = f.bind(null, t.render), Tt.toDataURL = f.bind(null, t.renderToDataURL), Tt.toString = f.bind(null, function(n, a, l) {\n    return i.render(n, l);\n  }), Tt;\n}\nvar Po = $o();\nconst qo = /* @__PURE__ */ Aa(Po);\nfunction Ko(e) {\n  throw new Error('Could not dynamically require \"' + e + '\". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');\n}\nvar Qn = { exports: {} }, Vn = {}, vi;\nfunction ct() {\n  return vi || (vi = 1, function(e) {\n    var r = typeof Uint8Array < \"u\" && typeof Uint16Array < \"u\" && typeof Int32Array < \"u\";\n    function t(n, a) {\n      return Object.prototype.hasOwnProperty.call(n, a);\n    }\n    e.assign = function(n) {\n      for (var a = Array.prototype.slice.call(arguments, 1); a.length; ) {\n        var l = a.shift();\n        if (l) {\n          if (typeof l != \"object\")\n            throw new TypeError(l + \"must be non-object\");\n          for (var s in l)\n            t(l, s) && (n[s] = l[s]);\n        }\n      }\n      return n;\n    }, e.shrinkBuf = function(n, a) {\n      return n.length === a ? n : n.subarray ? n.subarray(0, a) : (n.length = a, n);\n    };\n    var i = {\n      arraySet: function(n, a, l, s, h) {\n        if (a.subarray && n.subarray) {\n          n.set(a.subarray(l, l + s), h);\n          return;\n        }\n        for (var u = 0; u < s; u++)\n          n[h + u] = a[l + u];\n      },\n      // Join array of chunks to single array.\n      flattenChunks: function(n) {\n        var a, l, s, h, u, d;\n        for (s = 0, a = 0, l = n.length; a < l; a++)\n          s += n[a].length;\n        for (d = new Uint8Array(s), h = 0, a = 0, l = n.length; a < l; a++)\n          u = n[a], d.set(u, h), h += u.length;\n        return d;\n      }\n    }, f = {\n      arraySet: function(n, a, l, s, h) {\n        for (var u = 0; u < s; u++)\n          n[h + u] = a[l + u];\n      },\n      // Join array of chunks to single array.\n      flattenChunks: function(n) {\n        return [].concat.apply([], n);\n      }\n    };\n    e.setTyped = function(n) {\n      n ? (e.Buf8 = Uint8Array, e.Buf16 = Uint16Array, e.Buf32 = Int32Array, e.assign(e, i)) : (e.Buf8 = Array, e.Buf16 = Array, e.Buf32 = Array, e.assign(e, f));\n    }, e.setTyped(r);\n  }(Vn)), Vn;\n}\nvar zt = {}, qe = {}, dt = {}, wi;\nfunction Yo() {\n  if (wi) return dt;\n  wi = 1;\n  var e = ct(), r = 4, t = 0, i = 1, f = 2;\n  function n(p) {\n    for (var F = p.length; --F >= 0; )\n      p[F] = 0;\n  }\n  var a = 0, l = 1, s = 2, h = 3, u = 258, d = 29, g = 256, v = g + 1 + d, c = 30, R = 19, S = 2 * v + 1, b = 15, x = 16, m = 7, k = 256, L = 16, z = 17, E = 18, T = (\n    /* extra bits for each length code */\n    [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]\n  ), I = (\n    /* extra bits for each distance code */\n    [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]\n  ), D = (\n    /* extra bits for each bit length code */\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]\n  ), C = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], O = 512, N = new Array((v + 2) * 2);\n  n(N);\n  var U = new Array(c * 2);\n  n(U);\n  var X = new Array(O);\n  n(X);\n  var Y = new Array(u - h + 1);\n  n(Y);\n  var q = new Array(d);\n  n(q);\n  var V = new Array(c);\n  n(V);\n  function ne(p, F, P, j, A) {\n    this.static_tree = p, this.extra_bits = F, this.extra_base = P, this.elems = j, this.max_length = A, this.has_stree = p && p.length;\n  }\n  var ve, be, de;\n  function he(p, F) {\n    this.dyn_tree = p, this.max_code = 0, this.stat_desc = F;\n  }\n  function ge(p) {\n    return p < 256 ? X[p] : X[256 + (p >>> 7)];\n  }\n  function ue(p, F) {\n    p.pending_buf[p.pending++] = F & 255, p.pending_buf[p.pending++] = F >>> 8 & 255;\n  }\n  function re(p, F, P) {\n    p.bi_valid > x - P ? (p.bi_buf |= F << p.bi_valid & 65535, ue(p, p.bi_buf), p.bi_buf = F >> x - p.bi_valid, p.bi_valid += P - x) : (p.bi_buf |= F << p.bi_valid & 65535, p.bi_valid += P);\n  }\n  function ie(p, F, P) {\n    re(\n      p,\n      P[F * 2],\n      P[F * 2 + 1]\n      /*.Len*/\n    );\n  }\n  function G(p, F) {\n    var P = 0;\n    do\n      P |= p & 1, p >>>= 1, P <<= 1;\n    while (--F > 0);\n    return P >>> 1;\n  }\n  function W(p) {\n    p.bi_valid === 16 ? (ue(p, p.bi_buf), p.bi_buf = 0, p.bi_valid = 0) : p.bi_valid >= 8 && (p.pending_buf[p.pending++] = p.bi_buf & 255, p.bi_buf >>= 8, p.bi_valid -= 8);\n  }\n  function Ee(p, F) {\n    var P = F.dyn_tree, j = F.max_code, A = F.stat_desc.static_tree, H = F.stat_desc.has_stree, _ = F.stat_desc.extra_bits, $ = F.stat_desc.extra_base, ee = F.stat_desc.max_length, o, M, Z, w, y, B, J = 0;\n    for (w = 0; w <= b; w++)\n      p.bl_count[w] = 0;\n    for (P[p.heap[p.heap_max] * 2 + 1] = 0, o = p.heap_max + 1; o < S; o++)\n      M = p.heap[o], w = P[P[M * 2 + 1] * 2 + 1] + 1, w > ee && (w = ee, J++), P[M * 2 + 1] = w, !(M > j) && (p.bl_count[w]++, y = 0, M >= $ && (y = _[M - $]), B = P[M * 2], p.opt_len += B * (w + y), H && (p.static_len += B * (A[M * 2 + 1] + y)));\n    if (J !== 0) {\n      do {\n        for (w = ee - 1; p.bl_count[w] === 0; )\n          w--;\n        p.bl_count[w]--, p.bl_count[w + 1] += 2, p.bl_count[ee]--, J -= 2;\n      } while (J > 0);\n      for (w = ee; w !== 0; w--)\n        for (M = p.bl_count[w]; M !== 0; )\n          Z = p.heap[--o], !(Z > j) && (P[Z * 2 + 1] !== w && (p.opt_len += (w - P[Z * 2 + 1]) * P[Z * 2], P[Z * 2 + 1] = w), M--);\n    }\n  }\n  function ze(p, F, P) {\n    var j = new Array(b + 1), A = 0, H, _;\n    for (H = 1; H <= b; H++)\n      j[H] = A = A + P[H - 1] << 1;\n    for (_ = 0; _ <= F; _++) {\n      var $ = p[_ * 2 + 1];\n      $ !== 0 && (p[_ * 2] = G(j[$]++, $));\n    }\n  }\n  function te() {\n    var p, F, P, j, A, H = new Array(b + 1);\n    for (P = 0, j = 0; j < d - 1; j++)\n      for (q[j] = P, p = 0; p < 1 << T[j]; p++)\n        Y[P++] = j;\n    for (Y[P - 1] = j, A = 0, j = 0; j < 16; j++)\n      for (V[j] = A, p = 0; p < 1 << I[j]; p++)\n        X[A++] = j;\n    for (A >>= 7; j < c; j++)\n      for (V[j] = A << 7, p = 0; p < 1 << I[j] - 7; p++)\n        X[256 + A++] = j;\n    for (F = 0; F <= b; F++)\n      H[F] = 0;\n    for (p = 0; p <= 143; )\n      N[p * 2 + 1] = 8, p++, H[8]++;\n    for (; p <= 255; )\n      N[p * 2 + 1] = 9, p++, H[9]++;\n    for (; p <= 279; )\n      N[p * 2 + 1] = 7, p++, H[7]++;\n    for (; p <= 287; )\n      N[p * 2 + 1] = 8, p++, H[8]++;\n    for (ze(N, v + 1, H), p = 0; p < c; p++)\n      U[p * 2 + 1] = 5, U[p * 2] = G(p, 5);\n    ve = new ne(N, T, g + 1, v, b), be = new ne(U, I, 0, c, b), de = new ne(new Array(0), D, 0, R, m);\n  }\n  function pe(p) {\n    var F;\n    for (F = 0; F < v; F++)\n      p.dyn_ltree[F * 2] = 0;\n    for (F = 0; F < c; F++)\n      p.dyn_dtree[F * 2] = 0;\n    for (F = 0; F < R; F++)\n      p.bl_tree[F * 2] = 0;\n    p.dyn_ltree[k * 2] = 1, p.opt_len = p.static_len = 0, p.last_lit = p.matches = 0;\n  }\n  function Ne(p) {\n    p.bi_valid > 8 ? ue(p, p.bi_buf) : p.bi_valid > 0 && (p.pending_buf[p.pending++] = p.bi_buf), p.bi_buf = 0, p.bi_valid = 0;\n  }\n  function Ie(p, F, P, j) {\n    Ne(p), ue(p, P), ue(p, ~P), e.arraySet(p.pending_buf, p.window, F, P, p.pending), p.pending += P;\n  }\n  function ye(p, F, P, j) {\n    var A = F * 2, H = P * 2;\n    return p[A] < p[H] || p[A] === p[H] && j[F] <= j[P];\n  }\n  function ce(p, F, P) {\n    for (var j = p.heap[P], A = P << 1; A <= p.heap_len && (A < p.heap_len && ye(F, p.heap[A + 1], p.heap[A], p.depth) && A++, !ye(F, j, p.heap[A], p.depth)); )\n      p.heap[P] = p.heap[A], P = A, A <<= 1;\n    p.heap[P] = j;\n  }\n  function ae(p, F, P) {\n    var j, A, H = 0, _, $;\n    if (p.last_lit !== 0)\n      do\n        j = p.pending_buf[p.d_buf + H * 2] << 8 | p.pending_buf[p.d_buf + H * 2 + 1], A = p.pending_buf[p.l_buf + H], H++, j === 0 ? ie(p, A, F) : (_ = Y[A], ie(p, _ + g + 1, F), $ = T[_], $ !== 0 && (A -= q[_], re(p, A, $)), j--, _ = ge(j), ie(p, _, P), $ = I[_], $ !== 0 && (j -= V[_], re(p, j, $)));\n      while (H < p.last_lit);\n    ie(p, k, F);\n  }\n  function Ze(p, F) {\n    var P = F.dyn_tree, j = F.stat_desc.static_tree, A = F.stat_desc.has_stree, H = F.stat_desc.elems, _, $, ee = -1, o;\n    for (p.heap_len = 0, p.heap_max = S, _ = 0; _ < H; _++)\n      P[_ * 2] !== 0 ? (p.heap[++p.heap_len] = ee = _, p.depth[_] = 0) : P[_ * 2 + 1] = 0;\n    for (; p.heap_len < 2; )\n      o = p.heap[++p.heap_len] = ee < 2 ? ++ee : 0, P[o * 2] = 1, p.depth[o] = 0, p.opt_len--, A && (p.static_len -= j[o * 2 + 1]);\n    for (F.max_code = ee, _ = p.heap_len >> 1; _ >= 1; _--)\n      ce(p, P, _);\n    o = H;\n    do\n      _ = p.heap[\n        1\n        /*SMALLEST*/\n      ], p.heap[\n        1\n        /*SMALLEST*/\n      ] = p.heap[p.heap_len--], ce(\n        p,\n        P,\n        1\n        /*SMALLEST*/\n      ), $ = p.heap[\n        1\n        /*SMALLEST*/\n      ], p.heap[--p.heap_max] = _, p.heap[--p.heap_max] = $, P[o * 2] = P[_ * 2] + P[$ * 2], p.depth[o] = (p.depth[_] >= p.depth[$] ? p.depth[_] : p.depth[$]) + 1, P[_ * 2 + 1] = P[$ * 2 + 1] = o, p.heap[\n        1\n        /*SMALLEST*/\n      ] = o++, ce(\n        p,\n        P,\n        1\n        /*SMALLEST*/\n      );\n    while (p.heap_len >= 2);\n    p.heap[--p.heap_max] = p.heap[\n      1\n      /*SMALLEST*/\n    ], Ee(p, F), ze(P, ee, p.bl_count);\n  }\n  function yt(p, F, P) {\n    var j, A = -1, H, _ = F[0 * 2 + 1], $ = 0, ee = 7, o = 4;\n    for (_ === 0 && (ee = 138, o = 3), F[(P + 1) * 2 + 1] = 65535, j = 0; j <= P; j++)\n      H = _, _ = F[(j + 1) * 2 + 1], !(++$ < ee && H === _) && ($ < o ? p.bl_tree[H * 2] += $ : H !== 0 ? (H !== A && p.bl_tree[H * 2]++, p.bl_tree[L * 2]++) : $ <= 10 ? p.bl_tree[z * 2]++ : p.bl_tree[E * 2]++, $ = 0, A = H, _ === 0 ? (ee = 138, o = 3) : H === _ ? (ee = 6, o = 3) : (ee = 7, o = 4));\n  }\n  function rt(p, F, P) {\n    var j, A = -1, H, _ = F[0 * 2 + 1], $ = 0, ee = 7, o = 4;\n    for (_ === 0 && (ee = 138, o = 3), j = 0; j <= P; j++)\n      if (H = _, _ = F[(j + 1) * 2 + 1], !(++$ < ee && H === _)) {\n        if ($ < o)\n          do\n            ie(p, H, p.bl_tree);\n          while (--$ !== 0);\n        else H !== 0 ? (H !== A && (ie(p, H, p.bl_tree), $--), ie(p, L, p.bl_tree), re(p, $ - 3, 2)) : $ <= 10 ? (ie(p, z, p.bl_tree), re(p, $ - 3, 3)) : (ie(p, E, p.bl_tree), re(p, $ - 11, 7));\n        $ = 0, A = H, _ === 0 ? (ee = 138, o = 3) : H === _ ? (ee = 6, o = 3) : (ee = 7, o = 4);\n      }\n  }\n  function Oe(p) {\n    var F;\n    for (yt(p, p.dyn_ltree, p.l_desc.max_code), yt(p, p.dyn_dtree, p.d_desc.max_code), Ze(p, p.bl_desc), F = R - 1; F >= 3 && p.bl_tree[C[F] * 2 + 1] === 0; F--)\n      ;\n    return p.opt_len += 3 * (F + 1) + 5 + 5 + 4, F;\n  }\n  function At(p, F, P, j) {\n    var A;\n    for (re(p, F - 257, 5), re(p, P - 1, 5), re(p, j - 4, 4), A = 0; A < j; A++)\n      re(p, p.bl_tree[C[A] * 2 + 1], 3);\n    rt(p, p.dyn_ltree, F - 1), rt(p, p.dyn_dtree, P - 1);\n  }\n  function it(p) {\n    var F = 4093624447, P;\n    for (P = 0; P <= 31; P++, F >>>= 1)\n      if (F & 1 && p.dyn_ltree[P * 2] !== 0)\n        return t;\n    if (p.dyn_ltree[9 * 2] !== 0 || p.dyn_ltree[10 * 2] !== 0 || p.dyn_ltree[13 * 2] !== 0)\n      return i;\n    for (P = 32; P < g; P++)\n      if (p.dyn_ltree[P * 2] !== 0)\n        return i;\n    return t;\n  }\n  var Pe = !1;\n  function St(p) {\n    Pe || (te(), Pe = !0), p.l_desc = new he(p.dyn_ltree, ve), p.d_desc = new he(p.dyn_dtree, be), p.bl_desc = new he(p.bl_tree, de), p.bi_buf = 0, p.bi_valid = 0, pe(p);\n  }\n  function at(p, F, P, j) {\n    re(p, (a << 1) + (j ? 1 : 0), 3), Ie(p, F, P);\n  }\n  function Re(p) {\n    re(p, l << 1, 3), ie(p, k, N), W(p);\n  }\n  function Ke(p, F, P, j) {\n    var A, H, _ = 0;\n    p.level > 0 ? (p.strm.data_type === f && (p.strm.data_type = it(p)), Ze(p, p.l_desc), Ze(p, p.d_desc), _ = Oe(p), A = p.opt_len + 3 + 7 >>> 3, H = p.static_len + 3 + 7 >>> 3, H <= A && (A = H)) : A = H = P + 5, P + 4 <= A && F !== -1 ? at(p, F, P, j) : p.strategy === r || H === A ? (re(p, (l << 1) + (j ? 1 : 0), 3), ae(p, N, U)) : (re(p, (s << 1) + (j ? 1 : 0), 3), At(p, p.l_desc.max_code + 1, p.d_desc.max_code + 1, _ + 1), ae(p, p.dyn_ltree, p.dyn_dtree)), pe(p), j && Ne(p);\n  }\n  function Rt(p, F, P) {\n    return p.pending_buf[p.d_buf + p.last_lit * 2] = F >>> 8 & 255, p.pending_buf[p.d_buf + p.last_lit * 2 + 1] = F & 255, p.pending_buf[p.l_buf + p.last_lit] = P & 255, p.last_lit++, F === 0 ? p.dyn_ltree[P * 2]++ : (p.matches++, F--, p.dyn_ltree[(Y[P] + g + 1) * 2]++, p.dyn_dtree[ge(F) * 2]++), p.last_lit === p.lit_bufsize - 1;\n  }\n  return dt._tr_init = St, dt._tr_stored_block = at, dt._tr_flush_block = Ke, dt._tr_tally = Rt, dt._tr_align = Re, dt;\n}\nvar jn, bi;\nfunction Ca() {\n  if (bi) return jn;\n  bi = 1;\n  function e(r, t, i, f) {\n    for (var n = r & 65535 | 0, a = r >>> 16 & 65535 | 0, l = 0; i !== 0; ) {\n      l = i > 2e3 ? 2e3 : i, i -= l;\n      do\n        n = n + t[f++] | 0, a = a + n | 0;\n      while (--l);\n      n %= 65521, a %= 65521;\n    }\n    return n | a << 16 | 0;\n  }\n  return jn = e, jn;\n}\nvar Xn, pi;\nfunction Ia() {\n  if (pi) return Xn;\n  pi = 1;\n  function e() {\n    for (var i, f = [], n = 0; n < 256; n++) {\n      i = n;\n      for (var a = 0; a < 8; a++)\n        i = i & 1 ? 3988292384 ^ i >>> 1 : i >>> 1;\n      f[n] = i;\n    }\n    return f;\n  }\n  var r = e();\n  function t(i, f, n, a) {\n    var l = r, s = a + n;\n    i ^= -1;\n    for (var h = a; h < s; h++)\n      i = i >>> 8 ^ l[(i ^ f[h]) & 255];\n    return i ^ -1;\n  }\n  return Xn = t, Xn;\n}\nvar Jn, xi;\nfunction Dr() {\n  return xi || (xi = 1, Jn = {\n    2: \"need dictionary\",\n    /* Z_NEED_DICT       2  */\n    1: \"stream end\",\n    /* Z_STREAM_END      1  */\n    0: \"\",\n    /* Z_OK              0  */\n    \"-1\": \"file error\",\n    /* Z_ERRNO         (-1) */\n    \"-2\": \"stream error\",\n    /* Z_STREAM_ERROR  (-2) */\n    \"-3\": \"data error\",\n    /* Z_DATA_ERROR    (-3) */\n    \"-4\": \"insufficient memory\",\n    /* Z_MEM_ERROR     (-4) */\n    \"-5\": \"buffer error\",\n    /* Z_BUF_ERROR     (-5) */\n    \"-6\": \"incompatible version\"\n    /* Z_VERSION_ERROR (-6) */\n  }), Jn;\n}\nvar Ei;\nfunction Qo() {\n  if (Ei) return qe;\n  Ei = 1;\n  var e = ct(), r = Yo(), t = Ca(), i = Ia(), f = Dr(), n = 0, a = 1, l = 3, s = 4, h = 5, u = 0, d = 1, g = -2, v = -3, c = -5, R = -1, S = 1, b = 2, x = 3, m = 4, k = 0, L = 2, z = 8, E = 9, T = 15, I = 8, D = 29, C = 256, O = C + 1 + D, N = 30, U = 19, X = 2 * O + 1, Y = 15, q = 3, V = 258, ne = V + q + 1, ve = 32, be = 42, de = 69, he = 73, ge = 91, ue = 103, re = 113, ie = 666, G = 1, W = 2, Ee = 3, ze = 4, te = 3;\n  function pe(o, M) {\n    return o.msg = f[M], M;\n  }\n  function Ne(o) {\n    return (o << 1) - (o > 4 ? 9 : 0);\n  }\n  function Ie(o) {\n    for (var M = o.length; --M >= 0; )\n      o[M] = 0;\n  }\n  function ye(o) {\n    var M = o.state, Z = M.pending;\n    Z > o.avail_out && (Z = o.avail_out), Z !== 0 && (e.arraySet(o.output, M.pending_buf, M.pending_out, Z, o.next_out), o.next_out += Z, M.pending_out += Z, o.total_out += Z, o.avail_out -= Z, M.pending -= Z, M.pending === 0 && (M.pending_out = 0));\n  }\n  function ce(o, M) {\n    r._tr_flush_block(o, o.block_start >= 0 ? o.block_start : -1, o.strstart - o.block_start, M), o.block_start = o.strstart, ye(o.strm);\n  }\n  function ae(o, M) {\n    o.pending_buf[o.pending++] = M;\n  }\n  function Ze(o, M) {\n    o.pending_buf[o.pending++] = M >>> 8 & 255, o.pending_buf[o.pending++] = M & 255;\n  }\n  function yt(o, M, Z, w) {\n    var y = o.avail_in;\n    return y > w && (y = w), y === 0 ? 0 : (o.avail_in -= y, e.arraySet(M, o.input, o.next_in, y, Z), o.state.wrap === 1 ? o.adler = t(o.adler, M, y, Z) : o.state.wrap === 2 && (o.adler = i(o.adler, M, y, Z)), o.next_in += y, o.total_in += y, y);\n  }\n  function rt(o, M) {\n    var Z = o.max_chain_length, w = o.strstart, y, B, J = o.prev_length, K = o.nice_match, Q = o.strstart > o.w_size - ne ? o.strstart - (o.w_size - ne) : 0, fe = o.window, We = o.w_mask, we = o.prev, le = o.strstart + V, ke = fe[w + J - 1], Te = fe[w + J];\n    o.prev_length >= o.good_match && (Z >>= 2), K > o.lookahead && (K = o.lookahead);\n    do\n      if (y = M, !(fe[y + J] !== Te || fe[y + J - 1] !== ke || fe[y] !== fe[w] || fe[++y] !== fe[w + 1])) {\n        w += 2, y++;\n        do\n          ;\n        while (fe[++w] === fe[++y] && fe[++w] === fe[++y] && fe[++w] === fe[++y] && fe[++w] === fe[++y] && fe[++w] === fe[++y] && fe[++w] === fe[++y] && fe[++w] === fe[++y] && fe[++w] === fe[++y] && w < le);\n        if (B = V - (le - w), w = le - V, B > J) {\n          if (o.match_start = M, J = B, B >= K)\n            break;\n          ke = fe[w + J - 1], Te = fe[w + J];\n        }\n      }\n    while ((M = we[M & We]) > Q && --Z !== 0);\n    return J <= o.lookahead ? J : o.lookahead;\n  }\n  function Oe(o) {\n    var M = o.w_size, Z, w, y, B, J;\n    do {\n      if (B = o.window_size - o.lookahead - o.strstart, o.strstart >= M + (M - ne)) {\n        e.arraySet(o.window, o.window, M, M, 0), o.match_start -= M, o.strstart -= M, o.block_start -= M, w = o.hash_size, Z = w;\n        do\n          y = o.head[--Z], o.head[Z] = y >= M ? y - M : 0;\n        while (--w);\n        w = M, Z = w;\n        do\n          y = o.prev[--Z], o.prev[Z] = y >= M ? y - M : 0;\n        while (--w);\n        B += M;\n      }\n      if (o.strm.avail_in === 0)\n        break;\n      if (w = yt(o.strm, o.window, o.strstart + o.lookahead, B), o.lookahead += w, o.lookahead + o.insert >= q)\n        for (J = o.strstart - o.insert, o.ins_h = o.window[J], o.ins_h = (o.ins_h << o.hash_shift ^ o.window[J + 1]) & o.hash_mask; o.insert && (o.ins_h = (o.ins_h << o.hash_shift ^ o.window[J + q - 1]) & o.hash_mask, o.prev[J & o.w_mask] = o.head[o.ins_h], o.head[o.ins_h] = J, J++, o.insert--, !(o.lookahead + o.insert < q)); )\n          ;\n    } while (o.lookahead < ne && o.strm.avail_in !== 0);\n  }\n  function At(o, M) {\n    var Z = 65535;\n    for (Z > o.pending_buf_size - 5 && (Z = o.pending_buf_size - 5); ; ) {\n      if (o.lookahead <= 1) {\n        if (Oe(o), o.lookahead === 0 && M === n)\n          return G;\n        if (o.lookahead === 0)\n          break;\n      }\n      o.strstart += o.lookahead, o.lookahead = 0;\n      var w = o.block_start + Z;\n      if ((o.strstart === 0 || o.strstart >= w) && (o.lookahead = o.strstart - w, o.strstart = w, ce(o, !1), o.strm.avail_out === 0) || o.strstart - o.block_start >= o.w_size - ne && (ce(o, !1), o.strm.avail_out === 0))\n        return G;\n    }\n    return o.insert = 0, M === s ? (ce(o, !0), o.strm.avail_out === 0 ? Ee : ze) : (o.strstart > o.block_start && (ce(o, !1), o.strm.avail_out === 0), G);\n  }\n  function it(o, M) {\n    for (var Z, w; ; ) {\n      if (o.lookahead < ne) {\n        if (Oe(o), o.lookahead < ne && M === n)\n          return G;\n        if (o.lookahead === 0)\n          break;\n      }\n      if (Z = 0, o.lookahead >= q && (o.ins_h = (o.ins_h << o.hash_shift ^ o.window[o.strstart + q - 1]) & o.hash_mask, Z = o.prev[o.strstart & o.w_mask] = o.head[o.ins_h], o.head[o.ins_h] = o.strstart), Z !== 0 && o.strstart - Z <= o.w_size - ne && (o.match_length = rt(o, Z)), o.match_length >= q)\n        if (w = r._tr_tally(o, o.strstart - o.match_start, o.match_length - q), o.lookahead -= o.match_length, o.match_length <= o.max_lazy_match && o.lookahead >= q) {\n          o.match_length--;\n          do\n            o.strstart++, o.ins_h = (o.ins_h << o.hash_shift ^ o.window[o.strstart + q - 1]) & o.hash_mask, Z = o.prev[o.strstart & o.w_mask] = o.head[o.ins_h], o.head[o.ins_h] = o.strstart;\n          while (--o.match_length !== 0);\n          o.strstart++;\n        } else\n          o.strstart += o.match_length, o.match_length = 0, o.ins_h = o.window[o.strstart], o.ins_h = (o.ins_h << o.hash_shift ^ o.window[o.strstart + 1]) & o.hash_mask;\n      else\n        w = r._tr_tally(o, 0, o.window[o.strstart]), o.lookahead--, o.strstart++;\n      if (w && (ce(o, !1), o.strm.avail_out === 0))\n        return G;\n    }\n    return o.insert = o.strstart < q - 1 ? o.strstart : q - 1, M === s ? (ce(o, !0), o.strm.avail_out === 0 ? Ee : ze) : o.last_lit && (ce(o, !1), o.strm.avail_out === 0) ? G : W;\n  }\n  function Pe(o, M) {\n    for (var Z, w, y; ; ) {\n      if (o.lookahead < ne) {\n        if (Oe(o), o.lookahead < ne && M === n)\n          return G;\n        if (o.lookahead === 0)\n          break;\n      }\n      if (Z = 0, o.lookahead >= q && (o.ins_h = (o.ins_h << o.hash_shift ^ o.window[o.strstart + q - 1]) & o.hash_mask, Z = o.prev[o.strstart & o.w_mask] = o.head[o.ins_h], o.head[o.ins_h] = o.strstart), o.prev_length = o.match_length, o.prev_match = o.match_start, o.match_length = q - 1, Z !== 0 && o.prev_length < o.max_lazy_match && o.strstart - Z <= o.w_size - ne && (o.match_length = rt(o, Z), o.match_length <= 5 && (o.strategy === S || o.match_length === q && o.strstart - o.match_start > 4096) && (o.match_length = q - 1)), o.prev_length >= q && o.match_length <= o.prev_length) {\n        y = o.strstart + o.lookahead - q, w = r._tr_tally(o, o.strstart - 1 - o.prev_match, o.prev_length - q), o.lookahead -= o.prev_length - 1, o.prev_length -= 2;\n        do\n          ++o.strstart <= y && (o.ins_h = (o.ins_h << o.hash_shift ^ o.window[o.strstart + q - 1]) & o.hash_mask, Z = o.prev[o.strstart & o.w_mask] = o.head[o.ins_h], o.head[o.ins_h] = o.strstart);\n        while (--o.prev_length !== 0);\n        if (o.match_available = 0, o.match_length = q - 1, o.strstart++, w && (ce(o, !1), o.strm.avail_out === 0))\n          return G;\n      } else if (o.match_available) {\n        if (w = r._tr_tally(o, 0, o.window[o.strstart - 1]), w && ce(o, !1), o.strstart++, o.lookahead--, o.strm.avail_out === 0)\n          return G;\n      } else\n        o.match_available = 1, o.strstart++, o.lookahead--;\n    }\n    return o.match_available && (w = r._tr_tally(o, 0, o.window[o.strstart - 1]), o.match_available = 0), o.insert = o.strstart < q - 1 ? o.strstart : q - 1, M === s ? (ce(o, !0), o.strm.avail_out === 0 ? Ee : ze) : o.last_lit && (ce(o, !1), o.strm.avail_out === 0) ? G : W;\n  }\n  function St(o, M) {\n    for (var Z, w, y, B, J = o.window; ; ) {\n      if (o.lookahead <= V) {\n        if (Oe(o), o.lookahead <= V && M === n)\n          return G;\n        if (o.lookahead === 0)\n          break;\n      }\n      if (o.match_length = 0, o.lookahead >= q && o.strstart > 0 && (y = o.strstart - 1, w = J[y], w === J[++y] && w === J[++y] && w === J[++y])) {\n        B = o.strstart + V;\n        do\n          ;\n        while (w === J[++y] && w === J[++y] && w === J[++y] && w === J[++y] && w === J[++y] && w === J[++y] && w === J[++y] && w === J[++y] && y < B);\n        o.match_length = V - (B - y), o.match_length > o.lookahead && (o.match_length = o.lookahead);\n      }\n      if (o.match_length >= q ? (Z = r._tr_tally(o, 1, o.match_length - q), o.lookahead -= o.match_length, o.strstart += o.match_length, o.match_length = 0) : (Z = r._tr_tally(o, 0, o.window[o.strstart]), o.lookahead--, o.strstart++), Z && (ce(o, !1), o.strm.avail_out === 0))\n        return G;\n    }\n    return o.insert = 0, M === s ? (ce(o, !0), o.strm.avail_out === 0 ? Ee : ze) : o.last_lit && (ce(o, !1), o.strm.avail_out === 0) ? G : W;\n  }\n  function at(o, M) {\n    for (var Z; ; ) {\n      if (o.lookahead === 0 && (Oe(o), o.lookahead === 0)) {\n        if (M === n)\n          return G;\n        break;\n      }\n      if (o.match_length = 0, Z = r._tr_tally(o, 0, o.window[o.strstart]), o.lookahead--, o.strstart++, Z && (ce(o, !1), o.strm.avail_out === 0))\n        return G;\n    }\n    return o.insert = 0, M === s ? (ce(o, !0), o.strm.avail_out === 0 ? Ee : ze) : o.last_lit && (ce(o, !1), o.strm.avail_out === 0) ? G : W;\n  }\n  function Re(o, M, Z, w, y) {\n    this.good_length = o, this.max_lazy = M, this.nice_length = Z, this.max_chain = w, this.func = y;\n  }\n  var Ke;\n  Ke = [\n    /*      good lazy nice chain */\n    new Re(0, 0, 0, 0, At),\n    /* 0 store only */\n    new Re(4, 4, 8, 4, it),\n    /* 1 max speed, no lazy matches */\n    new Re(4, 5, 16, 8, it),\n    /* 2 */\n    new Re(4, 6, 32, 32, it),\n    /* 3 */\n    new Re(4, 4, 16, 16, Pe),\n    /* 4 lazy matches */\n    new Re(8, 16, 32, 32, Pe),\n    /* 5 */\n    new Re(8, 16, 128, 128, Pe),\n    /* 6 */\n    new Re(8, 32, 128, 256, Pe),\n    /* 7 */\n    new Re(32, 128, 258, 1024, Pe),\n    /* 8 */\n    new Re(32, 258, 258, 4096, Pe)\n    /* 9 max compression */\n  ];\n  function Rt(o) {\n    o.window_size = 2 * o.w_size, Ie(o.head), o.max_lazy_match = Ke[o.level].max_lazy, o.good_match = Ke[o.level].good_length, o.nice_match = Ke[o.level].nice_length, o.max_chain_length = Ke[o.level].max_chain, o.strstart = 0, o.block_start = 0, o.lookahead = 0, o.insert = 0, o.match_length = o.prev_length = q - 1, o.match_available = 0, o.ins_h = 0;\n  }\n  function p() {\n    this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = z, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new e.Buf16(X * 2), this.dyn_dtree = new e.Buf16((2 * N + 1) * 2), this.bl_tree = new e.Buf16((2 * U + 1) * 2), Ie(this.dyn_ltree), Ie(this.dyn_dtree), Ie(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new e.Buf16(Y + 1), this.heap = new e.Buf16(2 * O + 1), Ie(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new e.Buf16(2 * O + 1), Ie(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;\n  }\n  function F(o) {\n    var M;\n    return !o || !o.state ? pe(o, g) : (o.total_in = o.total_out = 0, o.data_type = L, M = o.state, M.pending = 0, M.pending_out = 0, M.wrap < 0 && (M.wrap = -M.wrap), M.status = M.wrap ? be : re, o.adler = M.wrap === 2 ? 0 : 1, M.last_flush = n, r._tr_init(M), u);\n  }\n  function P(o) {\n    var M = F(o);\n    return M === u && Rt(o.state), M;\n  }\n  function j(o, M) {\n    return !o || !o.state || o.state.wrap !== 2 ? g : (o.state.gzhead = M, u);\n  }\n  function A(o, M, Z, w, y, B) {\n    if (!o)\n      return g;\n    var J = 1;\n    if (M === R && (M = 6), w < 0 ? (J = 0, w = -w) : w > 15 && (J = 2, w -= 16), y < 1 || y > E || Z !== z || w < 8 || w > 15 || M < 0 || M > 9 || B < 0 || B > m)\n      return pe(o, g);\n    w === 8 && (w = 9);\n    var K = new p();\n    return o.state = K, K.strm = o, K.wrap = J, K.gzhead = null, K.w_bits = w, K.w_size = 1 << K.w_bits, K.w_mask = K.w_size - 1, K.hash_bits = y + 7, K.hash_size = 1 << K.hash_bits, K.hash_mask = K.hash_size - 1, K.hash_shift = ~~((K.hash_bits + q - 1) / q), K.window = new e.Buf8(K.w_size * 2), K.head = new e.Buf16(K.hash_size), K.prev = new e.Buf16(K.w_size), K.lit_bufsize = 1 << y + 6, K.pending_buf_size = K.lit_bufsize * 4, K.pending_buf = new e.Buf8(K.pending_buf_size), K.d_buf = 1 * K.lit_bufsize, K.l_buf = 3 * K.lit_bufsize, K.level = M, K.strategy = B, K.method = Z, P(o);\n  }\n  function H(o, M) {\n    return A(o, M, z, T, I, k);\n  }\n  function _(o, M) {\n    var Z, w, y, B;\n    if (!o || !o.state || M > h || M < 0)\n      return o ? pe(o, g) : g;\n    if (w = o.state, !o.output || !o.input && o.avail_in !== 0 || w.status === ie && M !== s)\n      return pe(o, o.avail_out === 0 ? c : g);\n    if (w.strm = o, Z = w.last_flush, w.last_flush = M, w.status === be)\n      if (w.wrap === 2)\n        o.adler = 0, ae(w, 31), ae(w, 139), ae(w, 8), w.gzhead ? (ae(\n          w,\n          (w.gzhead.text ? 1 : 0) + (w.gzhead.hcrc ? 2 : 0) + (w.gzhead.extra ? 4 : 0) + (w.gzhead.name ? 8 : 0) + (w.gzhead.comment ? 16 : 0)\n        ), ae(w, w.gzhead.time & 255), ae(w, w.gzhead.time >> 8 & 255), ae(w, w.gzhead.time >> 16 & 255), ae(w, w.gzhead.time >> 24 & 255), ae(w, w.level === 9 ? 2 : w.strategy >= b || w.level < 2 ? 4 : 0), ae(w, w.gzhead.os & 255), w.gzhead.extra && w.gzhead.extra.length && (ae(w, w.gzhead.extra.length & 255), ae(w, w.gzhead.extra.length >> 8 & 255)), w.gzhead.hcrc && (o.adler = i(o.adler, w.pending_buf, w.pending, 0)), w.gzindex = 0, w.status = de) : (ae(w, 0), ae(w, 0), ae(w, 0), ae(w, 0), ae(w, 0), ae(w, w.level === 9 ? 2 : w.strategy >= b || w.level < 2 ? 4 : 0), ae(w, te), w.status = re);\n      else {\n        var J = z + (w.w_bits - 8 << 4) << 8, K = -1;\n        w.strategy >= b || w.level < 2 ? K = 0 : w.level < 6 ? K = 1 : w.level === 6 ? K = 2 : K = 3, J |= K << 6, w.strstart !== 0 && (J |= ve), J += 31 - J % 31, w.status = re, Ze(w, J), w.strstart !== 0 && (Ze(w, o.adler >>> 16), Ze(w, o.adler & 65535)), o.adler = 1;\n      }\n    if (w.status === de)\n      if (w.gzhead.extra) {\n        for (y = w.pending; w.gzindex < (w.gzhead.extra.length & 65535) && !(w.pending === w.pending_buf_size && (w.gzhead.hcrc && w.pending > y && (o.adler = i(o.adler, w.pending_buf, w.pending - y, y)), ye(o), y = w.pending, w.pending === w.pending_buf_size)); )\n          ae(w, w.gzhead.extra[w.gzindex] & 255), w.gzindex++;\n        w.gzhead.hcrc && w.pending > y && (o.adler = i(o.adler, w.pending_buf, w.pending - y, y)), w.gzindex === w.gzhead.extra.length && (w.gzindex = 0, w.status = he);\n      } else\n        w.status = he;\n    if (w.status === he)\n      if (w.gzhead.name) {\n        y = w.pending;\n        do {\n          if (w.pending === w.pending_buf_size && (w.gzhead.hcrc && w.pending > y && (o.adler = i(o.adler, w.pending_buf, w.pending - y, y)), ye(o), y = w.pending, w.pending === w.pending_buf_size)) {\n            B = 1;\n            break;\n          }\n          w.gzindex < w.gzhead.name.length ? B = w.gzhead.name.charCodeAt(w.gzindex++) & 255 : B = 0, ae(w, B);\n        } while (B !== 0);\n        w.gzhead.hcrc && w.pending > y && (o.adler = i(o.adler, w.pending_buf, w.pending - y, y)), B === 0 && (w.gzindex = 0, w.status = ge);\n      } else\n        w.status = ge;\n    if (w.status === ge)\n      if (w.gzhead.comment) {\n        y = w.pending;\n        do {\n          if (w.pending === w.pending_buf_size && (w.gzhead.hcrc && w.pending > y && (o.adler = i(o.adler, w.pending_buf, w.pending - y, y)), ye(o), y = w.pending, w.pending === w.pending_buf_size)) {\n            B = 1;\n            break;\n          }\n          w.gzindex < w.gzhead.comment.length ? B = w.gzhead.comment.charCodeAt(w.gzindex++) & 255 : B = 0, ae(w, B);\n        } while (B !== 0);\n        w.gzhead.hcrc && w.pending > y && (o.adler = i(o.adler, w.pending_buf, w.pending - y, y)), B === 0 && (w.status = ue);\n      } else\n        w.status = ue;\n    if (w.status === ue && (w.gzhead.hcrc ? (w.pending + 2 > w.pending_buf_size && ye(o), w.pending + 2 <= w.pending_buf_size && (ae(w, o.adler & 255), ae(w, o.adler >> 8 & 255), o.adler = 0, w.status = re)) : w.status = re), w.pending !== 0) {\n      if (ye(o), o.avail_out === 0)\n        return w.last_flush = -1, u;\n    } else if (o.avail_in === 0 && Ne(M) <= Ne(Z) && M !== s)\n      return pe(o, c);\n    if (w.status === ie && o.avail_in !== 0)\n      return pe(o, c);\n    if (o.avail_in !== 0 || w.lookahead !== 0 || M !== n && w.status !== ie) {\n      var Q = w.strategy === b ? at(w, M) : w.strategy === x ? St(w, M) : Ke[w.level].func(w, M);\n      if ((Q === Ee || Q === ze) && (w.status = ie), Q === G || Q === Ee)\n        return o.avail_out === 0 && (w.last_flush = -1), u;\n      if (Q === W && (M === a ? r._tr_align(w) : M !== h && (r._tr_stored_block(w, 0, 0, !1), M === l && (Ie(w.head), w.lookahead === 0 && (w.strstart = 0, w.block_start = 0, w.insert = 0))), ye(o), o.avail_out === 0))\n        return w.last_flush = -1, u;\n    }\n    return M !== s ? u : w.wrap <= 0 ? d : (w.wrap === 2 ? (ae(w, o.adler & 255), ae(w, o.adler >> 8 & 255), ae(w, o.adler >> 16 & 255), ae(w, o.adler >> 24 & 255), ae(w, o.total_in & 255), ae(w, o.total_in >> 8 & 255), ae(w, o.total_in >> 16 & 255), ae(w, o.total_in >> 24 & 255)) : (Ze(w, o.adler >>> 16), Ze(w, o.adler & 65535)), ye(o), w.wrap > 0 && (w.wrap = -w.wrap), w.pending !== 0 ? u : d);\n  }\n  function $(o) {\n    var M;\n    return !o || !o.state ? g : (M = o.state.status, M !== be && M !== de && M !== he && M !== ge && M !== ue && M !== re && M !== ie ? pe(o, g) : (o.state = null, M === re ? pe(o, v) : u));\n  }\n  function ee(o, M) {\n    var Z = M.length, w, y, B, J, K, Q, fe, We;\n    if (!o || !o.state || (w = o.state, J = w.wrap, J === 2 || J === 1 && w.status !== be || w.lookahead))\n      return g;\n    for (J === 1 && (o.adler = t(o.adler, M, Z, 0)), w.wrap = 0, Z >= w.w_size && (J === 0 && (Ie(w.head), w.strstart = 0, w.block_start = 0, w.insert = 0), We = new e.Buf8(w.w_size), e.arraySet(We, M, Z - w.w_size, w.w_size, 0), M = We, Z = w.w_size), K = o.avail_in, Q = o.next_in, fe = o.input, o.avail_in = Z, o.next_in = 0, o.input = M, Oe(w); w.lookahead >= q; ) {\n      y = w.strstart, B = w.lookahead - (q - 1);\n      do\n        w.ins_h = (w.ins_h << w.hash_shift ^ w.window[y + q - 1]) & w.hash_mask, w.prev[y & w.w_mask] = w.head[w.ins_h], w.head[w.ins_h] = y, y++;\n      while (--B);\n      w.strstart = y, w.lookahead = q - 1, Oe(w);\n    }\n    return w.strstart += w.lookahead, w.block_start = w.strstart, w.insert = w.lookahead, w.lookahead = 0, w.match_length = w.prev_length = q - 1, w.match_available = 0, o.next_in = Q, o.input = fe, o.avail_in = K, w.wrap = J, u;\n  }\n  return qe.deflateInit = H, qe.deflateInit2 = A, qe.deflateReset = P, qe.deflateResetKeep = F, qe.deflateSetHeader = j, qe.deflate = _, qe.deflateEnd = $, qe.deflateSetDictionary = ee, qe.deflateInfo = \"pako deflate (from Nodeca project)\", qe;\n}\nvar _t = {}, ki;\nfunction Da() {\n  if (ki) return _t;\n  ki = 1;\n  var e = ct(), r = !0, t = !0;\n  try {\n    String.fromCharCode.apply(null, [0]);\n  } catch {\n    r = !1;\n  }\n  try {\n    String.fromCharCode.apply(null, new Uint8Array(1));\n  } catch {\n    t = !1;\n  }\n  for (var i = new e.Buf8(256), f = 0; f < 256; f++)\n    i[f] = f >= 252 ? 6 : f >= 248 ? 5 : f >= 240 ? 4 : f >= 224 ? 3 : f >= 192 ? 2 : 1;\n  i[254] = i[254] = 1, _t.string2buf = function(a) {\n    var l, s, h, u, d, g = a.length, v = 0;\n    for (u = 0; u < g; u++)\n      s = a.charCodeAt(u), (s & 64512) === 55296 && u + 1 < g && (h = a.charCodeAt(u + 1), (h & 64512) === 56320 && (s = 65536 + (s - 55296 << 10) + (h - 56320), u++)), v += s < 128 ? 1 : s < 2048 ? 2 : s < 65536 ? 3 : 4;\n    for (l = new e.Buf8(v), d = 0, u = 0; d < v; u++)\n      s = a.charCodeAt(u), (s & 64512) === 55296 && u + 1 < g && (h = a.charCodeAt(u + 1), (h & 64512) === 56320 && (s = 65536 + (s - 55296 << 10) + (h - 56320), u++)), s < 128 ? l[d++] = s : s < 2048 ? (l[d++] = 192 | s >>> 6, l[d++] = 128 | s & 63) : s < 65536 ? (l[d++] = 224 | s >>> 12, l[d++] = 128 | s >>> 6 & 63, l[d++] = 128 | s & 63) : (l[d++] = 240 | s >>> 18, l[d++] = 128 | s >>> 12 & 63, l[d++] = 128 | s >>> 6 & 63, l[d++] = 128 | s & 63);\n    return l;\n  };\n  function n(a, l) {\n    if (l < 65534 && (a.subarray && t || !a.subarray && r))\n      return String.fromCharCode.apply(null, e.shrinkBuf(a, l));\n    for (var s = \"\", h = 0; h < l; h++)\n      s += String.fromCharCode(a[h]);\n    return s;\n  }\n  return _t.buf2binstring = function(a) {\n    return n(a, a.length);\n  }, _t.binstring2buf = function(a) {\n    for (var l = new e.Buf8(a.length), s = 0, h = l.length; s < h; s++)\n      l[s] = a.charCodeAt(s);\n    return l;\n  }, _t.buf2string = function(a, l) {\n    var s, h, u, d, g = l || a.length, v = new Array(g * 2);\n    for (h = 0, s = 0; s < g; ) {\n      if (u = a[s++], u < 128) {\n        v[h++] = u;\n        continue;\n      }\n      if (d = i[u], d > 4) {\n        v[h++] = 65533, s += d - 1;\n        continue;\n      }\n      for (u &= d === 2 ? 31 : d === 3 ? 15 : 7; d > 1 && s < g; )\n        u = u << 6 | a[s++] & 63, d--;\n      if (d > 1) {\n        v[h++] = 65533;\n        continue;\n      }\n      u < 65536 ? v[h++] = u : (u -= 65536, v[h++] = 55296 | u >> 10 & 1023, v[h++] = 56320 | u & 1023);\n    }\n    return n(v, h);\n  }, _t.utf8border = function(a, l) {\n    var s;\n    for (l = l || a.length, l > a.length && (l = a.length), s = l - 1; s >= 0 && (a[s] & 192) === 128; )\n      s--;\n    return s < 0 || s === 0 ? l : s + i[a[s]] > l ? s : l;\n  }, _t;\n}\nvar Wn, mi;\nfunction La() {\n  if (mi) return Wn;\n  mi = 1;\n  function e() {\n    this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = \"\", this.state = null, this.data_type = 2, this.adler = 0;\n  }\n  return Wn = e, Wn;\n}\nvar yi;\nfunction Vo() {\n  if (yi) return zt;\n  yi = 1;\n  var e = Qo(), r = ct(), t = Da(), i = Dr(), f = La(), n = Object.prototype.toString, a = 0, l = 4, s = 0, h = 1, u = 2, d = -1, g = 0, v = 8;\n  function c(x) {\n    if (!(this instanceof c)) return new c(x);\n    this.options = r.assign({\n      level: d,\n      method: v,\n      chunkSize: 16384,\n      windowBits: 15,\n      memLevel: 8,\n      strategy: g,\n      to: \"\"\n    }, x || {});\n    var m = this.options;\n    m.raw && m.windowBits > 0 ? m.windowBits = -m.windowBits : m.gzip && m.windowBits > 0 && m.windowBits < 16 && (m.windowBits += 16), this.err = 0, this.msg = \"\", this.ended = !1, this.chunks = [], this.strm = new f(), this.strm.avail_out = 0;\n    var k = e.deflateInit2(\n      this.strm,\n      m.level,\n      m.method,\n      m.windowBits,\n      m.memLevel,\n      m.strategy\n    );\n    if (k !== s)\n      throw new Error(i[k]);\n    if (m.header && e.deflateSetHeader(this.strm, m.header), m.dictionary) {\n      var L;\n      if (typeof m.dictionary == \"string\" ? L = t.string2buf(m.dictionary) : n.call(m.dictionary) === \"[object ArrayBuffer]\" ? L = new Uint8Array(m.dictionary) : L = m.dictionary, k = e.deflateSetDictionary(this.strm, L), k !== s)\n        throw new Error(i[k]);\n      this._dict_set = !0;\n    }\n  }\n  c.prototype.push = function(x, m) {\n    var k = this.strm, L = this.options.chunkSize, z, E;\n    if (this.ended)\n      return !1;\n    E = m === ~~m ? m : m === !0 ? l : a, typeof x == \"string\" ? k.input = t.string2buf(x) : n.call(x) === \"[object ArrayBuffer]\" ? k.input = new Uint8Array(x) : k.input = x, k.next_in = 0, k.avail_in = k.input.length;\n    do {\n      if (k.avail_out === 0 && (k.output = new r.Buf8(L), k.next_out = 0, k.avail_out = L), z = e.deflate(k, E), z !== h && z !== s)\n        return this.onEnd(z), this.ended = !0, !1;\n      (k.avail_out === 0 || k.avail_in === 0 && (E === l || E === u)) && (this.options.to === \"string\" ? this.onData(t.buf2binstring(r.shrinkBuf(k.output, k.next_out))) : this.onData(r.shrinkBuf(k.output, k.next_out)));\n    } while ((k.avail_in > 0 || k.avail_out === 0) && z !== h);\n    return E === l ? (z = e.deflateEnd(this.strm), this.onEnd(z), this.ended = !0, z === s) : (E === u && (this.onEnd(s), k.avail_out = 0), !0);\n  }, c.prototype.onData = function(x) {\n    this.chunks.push(x);\n  }, c.prototype.onEnd = function(x) {\n    x === s && (this.options.to === \"string\" ? this.result = this.chunks.join(\"\") : this.result = r.flattenChunks(this.chunks)), this.chunks = [], this.err = x, this.msg = this.strm.msg;\n  };\n  function R(x, m) {\n    var k = new c(m);\n    if (k.push(x, !0), k.err)\n      throw k.msg || i[k.err];\n    return k.result;\n  }\n  function S(x, m) {\n    return m = m || {}, m.raw = !0, R(x, m);\n  }\n  function b(x, m) {\n    return m = m || {}, m.gzip = !0, R(x, m);\n  }\n  return zt.Deflate = c, zt.deflate = R, zt.deflateRaw = S, zt.gzip = b, zt;\n}\nvar Ct = {}, Ue = {}, Gn, Ai;\nfunction jo() {\n  if (Ai) return Gn;\n  Ai = 1;\n  var e = 30, r = 12;\n  return Gn = function(i, f) {\n    var n, a, l, s, h, u, d, g, v, c, R, S, b, x, m, k, L, z, E, T, I, D, C, O, N;\n    n = i.state, a = i.next_in, O = i.input, l = a + (i.avail_in - 5), s = i.next_out, N = i.output, h = s - (f - i.avail_out), u = s + (i.avail_out - 257), d = n.dmax, g = n.wsize, v = n.whave, c = n.wnext, R = n.window, S = n.hold, b = n.bits, x = n.lencode, m = n.distcode, k = (1 << n.lenbits) - 1, L = (1 << n.distbits) - 1;\n    e:\n      do {\n        b < 15 && (S += O[a++] << b, b += 8, S += O[a++] << b, b += 8), z = x[S & k];\n        t:\n          for (; ; ) {\n            if (E = z >>> 24, S >>>= E, b -= E, E = z >>> 16 & 255, E === 0)\n              N[s++] = z & 65535;\n            else if (E & 16) {\n              T = z & 65535, E &= 15, E && (b < E && (S += O[a++] << b, b += 8), T += S & (1 << E) - 1, S >>>= E, b -= E), b < 15 && (S += O[a++] << b, b += 8, S += O[a++] << b, b += 8), z = m[S & L];\n              n:\n                for (; ; ) {\n                  if (E = z >>> 24, S >>>= E, b -= E, E = z >>> 16 & 255, E & 16) {\n                    if (I = z & 65535, E &= 15, b < E && (S += O[a++] << b, b += 8, b < E && (S += O[a++] << b, b += 8)), I += S & (1 << E) - 1, I > d) {\n                      i.msg = \"invalid distance too far back\", n.mode = e;\n                      break e;\n                    }\n                    if (S >>>= E, b -= E, E = s - h, I > E) {\n                      if (E = I - E, E > v && n.sane) {\n                        i.msg = \"invalid distance too far back\", n.mode = e;\n                        break e;\n                      }\n                      if (D = 0, C = R, c === 0) {\n                        if (D += g - E, E < T) {\n                          T -= E;\n                          do\n                            N[s++] = R[D++];\n                          while (--E);\n                          D = s - I, C = N;\n                        }\n                      } else if (c < E) {\n                        if (D += g + c - E, E -= c, E < T) {\n                          T -= E;\n                          do\n                            N[s++] = R[D++];\n                          while (--E);\n                          if (D = 0, c < T) {\n                            E = c, T -= E;\n                            do\n                              N[s++] = R[D++];\n                            while (--E);\n                            D = s - I, C = N;\n                          }\n                        }\n                      } else if (D += c - E, E < T) {\n                        T -= E;\n                        do\n                          N[s++] = R[D++];\n                        while (--E);\n                        D = s - I, C = N;\n                      }\n                      for (; T > 2; )\n                        N[s++] = C[D++], N[s++] = C[D++], N[s++] = C[D++], T -= 3;\n                      T && (N[s++] = C[D++], T > 1 && (N[s++] = C[D++]));\n                    } else {\n                      D = s - I;\n                      do\n                        N[s++] = N[D++], N[s++] = N[D++], N[s++] = N[D++], T -= 3;\n                      while (T > 2);\n                      T && (N[s++] = N[D++], T > 1 && (N[s++] = N[D++]));\n                    }\n                  } else if ((E & 64) === 0) {\n                    z = m[(z & 65535) + (S & (1 << E) - 1)];\n                    continue n;\n                  } else {\n                    i.msg = \"invalid distance code\", n.mode = e;\n                    break e;\n                  }\n                  break;\n                }\n            } else if ((E & 64) === 0) {\n              z = x[(z & 65535) + (S & (1 << E) - 1)];\n              continue t;\n            } else if (E & 32) {\n              n.mode = r;\n              break e;\n            } else {\n              i.msg = \"invalid literal/length code\", n.mode = e;\n              break e;\n            }\n            break;\n          }\n      } while (a < l && s < u);\n    T = b >> 3, a -= T, b -= T << 3, S &= (1 << b) - 1, i.next_in = a, i.next_out = s, i.avail_in = a < l ? 5 + (l - a) : 5 - (a - l), i.avail_out = s < u ? 257 + (u - s) : 257 - (s - u), n.hold = S, n.bits = b;\n  }, Gn;\n}\nvar er, Si;\nfunction Xo() {\n  if (Si) return er;\n  Si = 1;\n  var e = ct(), r = 15, t = 852, i = 592, f = 0, n = 1, a = 2, l = [\n    /* Length codes 257..285 base */\n    3,\n    4,\n    5,\n    6,\n    7,\n    8,\n    9,\n    10,\n    11,\n    13,\n    15,\n    17,\n    19,\n    23,\n    27,\n    31,\n    35,\n    43,\n    51,\n    59,\n    67,\n    83,\n    99,\n    115,\n    131,\n    163,\n    195,\n    227,\n    258,\n    0,\n    0\n  ], s = [\n    /* Length codes 257..285 extra */\n    16,\n    16,\n    16,\n    16,\n    16,\n    16,\n    16,\n    16,\n    17,\n    17,\n    17,\n    17,\n    18,\n    18,\n    18,\n    18,\n    19,\n    19,\n    19,\n    19,\n    20,\n    20,\n    20,\n    20,\n    21,\n    21,\n    21,\n    21,\n    16,\n    72,\n    78\n  ], h = [\n    /* Distance codes 0..29 base */\n    1,\n    2,\n    3,\n    4,\n    5,\n    7,\n    9,\n    13,\n    17,\n    25,\n    33,\n    49,\n    65,\n    97,\n    129,\n    193,\n    257,\n    385,\n    513,\n    769,\n    1025,\n    1537,\n    2049,\n    3073,\n    4097,\n    6145,\n    8193,\n    12289,\n    16385,\n    24577,\n    0,\n    0\n  ], u = [\n    /* Distance codes 0..29 extra */\n    16,\n    16,\n    16,\n    16,\n    17,\n    17,\n    18,\n    18,\n    19,\n    19,\n    20,\n    20,\n    21,\n    21,\n    22,\n    22,\n    23,\n    23,\n    24,\n    24,\n    25,\n    25,\n    26,\n    26,\n    27,\n    27,\n    28,\n    28,\n    29,\n    29,\n    64,\n    64\n  ];\n  return er = function(g, v, c, R, S, b, x, m) {\n    var k = m.bits, L = 0, z = 0, E = 0, T = 0, I = 0, D = 0, C = 0, O = 0, N = 0, U = 0, X, Y, q, V, ne, ve = null, be = 0, de, he = new e.Buf16(r + 1), ge = new e.Buf16(r + 1), ue = null, re = 0, ie, G, W;\n    for (L = 0; L <= r; L++)\n      he[L] = 0;\n    for (z = 0; z < R; z++)\n      he[v[c + z]]++;\n    for (I = k, T = r; T >= 1 && he[T] === 0; T--)\n      ;\n    if (I > T && (I = T), T === 0)\n      return S[b++] = 1 << 24 | 64 << 16 | 0, S[b++] = 1 << 24 | 64 << 16 | 0, m.bits = 1, 0;\n    for (E = 1; E < T && he[E] === 0; E++)\n      ;\n    for (I < E && (I = E), O = 1, L = 1; L <= r; L++)\n      if (O <<= 1, O -= he[L], O < 0)\n        return -1;\n    if (O > 0 && (g === f || T !== 1))\n      return -1;\n    for (ge[1] = 0, L = 1; L < r; L++)\n      ge[L + 1] = ge[L] + he[L];\n    for (z = 0; z < R; z++)\n      v[c + z] !== 0 && (x[ge[v[c + z]]++] = z);\n    if (g === f ? (ve = ue = x, de = 19) : g === n ? (ve = l, be -= 257, ue = s, re -= 257, de = 256) : (ve = h, ue = u, de = -1), U = 0, z = 0, L = E, ne = b, D = I, C = 0, q = -1, N = 1 << I, V = N - 1, g === n && N > t || g === a && N > i)\n      return 1;\n    for (; ; ) {\n      ie = L - C, x[z] < de ? (G = 0, W = x[z]) : x[z] > de ? (G = ue[re + x[z]], W = ve[be + x[z]]) : (G = 96, W = 0), X = 1 << L - C, Y = 1 << D, E = Y;\n      do\n        Y -= X, S[ne + (U >> C) + Y] = ie << 24 | G << 16 | W | 0;\n      while (Y !== 0);\n      for (X = 1 << L - 1; U & X; )\n        X >>= 1;\n      if (X !== 0 ? (U &= X - 1, U += X) : U = 0, z++, --he[L] === 0) {\n        if (L === T)\n          break;\n        L = v[c + x[z]];\n      }\n      if (L > I && (U & V) !== q) {\n        for (C === 0 && (C = I), ne += E, D = L - C, O = 1 << D; D + C < T && (O -= he[D + C], !(O <= 0)); )\n          D++, O <<= 1;\n        if (N += 1 << D, g === n && N > t || g === a && N > i)\n          return 1;\n        q = U & V, S[q] = I << 24 | D << 16 | ne - b | 0;\n      }\n    }\n    return U !== 0 && (S[ne + U] = L - C << 24 | 64 << 16 | 0), m.bits = I, 0;\n  }, er;\n}\nvar Ri;\nfunction Jo() {\n  if (Ri) return Ue;\n  Ri = 1;\n  var e = ct(), r = Ca(), t = Ia(), i = jo(), f = Xo(), n = 0, a = 1, l = 2, s = 4, h = 5, u = 6, d = 0, g = 1, v = 2, c = -2, R = -3, S = -4, b = -5, x = 8, m = 1, k = 2, L = 3, z = 4, E = 5, T = 6, I = 7, D = 8, C = 9, O = 10, N = 11, U = 12, X = 13, Y = 14, q = 15, V = 16, ne = 17, ve = 18, be = 19, de = 20, he = 21, ge = 22, ue = 23, re = 24, ie = 25, G = 26, W = 27, Ee = 28, ze = 29, te = 30, pe = 31, Ne = 32, Ie = 852, ye = 592, ce = 15, ae = ce;\n  function Ze(A) {\n    return (A >>> 24 & 255) + (A >>> 8 & 65280) + ((A & 65280) << 8) + ((A & 255) << 24);\n  }\n  function yt() {\n    this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new e.Buf16(320), this.work = new e.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;\n  }\n  function rt(A) {\n    var H;\n    return !A || !A.state ? c : (H = A.state, A.total_in = A.total_out = H.total = 0, A.msg = \"\", H.wrap && (A.adler = H.wrap & 1), H.mode = m, H.last = 0, H.havedict = 0, H.dmax = 32768, H.head = null, H.hold = 0, H.bits = 0, H.lencode = H.lendyn = new e.Buf32(Ie), H.distcode = H.distdyn = new e.Buf32(ye), H.sane = 1, H.back = -1, d);\n  }\n  function Oe(A) {\n    var H;\n    return !A || !A.state ? c : (H = A.state, H.wsize = 0, H.whave = 0, H.wnext = 0, rt(A));\n  }\n  function At(A, H) {\n    var _, $;\n    return !A || !A.state || ($ = A.state, H < 0 ? (_ = 0, H = -H) : (_ = (H >> 4) + 1, H < 48 && (H &= 15)), H && (H < 8 || H > 15)) ? c : ($.window !== null && $.wbits !== H && ($.window = null), $.wrap = _, $.wbits = H, Oe(A));\n  }\n  function it(A, H) {\n    var _, $;\n    return A ? ($ = new yt(), A.state = $, $.window = null, _ = At(A, H), _ !== d && (A.state = null), _) : c;\n  }\n  function Pe(A) {\n    return it(A, ae);\n  }\n  var St = !0, at, Re;\n  function Ke(A) {\n    if (St) {\n      var H;\n      for (at = new e.Buf32(512), Re = new e.Buf32(32), H = 0; H < 144; )\n        A.lens[H++] = 8;\n      for (; H < 256; )\n        A.lens[H++] = 9;\n      for (; H < 280; )\n        A.lens[H++] = 7;\n      for (; H < 288; )\n        A.lens[H++] = 8;\n      for (f(a, A.lens, 0, 288, at, 0, A.work, { bits: 9 }), H = 0; H < 32; )\n        A.lens[H++] = 5;\n      f(l, A.lens, 0, 32, Re, 0, A.work, { bits: 5 }), St = !1;\n    }\n    A.lencode = at, A.lenbits = 9, A.distcode = Re, A.distbits = 5;\n  }\n  function Rt(A, H, _, $) {\n    var ee, o = A.state;\n    return o.window === null && (o.wsize = 1 << o.wbits, o.wnext = 0, o.whave = 0, o.window = new e.Buf8(o.wsize)), $ >= o.wsize ? (e.arraySet(o.window, H, _ - o.wsize, o.wsize, 0), o.wnext = 0, o.whave = o.wsize) : (ee = o.wsize - o.wnext, ee > $ && (ee = $), e.arraySet(o.window, H, _ - $, ee, o.wnext), $ -= ee, $ ? (e.arraySet(o.window, H, _ - $, $, 0), o.wnext = $, o.whave = o.wsize) : (o.wnext += ee, o.wnext === o.wsize && (o.wnext = 0), o.whave < o.wsize && (o.whave += ee))), 0;\n  }\n  function p(A, H) {\n    var _, $, ee, o, M, Z, w, y, B, J, K, Q, fe, We, we = 0, le, ke, Te, De, on, fn, xe, He, Ae = new e.Buf8(4), Ge, Ye, Fr = (\n      /* permutation of code lengths */\n      [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]\n    );\n    if (!A || !A.state || !A.output || !A.input && A.avail_in !== 0)\n      return c;\n    _ = A.state, _.mode === U && (_.mode = X), M = A.next_out, ee = A.output, w = A.avail_out, o = A.next_in, $ = A.input, Z = A.avail_in, y = _.hold, B = _.bits, J = Z, K = w, He = d;\n    e:\n      for (; ; )\n        switch (_.mode) {\n          case m:\n            if (_.wrap === 0) {\n              _.mode = X;\n              break;\n            }\n            for (; B < 16; ) {\n              if (Z === 0)\n                break e;\n              Z--, y += $[o++] << B, B += 8;\n            }\n            if (_.wrap & 2 && y === 35615) {\n              _.check = 0, Ae[0] = y & 255, Ae[1] = y >>> 8 & 255, _.check = t(_.check, Ae, 2, 0), y = 0, B = 0, _.mode = k;\n              break;\n            }\n            if (_.flags = 0, _.head && (_.head.done = !1), !(_.wrap & 1) || /* check if zlib header allowed */\n            (((y & 255) << 8) + (y >> 8)) % 31) {\n              A.msg = \"incorrect header check\", _.mode = te;\n              break;\n            }\n            if ((y & 15) !== x) {\n              A.msg = \"unknown compression method\", _.mode = te;\n              break;\n            }\n            if (y >>>= 4, B -= 4, xe = (y & 15) + 8, _.wbits === 0)\n              _.wbits = xe;\n            else if (xe > _.wbits) {\n              A.msg = \"invalid window size\", _.mode = te;\n              break;\n            }\n            _.dmax = 1 << xe, A.adler = _.check = 1, _.mode = y & 512 ? O : U, y = 0, B = 0;\n            break;\n          case k:\n            for (; B < 16; ) {\n              if (Z === 0)\n                break e;\n              Z--, y += $[o++] << B, B += 8;\n            }\n            if (_.flags = y, (_.flags & 255) !== x) {\n              A.msg = \"unknown compression method\", _.mode = te;\n              break;\n            }\n            if (_.flags & 57344) {\n              A.msg = \"unknown header flags set\", _.mode = te;\n              break;\n            }\n            _.head && (_.head.text = y >> 8 & 1), _.flags & 512 && (Ae[0] = y & 255, Ae[1] = y >>> 8 & 255, _.check = t(_.check, Ae, 2, 0)), y = 0, B = 0, _.mode = L;\n          /* falls through */\n          case L:\n            for (; B < 32; ) {\n              if (Z === 0)\n                break e;\n              Z--, y += $[o++] << B, B += 8;\n            }\n            _.head && (_.head.time = y), _.flags & 512 && (Ae[0] = y & 255, Ae[1] = y >>> 8 & 255, Ae[2] = y >>> 16 & 255, Ae[3] = y >>> 24 & 255, _.check = t(_.check, Ae, 4, 0)), y = 0, B = 0, _.mode = z;\n          /* falls through */\n          case z:\n            for (; B < 16; ) {\n              if (Z === 0)\n                break e;\n              Z--, y += $[o++] << B, B += 8;\n            }\n            _.head && (_.head.xflags = y & 255, _.head.os = y >> 8), _.flags & 512 && (Ae[0] = y & 255, Ae[1] = y >>> 8 & 255, _.check = t(_.check, Ae, 2, 0)), y = 0, B = 0, _.mode = E;\n          /* falls through */\n          case E:\n            if (_.flags & 1024) {\n              for (; B < 16; ) {\n                if (Z === 0)\n                  break e;\n                Z--, y += $[o++] << B, B += 8;\n              }\n              _.length = y, _.head && (_.head.extra_len = y), _.flags & 512 && (Ae[0] = y & 255, Ae[1] = y >>> 8 & 255, _.check = t(_.check, Ae, 2, 0)), y = 0, B = 0;\n            } else _.head && (_.head.extra = null);\n            _.mode = T;\n          /* falls through */\n          case T:\n            if (_.flags & 1024 && (Q = _.length, Q > Z && (Q = Z), Q && (_.head && (xe = _.head.extra_len - _.length, _.head.extra || (_.head.extra = new Array(_.head.extra_len)), e.arraySet(\n              _.head.extra,\n              $,\n              o,\n              // extra field is limited to 65536 bytes\n              // - no need for additional size check\n              Q,\n              /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/\n              xe\n            )), _.flags & 512 && (_.check = t(_.check, $, Q, o)), Z -= Q, o += Q, _.length -= Q), _.length))\n              break e;\n            _.length = 0, _.mode = I;\n          /* falls through */\n          case I:\n            if (_.flags & 2048) {\n              if (Z === 0)\n                break e;\n              Q = 0;\n              do\n                xe = $[o + Q++], _.head && xe && _.length < 65536 && (_.head.name += String.fromCharCode(xe));\n              while (xe && Q < Z);\n              if (_.flags & 512 && (_.check = t(_.check, $, Q, o)), Z -= Q, o += Q, xe)\n                break e;\n            } else _.head && (_.head.name = null);\n            _.length = 0, _.mode = D;\n          /* falls through */\n          case D:\n            if (_.flags & 4096) {\n              if (Z === 0)\n                break e;\n              Q = 0;\n              do\n                xe = $[o + Q++], _.head && xe && _.length < 65536 && (_.head.comment += String.fromCharCode(xe));\n              while (xe && Q < Z);\n              if (_.flags & 512 && (_.check = t(_.check, $, Q, o)), Z -= Q, o += Q, xe)\n                break e;\n            } else _.head && (_.head.comment = null);\n            _.mode = C;\n          /* falls through */\n          case C:\n            if (_.flags & 512) {\n              for (; B < 16; ) {\n                if (Z === 0)\n                  break e;\n                Z--, y += $[o++] << B, B += 8;\n              }\n              if (y !== (_.check & 65535)) {\n                A.msg = \"header crc mismatch\", _.mode = te;\n                break;\n              }\n              y = 0, B = 0;\n            }\n            _.head && (_.head.hcrc = _.flags >> 9 & 1, _.head.done = !0), A.adler = _.check = 0, _.mode = U;\n            break;\n          case O:\n            for (; B < 32; ) {\n              if (Z === 0)\n                break e;\n              Z--, y += $[o++] << B, B += 8;\n            }\n            A.adler = _.check = Ze(y), y = 0, B = 0, _.mode = N;\n          /* falls through */\n          case N:\n            if (_.havedict === 0)\n              return A.next_out = M, A.avail_out = w, A.next_in = o, A.avail_in = Z, _.hold = y, _.bits = B, v;\n            A.adler = _.check = 1, _.mode = U;\n          /* falls through */\n          case U:\n            if (H === h || H === u)\n              break e;\n          /* falls through */\n          case X:\n            if (_.last) {\n              y >>>= B & 7, B -= B & 7, _.mode = W;\n              break;\n            }\n            for (; B < 3; ) {\n              if (Z === 0)\n                break e;\n              Z--, y += $[o++] << B, B += 8;\n            }\n            switch (_.last = y & 1, y >>>= 1, B -= 1, y & 3) {\n              case 0:\n                _.mode = Y;\n                break;\n              case 1:\n                if (Ke(_), _.mode = de, H === u) {\n                  y >>>= 2, B -= 2;\n                  break e;\n                }\n                break;\n              case 2:\n                _.mode = ne;\n                break;\n              case 3:\n                A.msg = \"invalid block type\", _.mode = te;\n            }\n            y >>>= 2, B -= 2;\n            break;\n          case Y:\n            for (y >>>= B & 7, B -= B & 7; B < 32; ) {\n              if (Z === 0)\n                break e;\n              Z--, y += $[o++] << B, B += 8;\n            }\n            if ((y & 65535) !== (y >>> 16 ^ 65535)) {\n              A.msg = \"invalid stored block lengths\", _.mode = te;\n              break;\n            }\n            if (_.length = y & 65535, y = 0, B = 0, _.mode = q, H === u)\n              break e;\n          /* falls through */\n          case q:\n            _.mode = V;\n          /* falls through */\n          case V:\n            if (Q = _.length, Q) {\n              if (Q > Z && (Q = Z), Q > w && (Q = w), Q === 0)\n                break e;\n              e.arraySet(ee, $, o, Q, M), Z -= Q, o += Q, w -= Q, M += Q, _.length -= Q;\n              break;\n            }\n            _.mode = U;\n            break;\n          case ne:\n            for (; B < 14; ) {\n              if (Z === 0)\n                break e;\n              Z--, y += $[o++] << B, B += 8;\n            }\n            if (_.nlen = (y & 31) + 257, y >>>= 5, B -= 5, _.ndist = (y & 31) + 1, y >>>= 5, B -= 5, _.ncode = (y & 15) + 4, y >>>= 4, B -= 4, _.nlen > 286 || _.ndist > 30) {\n              A.msg = \"too many length or distance symbols\", _.mode = te;\n              break;\n            }\n            _.have = 0, _.mode = ve;\n          /* falls through */\n          case ve:\n            for (; _.have < _.ncode; ) {\n              for (; B < 3; ) {\n                if (Z === 0)\n                  break e;\n                Z--, y += $[o++] << B, B += 8;\n              }\n              _.lens[Fr[_.have++]] = y & 7, y >>>= 3, B -= 3;\n            }\n            for (; _.have < 19; )\n              _.lens[Fr[_.have++]] = 0;\n            if (_.lencode = _.lendyn, _.lenbits = 7, Ge = { bits: _.lenbits }, He = f(n, _.lens, 0, 19, _.lencode, 0, _.work, Ge), _.lenbits = Ge.bits, He) {\n              A.msg = \"invalid code lengths set\", _.mode = te;\n              break;\n            }\n            _.have = 0, _.mode = be;\n          /* falls through */\n          case be:\n            for (; _.have < _.nlen + _.ndist; ) {\n              for (; we = _.lencode[y & (1 << _.lenbits) - 1], le = we >>> 24, ke = we >>> 16 & 255, Te = we & 65535, !(le <= B); ) {\n                if (Z === 0)\n                  break e;\n                Z--, y += $[o++] << B, B += 8;\n              }\n              if (Te < 16)\n                y >>>= le, B -= le, _.lens[_.have++] = Te;\n              else {\n                if (Te === 16) {\n                  for (Ye = le + 2; B < Ye; ) {\n                    if (Z === 0)\n                      break e;\n                    Z--, y += $[o++] << B, B += 8;\n                  }\n                  if (y >>>= le, B -= le, _.have === 0) {\n                    A.msg = \"invalid bit length repeat\", _.mode = te;\n                    break;\n                  }\n                  xe = _.lens[_.have - 1], Q = 3 + (y & 3), y >>>= 2, B -= 2;\n                } else if (Te === 17) {\n                  for (Ye = le + 3; B < Ye; ) {\n                    if (Z === 0)\n                      break e;\n                    Z--, y += $[o++] << B, B += 8;\n                  }\n                  y >>>= le, B -= le, xe = 0, Q = 3 + (y & 7), y >>>= 3, B -= 3;\n                } else {\n                  for (Ye = le + 7; B < Ye; ) {\n                    if (Z === 0)\n                      break e;\n                    Z--, y += $[o++] << B, B += 8;\n                  }\n                  y >>>= le, B -= le, xe = 0, Q = 11 + (y & 127), y >>>= 7, B -= 7;\n                }\n                if (_.have + Q > _.nlen + _.ndist) {\n                  A.msg = \"invalid bit length repeat\", _.mode = te;\n                  break;\n                }\n                for (; Q--; )\n                  _.lens[_.have++] = xe;\n              }\n            }\n            if (_.mode === te)\n              break;\n            if (_.lens[256] === 0) {\n              A.msg = \"invalid code -- missing end-of-block\", _.mode = te;\n              break;\n            }\n            if (_.lenbits = 9, Ge = { bits: _.lenbits }, He = f(a, _.lens, 0, _.nlen, _.lencode, 0, _.work, Ge), _.lenbits = Ge.bits, He) {\n              A.msg = \"invalid literal/lengths set\", _.mode = te;\n              break;\n            }\n            if (_.distbits = 6, _.distcode = _.distdyn, Ge = { bits: _.distbits }, He = f(l, _.lens, _.nlen, _.ndist, _.distcode, 0, _.work, Ge), _.distbits = Ge.bits, He) {\n              A.msg = \"invalid distances set\", _.mode = te;\n              break;\n            }\n            if (_.mode = de, H === u)\n              break e;\n          /* falls through */\n          case de:\n            _.mode = he;\n          /* falls through */\n          case he:\n            if (Z >= 6 && w >= 258) {\n              A.next_out = M, A.avail_out = w, A.next_in = o, A.avail_in = Z, _.hold = y, _.bits = B, i(A, K), M = A.next_out, ee = A.output, w = A.avail_out, o = A.next_in, $ = A.input, Z = A.avail_in, y = _.hold, B = _.bits, _.mode === U && (_.back = -1);\n              break;\n            }\n            for (_.back = 0; we = _.lencode[y & (1 << _.lenbits) - 1], le = we >>> 24, ke = we >>> 16 & 255, Te = we & 65535, !(le <= B); ) {\n              if (Z === 0)\n                break e;\n              Z--, y += $[o++] << B, B += 8;\n            }\n            if (ke && (ke & 240) === 0) {\n              for (De = le, on = ke, fn = Te; we = _.lencode[fn + ((y & (1 << De + on) - 1) >> De)], le = we >>> 24, ke = we >>> 16 & 255, Te = we & 65535, !(De + le <= B); ) {\n                if (Z === 0)\n                  break e;\n                Z--, y += $[o++] << B, B += 8;\n              }\n              y >>>= De, B -= De, _.back += De;\n            }\n            if (y >>>= le, B -= le, _.back += le, _.length = Te, ke === 0) {\n              _.mode = G;\n              break;\n            }\n            if (ke & 32) {\n              _.back = -1, _.mode = U;\n              break;\n            }\n            if (ke & 64) {\n              A.msg = \"invalid literal/length code\", _.mode = te;\n              break;\n            }\n            _.extra = ke & 15, _.mode = ge;\n          /* falls through */\n          case ge:\n            if (_.extra) {\n              for (Ye = _.extra; B < Ye; ) {\n                if (Z === 0)\n                  break e;\n                Z--, y += $[o++] << B, B += 8;\n              }\n              _.length += y & (1 << _.extra) - 1, y >>>= _.extra, B -= _.extra, _.back += _.extra;\n            }\n            _.was = _.length, _.mode = ue;\n          /* falls through */\n          case ue:\n            for (; we = _.distcode[y & (1 << _.distbits) - 1], le = we >>> 24, ke = we >>> 16 & 255, Te = we & 65535, !(le <= B); ) {\n              if (Z === 0)\n                break e;\n              Z--, y += $[o++] << B, B += 8;\n            }\n            if ((ke & 240) === 0) {\n              for (De = le, on = ke, fn = Te; we = _.distcode[fn + ((y & (1 << De + on) - 1) >> De)], le = we >>> 24, ke = we >>> 16 & 255, Te = we & 65535, !(De + le <= B); ) {\n                if (Z === 0)\n                  break e;\n                Z--, y += $[o++] << B, B += 8;\n              }\n              y >>>= De, B -= De, _.back += De;\n            }\n            if (y >>>= le, B -= le, _.back += le, ke & 64) {\n              A.msg = \"invalid distance code\", _.mode = te;\n              break;\n            }\n            _.offset = Te, _.extra = ke & 15, _.mode = re;\n          /* falls through */\n          case re:\n            if (_.extra) {\n              for (Ye = _.extra; B < Ye; ) {\n                if (Z === 0)\n                  break e;\n                Z--, y += $[o++] << B, B += 8;\n              }\n              _.offset += y & (1 << _.extra) - 1, y >>>= _.extra, B -= _.extra, _.back += _.extra;\n            }\n            if (_.offset > _.dmax) {\n              A.msg = \"invalid distance too far back\", _.mode = te;\n              break;\n            }\n            _.mode = ie;\n          /* falls through */\n          case ie:\n            if (w === 0)\n              break e;\n            if (Q = K - w, _.offset > Q) {\n              if (Q = _.offset - Q, Q > _.whave && _.sane) {\n                A.msg = \"invalid distance too far back\", _.mode = te;\n                break;\n              }\n              Q > _.wnext ? (Q -= _.wnext, fe = _.wsize - Q) : fe = _.wnext - Q, Q > _.length && (Q = _.length), We = _.window;\n            } else\n              We = ee, fe = M - _.offset, Q = _.length;\n            Q > w && (Q = w), w -= Q, _.length -= Q;\n            do\n              ee[M++] = We[fe++];\n            while (--Q);\n            _.length === 0 && (_.mode = he);\n            break;\n          case G:\n            if (w === 0)\n              break e;\n            ee[M++] = _.length, w--, _.mode = he;\n            break;\n          case W:\n            if (_.wrap) {\n              for (; B < 32; ) {\n                if (Z === 0)\n                  break e;\n                Z--, y |= $[o++] << B, B += 8;\n              }\n              if (K -= w, A.total_out += K, _.total += K, K && (A.adler = _.check = /*UPDATE(state.check, put - _out, _out);*/\n              _.flags ? t(_.check, ee, K, M - K) : r(_.check, ee, K, M - K)), K = w, (_.flags ? y : Ze(y)) !== _.check) {\n                A.msg = \"incorrect data check\", _.mode = te;\n                break;\n              }\n              y = 0, B = 0;\n            }\n            _.mode = Ee;\n          /* falls through */\n          case Ee:\n            if (_.wrap && _.flags) {\n              for (; B < 32; ) {\n                if (Z === 0)\n                  break e;\n                Z--, y += $[o++] << B, B += 8;\n              }\n              if (y !== (_.total & 4294967295)) {\n                A.msg = \"incorrect length check\", _.mode = te;\n                break;\n              }\n              y = 0, B = 0;\n            }\n            _.mode = ze;\n          /* falls through */\n          case ze:\n            He = g;\n            break e;\n          case te:\n            He = R;\n            break e;\n          case pe:\n            return S;\n          case Ne:\n          /* falls through */\n          default:\n            return c;\n        }\n    return A.next_out = M, A.avail_out = w, A.next_in = o, A.avail_in = Z, _.hold = y, _.bits = B, (_.wsize || K !== A.avail_out && _.mode < te && (_.mode < W || H !== s)) && Rt(A, A.output, A.next_out, K - A.avail_out), J -= A.avail_in, K -= A.avail_out, A.total_in += J, A.total_out += K, _.total += K, _.wrap && K && (A.adler = _.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/\n    _.flags ? t(_.check, ee, K, A.next_out - K) : r(_.check, ee, K, A.next_out - K)), A.data_type = _.bits + (_.last ? 64 : 0) + (_.mode === U ? 128 : 0) + (_.mode === de || _.mode === q ? 256 : 0), (J === 0 && K === 0 || H === s) && He === d && (He = b), He;\n  }\n  function F(A) {\n    if (!A || !A.state)\n      return c;\n    var H = A.state;\n    return H.window && (H.window = null), A.state = null, d;\n  }\n  function P(A, H) {\n    var _;\n    return !A || !A.state || (_ = A.state, (_.wrap & 2) === 0) ? c : (_.head = H, H.done = !1, d);\n  }\n  function j(A, H) {\n    var _ = H.length, $, ee, o;\n    return !A || !A.state || ($ = A.state, $.wrap !== 0 && $.mode !== N) ? c : $.mode === N && (ee = 1, ee = r(ee, H, _, 0), ee !== $.check) ? R : (o = Rt(A, H, _, _), o ? ($.mode = pe, S) : ($.havedict = 1, d));\n  }\n  return Ue.inflateReset = Oe, Ue.inflateReset2 = At, Ue.inflateResetKeep = rt, Ue.inflateInit = Pe, Ue.inflateInit2 = it, Ue.inflate = p, Ue.inflateEnd = F, Ue.inflateGetHeader = P, Ue.inflateSetDictionary = j, Ue.inflateInfo = \"pako inflate (from Nodeca project)\", Ue;\n}\nvar tr, Ti;\nfunction Ba() {\n  return Ti || (Ti = 1, tr = {\n    /* Allowed flush values; see deflate() and inflate() below for details */\n    Z_NO_FLUSH: 0,\n    Z_PARTIAL_FLUSH: 1,\n    Z_SYNC_FLUSH: 2,\n    Z_FULL_FLUSH: 3,\n    Z_FINISH: 4,\n    Z_BLOCK: 5,\n    Z_TREES: 6,\n    /* Return codes for the compression/decompression functions. Negative values\n    * are errors, positive values are used for special but normal events.\n    */\n    Z_OK: 0,\n    Z_STREAM_END: 1,\n    Z_NEED_DICT: 2,\n    Z_ERRNO: -1,\n    Z_STREAM_ERROR: -2,\n    Z_DATA_ERROR: -3,\n    //Z_MEM_ERROR:     -4,\n    Z_BUF_ERROR: -5,\n    //Z_VERSION_ERROR: -6,\n    /* compression levels */\n    Z_NO_COMPRESSION: 0,\n    Z_BEST_SPEED: 1,\n    Z_BEST_COMPRESSION: 9,\n    Z_DEFAULT_COMPRESSION: -1,\n    Z_FILTERED: 1,\n    Z_HUFFMAN_ONLY: 2,\n    Z_RLE: 3,\n    Z_FIXED: 4,\n    Z_DEFAULT_STRATEGY: 0,\n    /* Possible values of the data_type field (though see inflate()) */\n    Z_BINARY: 0,\n    Z_TEXT: 1,\n    //Z_ASCII:                1, // = Z_TEXT (deprecated)\n    Z_UNKNOWN: 2,\n    /* The deflate compression method */\n    Z_DEFLATED: 8\n    //Z_NULL:                 null // Use -1 or null inline, depending on var type\n  }), tr;\n}\nvar nr, zi;\nfunction Wo() {\n  if (zi) return nr;\n  zi = 1;\n  function e() {\n    this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = \"\", this.comment = \"\", this.hcrc = 0, this.done = !1;\n  }\n  return nr = e, nr;\n}\nvar Ci;\nfunction Go() {\n  if (Ci) return Ct;\n  Ci = 1;\n  var e = Jo(), r = ct(), t = Da(), i = Ba(), f = Dr(), n = La(), a = Wo(), l = Object.prototype.toString;\n  function s(d) {\n    if (!(this instanceof s)) return new s(d);\n    this.options = r.assign({\n      chunkSize: 16384,\n      windowBits: 0,\n      to: \"\"\n    }, d || {});\n    var g = this.options;\n    g.raw && g.windowBits >= 0 && g.windowBits < 16 && (g.windowBits = -g.windowBits, g.windowBits === 0 && (g.windowBits = -15)), g.windowBits >= 0 && g.windowBits < 16 && !(d && d.windowBits) && (g.windowBits += 32), g.windowBits > 15 && g.windowBits < 48 && (g.windowBits & 15) === 0 && (g.windowBits |= 15), this.err = 0, this.msg = \"\", this.ended = !1, this.chunks = [], this.strm = new n(), this.strm.avail_out = 0;\n    var v = e.inflateInit2(\n      this.strm,\n      g.windowBits\n    );\n    if (v !== i.Z_OK)\n      throw new Error(f[v]);\n    if (this.header = new a(), e.inflateGetHeader(this.strm, this.header), g.dictionary && (typeof g.dictionary == \"string\" ? g.dictionary = t.string2buf(g.dictionary) : l.call(g.dictionary) === \"[object ArrayBuffer]\" && (g.dictionary = new Uint8Array(g.dictionary)), g.raw && (v = e.inflateSetDictionary(this.strm, g.dictionary), v !== i.Z_OK)))\n      throw new Error(f[v]);\n  }\n  s.prototype.push = function(d, g) {\n    var v = this.strm, c = this.options.chunkSize, R = this.options.dictionary, S, b, x, m, k, L = !1;\n    if (this.ended)\n      return !1;\n    b = g === ~~g ? g : g === !0 ? i.Z_FINISH : i.Z_NO_FLUSH, typeof d == \"string\" ? v.input = t.binstring2buf(d) : l.call(d) === \"[object ArrayBuffer]\" ? v.input = new Uint8Array(d) : v.input = d, v.next_in = 0, v.avail_in = v.input.length;\n    do {\n      if (v.avail_out === 0 && (v.output = new r.Buf8(c), v.next_out = 0, v.avail_out = c), S = e.inflate(v, i.Z_NO_FLUSH), S === i.Z_NEED_DICT && R && (S = e.inflateSetDictionary(this.strm, R)), S === i.Z_BUF_ERROR && L === !0 && (S = i.Z_OK, L = !1), S !== i.Z_STREAM_END && S !== i.Z_OK)\n        return this.onEnd(S), this.ended = !0, !1;\n      v.next_out && (v.avail_out === 0 || S === i.Z_STREAM_END || v.avail_in === 0 && (b === i.Z_FINISH || b === i.Z_SYNC_FLUSH)) && (this.options.to === \"string\" ? (x = t.utf8border(v.output, v.next_out), m = v.next_out - x, k = t.buf2string(v.output, x), v.next_out = m, v.avail_out = c - m, m && r.arraySet(v.output, v.output, x, m, 0), this.onData(k)) : this.onData(r.shrinkBuf(v.output, v.next_out))), v.avail_in === 0 && v.avail_out === 0 && (L = !0);\n    } while ((v.avail_in > 0 || v.avail_out === 0) && S !== i.Z_STREAM_END);\n    return S === i.Z_STREAM_END && (b = i.Z_FINISH), b === i.Z_FINISH ? (S = e.inflateEnd(this.strm), this.onEnd(S), this.ended = !0, S === i.Z_OK) : (b === i.Z_SYNC_FLUSH && (this.onEnd(i.Z_OK), v.avail_out = 0), !0);\n  }, s.prototype.onData = function(d) {\n    this.chunks.push(d);\n  }, s.prototype.onEnd = function(d) {\n    d === i.Z_OK && (this.options.to === \"string\" ? this.result = this.chunks.join(\"\") : this.result = r.flattenChunks(this.chunks)), this.chunks = [], this.err = d, this.msg = this.strm.msg;\n  };\n  function h(d, g) {\n    var v = new s(g);\n    if (v.push(d, !0), v.err)\n      throw v.msg || f[v.err];\n    return v.result;\n  }\n  function u(d, g) {\n    return g = g || {}, g.raw = !0, h(d, g);\n  }\n  return Ct.Inflate = s, Ct.inflate = h, Ct.inflateRaw = u, Ct.ungzip = h, Ct;\n}\nvar rr, Ii;\nfunction ef() {\n  if (Ii) return rr;\n  Ii = 1;\n  var e = ct().assign, r = Vo(), t = Go(), i = Ba(), f = {};\n  return e(f, r, t, i), rr = f, rr;\n}\nvar Di;\nfunction tf() {\n  return Di || (Di = 1, function(e) {\n    (function() {\n      var r = {}, t;\n      e.exports = r, typeof Ko == \"function\" ? t = ef() : t = window.pako, function(i, f) {\n        i.toRGBA8 = function(n) {\n          var a = n.width, l = n.height;\n          if (n.tabs.acTL == null) return [i.toRGBA8.decodeImage(n.data, a, l, n).buffer];\n          var s = [];\n          n.frames[0].data == null && (n.frames[0].data = n.data);\n          for (var h, u = new Uint8Array(a * l * 4), d = 0; d < n.frames.length; d++) {\n            var g = n.frames[d], v = g.rect.x, c = g.rect.y, R = g.rect.width, S = g.rect.height, b = i.toRGBA8.decodeImage(g.data, R, S, n);\n            if (d == 0 ? h = b : g.blend == 0 ? i._copyTile(b, R, S, h, a, l, v, c, 0) : g.blend == 1 && i._copyTile(b, R, S, h, a, l, v, c, 1), s.push(h.buffer), h = h.slice(0), g.dispose != 0) {\n              if (g.dispose == 1) i._copyTile(u, R, S, h, a, l, v, c, 0);\n              else if (g.dispose == 2) {\n                for (var x = d - 1; n.frames[x].dispose == 2; ) x--;\n                h = new Uint8Array(s[x]).slice(0);\n              }\n            }\n          }\n          return s;\n        }, i.toRGBA8.decodeImage = function(n, a, l, s) {\n          var h = a * l, u = i.decode._getBPP(s), d = Math.ceil(a * u / 8), g = new Uint8Array(h * 4), v = new Uint32Array(g.buffer), c = s.ctype, R = s.depth, S = i._bin.readUshort;\n          if (c == 6) {\n            var b = h << 2;\n            if (R == 8) for (var x = 0; x < b; x++)\n              g[x] = n[x];\n            if (R == 16) for (var x = 0; x < b; x++)\n              g[x] = n[x << 1];\n          } else if (c == 2) {\n            var m = s.tabs.tRNS, k = -1, L = -1, z = -1;\n            if (m && (k = m[0], L = m[1], z = m[2]), R == 8) for (var x = 0; x < h; x++) {\n              var E = x << 2, T = x * 3;\n              g[E] = n[T], g[E + 1] = n[T + 1], g[E + 2] = n[T + 2], g[E + 3] = 255, k != -1 && n[T] == k && n[T + 1] == L && n[T + 2] == z && (g[E + 3] = 0);\n            }\n            if (R == 16) for (var x = 0; x < h; x++) {\n              var E = x << 2, T = x * 6;\n              g[E] = n[T], g[E + 1] = n[T + 2], g[E + 2] = n[T + 4], g[E + 3] = 255, k != -1 && S(n, T) == k && S(n, T + 2) == L && S(n, T + 4) == z && (g[E + 3] = 0);\n            }\n          } else if (c == 3) {\n            var I = s.tabs.PLTE, D = s.tabs.tRNS, C = D ? D.length : 0;\n            if (R == 1) for (var O = 0; O < l; O++)\n              for (var N = O * d, U = O * a, x = 0; x < a; x++) {\n                var E = U + x << 2, X = n[N + (x >> 3)] >> 7 - ((x & 7) << 0) & 1, Y = 3 * X;\n                g[E] = I[Y], g[E + 1] = I[Y + 1], g[E + 2] = I[Y + 2], g[E + 3] = X < C ? D[X] : 255;\n              }\n            if (R == 2) for (var O = 0; O < l; O++)\n              for (var N = O * d, U = O * a, x = 0; x < a; x++) {\n                var E = U + x << 2, X = n[N + (x >> 2)] >> 6 - ((x & 3) << 1) & 3, Y = 3 * X;\n                g[E] = I[Y], g[E + 1] = I[Y + 1], g[E + 2] = I[Y + 2], g[E + 3] = X < C ? D[X] : 255;\n              }\n            if (R == 4) for (var O = 0; O < l; O++)\n              for (var N = O * d, U = O * a, x = 0; x < a; x++) {\n                var E = U + x << 2, X = n[N + (x >> 1)] >> 4 - ((x & 1) << 2) & 15, Y = 3 * X;\n                g[E] = I[Y], g[E + 1] = I[Y + 1], g[E + 2] = I[Y + 2], g[E + 3] = X < C ? D[X] : 255;\n              }\n            if (R == 8) for (var x = 0; x < h; x++) {\n              var E = x << 2, X = n[x], Y = 3 * X;\n              g[E] = I[Y], g[E + 1] = I[Y + 1], g[E + 2] = I[Y + 2], g[E + 3] = X < C ? D[X] : 255;\n            }\n          } else if (c == 4) {\n            if (R == 8) for (var x = 0; x < h; x++) {\n              var E = x << 2, q = x << 1, V = n[q];\n              g[E] = V, g[E + 1] = V, g[E + 2] = V, g[E + 3] = n[q + 1];\n            }\n            if (R == 16) for (var x = 0; x < h; x++) {\n              var E = x << 2, q = x << 2, V = n[q];\n              g[E] = V, g[E + 1] = V, g[E + 2] = V, g[E + 3] = n[q + 2];\n            }\n          } else if (c == 0) {\n            var k = s.tabs.tRNS ? s.tabs.tRNS : -1;\n            if (R == 1) for (var x = 0; x < h; x++) {\n              var V = 255 * (n[x >> 3] >> 7 - (x & 7) & 1), ne = V == k * 255 ? 0 : 255;\n              v[x] = ne << 24 | V << 16 | V << 8 | V;\n            }\n            if (R == 2) for (var x = 0; x < h; x++) {\n              var V = 85 * (n[x >> 2] >> 6 - ((x & 3) << 1) & 3), ne = V == k * 85 ? 0 : 255;\n              v[x] = ne << 24 | V << 16 | V << 8 | V;\n            }\n            if (R == 4) for (var x = 0; x < h; x++) {\n              var V = 17 * (n[x >> 1] >> 4 - ((x & 1) << 2) & 15), ne = V == k * 17 ? 0 : 255;\n              v[x] = ne << 24 | V << 16 | V << 8 | V;\n            }\n            if (R == 8) for (var x = 0; x < h; x++) {\n              var V = n[x], ne = V == k ? 0 : 255;\n              v[x] = ne << 24 | V << 16 | V << 8 | V;\n            }\n            if (R == 16) for (var x = 0; x < h; x++) {\n              var V = n[x << 1], ne = S(n, x << 1) == k ? 0 : 255;\n              v[x] = ne << 24 | V << 16 | V << 8 | V;\n            }\n          }\n          return g;\n        }, i.decode = function(n) {\n          for (var a = new Uint8Array(n), l = 8, s = i._bin, h = s.readUshort, u = s.readUint, d = { tabs: {}, frames: [] }, g = new Uint8Array(a.length), v = 0, c, R = 0, S = [137, 80, 78, 71, 13, 10, 26, 10], b = 0; b < 8; b++) if (a[b] != S[b]) throw \"The input is not a PNG file!\";\n          for (; l < a.length; ) {\n            var x = s.readUint(a, l);\n            l += 4;\n            var m = s.readASCII(a, l, 4);\n            if (l += 4, m == \"IHDR\")\n              i.decode._IHDR(a, l, d);\n            else if (m == \"IDAT\") {\n              for (var b = 0; b < x; b++) g[v + b] = a[l + b];\n              v += x;\n            } else if (m == \"acTL\")\n              d.tabs[m] = { num_frames: u(a, l), num_plays: u(a, l + 4) }, c = new Uint8Array(a.length);\n            else if (m == \"fcTL\") {\n              if (R != 0) {\n                var k = d.frames[d.frames.length - 1];\n                k.data = i.decode._decompress(d, c.slice(0, R), k.rect.width, k.rect.height), R = 0;\n              }\n              var L = { x: u(a, l + 12), y: u(a, l + 16), width: u(a, l + 4), height: u(a, l + 8) }, z = h(a, l + 22);\n              z = h(a, l + 20) / (z == 0 ? 100 : z);\n              var E = { rect: L, delay: Math.round(z * 1e3), dispose: a[l + 24], blend: a[l + 25] };\n              d.frames.push(E);\n            } else if (m == \"fdAT\") {\n              for (var b = 0; b < x - 4; b++) c[R + b] = a[l + b + 4];\n              R += x - 4;\n            } else if (m == \"pHYs\")\n              d.tabs[m] = [s.readUint(a, l), s.readUint(a, l + 4), a[l + 8]];\n            else if (m == \"cHRM\") {\n              d.tabs[m] = [];\n              for (var b = 0; b < 8; b++) d.tabs[m].push(s.readUint(a, l + b * 4));\n            } else if (m == \"tEXt\") {\n              d.tabs[m] == null && (d.tabs[m] = {});\n              var T = s.nextZero(a, l), I = s.readASCII(a, l, T - l), D = s.readASCII(a, T + 1, l + x - T - 1);\n              d.tabs[m][I] = D;\n            } else if (m == \"iTXt\") {\n              d.tabs[m] == null && (d.tabs[m] = {});\n              var T = 0, C = l;\n              T = s.nextZero(a, C);\n              var I = s.readASCII(a, C, T - C);\n              C = T + 1, a[C], a[C + 1], C += 2, T = s.nextZero(a, C), s.readASCII(a, C, T - C), C = T + 1, T = s.nextZero(a, C), s.readUTF8(a, C, T - C), C = T + 1;\n              var D = s.readUTF8(a, C, x - (C - l));\n              d.tabs[m][I] = D;\n            } else if (m == \"PLTE\")\n              d.tabs[m] = s.readBytes(a, l, x);\n            else if (m == \"hIST\") {\n              var O = d.tabs.PLTE.length / 3;\n              d.tabs[m] = [];\n              for (var b = 0; b < O; b++) d.tabs[m].push(h(a, l + b * 2));\n            } else if (m == \"tRNS\")\n              d.ctype == 3 ? d.tabs[m] = s.readBytes(a, l, x) : d.ctype == 0 ? d.tabs[m] = h(a, l) : d.ctype == 2 && (d.tabs[m] = [h(a, l), h(a, l + 2), h(a, l + 4)]);\n            else if (m == \"gAMA\") d.tabs[m] = s.readUint(a, l) / 1e5;\n            else if (m == \"sRGB\") d.tabs[m] = a[l];\n            else if (m == \"bKGD\")\n              d.ctype == 0 || d.ctype == 4 ? d.tabs[m] = [h(a, l)] : d.ctype == 2 || d.ctype == 6 ? d.tabs[m] = [h(a, l), h(a, l + 2), h(a, l + 4)] : d.ctype == 3 && (d.tabs[m] = a[l]);\n            else if (m == \"IEND\") {\n              if (R != 0) {\n                var k = d.frames[d.frames.length - 1];\n                k.data = i.decode._decompress(d, c.slice(0, R), k.rect.width, k.rect.height), R = 0;\n              }\n              d.data = i.decode._decompress(d, g, d.width, d.height);\n              break;\n            }\n            l += x, s.readUint(a, l), l += 4;\n          }\n          return delete d.compress, delete d.interlace, delete d.filter, d;\n        }, i.decode._decompress = function(n, a, l, s) {\n          return n.compress == 0 && (a = i.decode._inflate(a)), n.interlace == 0 ? a = i.decode._filterZero(a, n, 0, l, s) : n.interlace == 1 && (a = i.decode._readInterlace(a, n)), a;\n        }, i.decode._inflate = function(n) {\n          return f.inflate(n);\n        }, i.decode._readInterlace = function(n, a) {\n          for (var l = a.width, s = a.height, h = i.decode._getBPP(a), u = h >> 3, d = Math.ceil(l * h / 8), g = new Uint8Array(s * d), v = 0, c = [0, 0, 4, 0, 2, 0, 1], R = [0, 4, 0, 2, 0, 1, 0], S = [8, 8, 8, 4, 4, 2, 2], b = [8, 8, 4, 4, 2, 2, 1], x = 0; x < 7; ) {\n            for (var m = S[x], k = b[x], L = 0, z = 0, E = c[x]; E < s; )\n              E += m, z++;\n            for (var T = R[x]; T < l; )\n              T += k, L++;\n            var I = Math.ceil(L * h / 8);\n            i.decode._filterZero(n, a, v, L, z);\n            for (var D = 0, C = c[x]; C < s; ) {\n              for (var O = R[x], N = v + D * I << 3; O < l; ) {\n                if (h == 1) {\n                  var U = n[N >> 3];\n                  U = U >> 7 - (N & 7) & 1, g[C * d + (O >> 3)] |= U << 7 - ((O & 3) << 0);\n                }\n                if (h == 2) {\n                  var U = n[N >> 3];\n                  U = U >> 6 - (N & 7) & 3, g[C * d + (O >> 2)] |= U << 6 - ((O & 3) << 1);\n                }\n                if (h == 4) {\n                  var U = n[N >> 3];\n                  U = U >> 4 - (N & 7) & 15, g[C * d + (O >> 1)] |= U << 4 - ((O & 1) << 2);\n                }\n                if (h >= 8)\n                  for (var X = C * d + O * u, Y = 0; Y < u; Y++) g[X + Y] = n[(N >> 3) + Y];\n                N += h, O += k;\n              }\n              D++, C += m;\n            }\n            L * z != 0 && (v += z * (1 + I)), x = x + 1;\n          }\n          return g;\n        }, i.decode._getBPP = function(n) {\n          var a = [1, null, 3, 1, 2, null, 4][n.ctype];\n          return a * n.depth;\n        }, i.decode._filterZero = function(n, a, l, s, h) {\n          var u = i.decode._getBPP(a), d = Math.ceil(s * u / 8), g = i.decode._paeth;\n          u = Math.ceil(u / 8);\n          for (var v = 0; v < h; v++) {\n            var c = l + v * d, R = c + v + 1, S = n[R - 1];\n            if (S == 0) for (var b = 0; b < d; b++) n[c + b] = n[R + b];\n            else if (S == 1) {\n              for (var b = 0; b < u; b++) n[c + b] = n[R + b];\n              for (var b = u; b < d; b++) n[c + b] = n[R + b] + n[c + b - u] & 255;\n            } else if (v == 0) {\n              for (var b = 0; b < u; b++) n[c + b] = n[R + b];\n              if (S == 2) for (var b = u; b < d; b++) n[c + b] = n[R + b] & 255;\n              if (S == 3) for (var b = u; b < d; b++) n[c + b] = n[R + b] + (n[c + b - u] >> 1) & 255;\n              if (S == 4) for (var b = u; b < d; b++) n[c + b] = n[R + b] + g(n[c + b - u], 0, 0) & 255;\n            } else {\n              if (S == 2)\n                for (var b = 0; b < d; b++) n[c + b] = n[R + b] + n[c + b - d] & 255;\n              if (S == 3) {\n                for (var b = 0; b < u; b++) n[c + b] = n[R + b] + (n[c + b - d] >> 1) & 255;\n                for (var b = u; b < d; b++) n[c + b] = n[R + b] + (n[c + b - d] + n[c + b - u] >> 1) & 255;\n              }\n              if (S == 4) {\n                for (var b = 0; b < u; b++) n[c + b] = n[R + b] + g(0, n[c + b - d], 0) & 255;\n                for (var b = u; b < d; b++) n[c + b] = n[R + b] + g(n[c + b - u], n[c + b - d], n[c + b - u - d]) & 255;\n              }\n            }\n          }\n          return n;\n        }, i.decode._paeth = function(n, a, l) {\n          var s = n + a - l, h = Math.abs(s - n), u = Math.abs(s - a), d = Math.abs(s - l);\n          return h <= u && h <= d ? n : u <= d ? a : l;\n        }, i.decode._IHDR = function(n, a, l) {\n          var s = i._bin;\n          l.width = s.readUint(n, a), a += 4, l.height = s.readUint(n, a), a += 4, l.depth = n[a], a++, l.ctype = n[a], a++, l.compress = n[a], a++, l.filter = n[a], a++, l.interlace = n[a], a++;\n        }, i._bin = {\n          nextZero: function(n, a) {\n            for (; n[a] != 0; ) a++;\n            return a;\n          },\n          readUshort: function(n, a) {\n            return n[a] << 8 | n[a + 1];\n          },\n          writeUshort: function(n, a, l) {\n            n[a] = l >> 8 & 255, n[a + 1] = l & 255;\n          },\n          readUint: function(n, a) {\n            return n[a] * (256 * 256 * 256) + (n[a + 1] << 16 | n[a + 2] << 8 | n[a + 3]);\n          },\n          writeUint: function(n, a, l) {\n            n[a] = l >> 24 & 255, n[a + 1] = l >> 16 & 255, n[a + 2] = l >> 8 & 255, n[a + 3] = l & 255;\n          },\n          readASCII: function(n, a, l) {\n            for (var s = \"\", h = 0; h < l; h++) s += String.fromCharCode(n[a + h]);\n            return s;\n          },\n          writeASCII: function(n, a, l) {\n            for (var s = 0; s < l.length; s++) n[a + s] = l.charCodeAt(s);\n          },\n          readBytes: function(n, a, l) {\n            for (var s = [], h = 0; h < l; h++) s.push(n[a + h]);\n            return s;\n          },\n          pad: function(n) {\n            return n.length < 2 ? \"0\" + n : n;\n          },\n          readUTF8: function(n, a, l) {\n            for (var s = \"\", h, u = 0; u < l; u++) s += \"%\" + i._bin.pad(n[a + u].toString(16));\n            try {\n              h = decodeURIComponent(s);\n            } catch {\n              return i._bin.readASCII(n, a, l);\n            }\n            return h;\n          }\n        }, i._copyTile = function(n, a, l, s, h, u, d, g, v) {\n          for (var c = Math.min(a, h), R = Math.min(l, u), S = 0, b = 0, x = 0; x < R; x++)\n            for (var m = 0; m < c; m++)\n              if (d >= 0 && g >= 0 ? (S = x * a + m << 2, b = (g + x) * h + d + m << 2) : (S = (-g + x) * a - d + m << 2, b = x * h + m << 2), v == 0)\n                s[b] = n[S], s[b + 1] = n[S + 1], s[b + 2] = n[S + 2], s[b + 3] = n[S + 3];\n              else if (v == 1) {\n                var k = n[S + 3] * 0.00392156862745098, L = n[S] * k, z = n[S + 1] * k, E = n[S + 2] * k, T = s[b + 3] * (1 / 255), I = s[b] * T, D = s[b + 1] * T, C = s[b + 2] * T, O = 1 - k, N = k + T * O, U = N == 0 ? 0 : 1 / N;\n                s[b + 3] = 255 * N, s[b + 0] = (L + I * O) * U, s[b + 1] = (z + D * O) * U, s[b + 2] = (E + C * O) * U;\n              } else if (v == 2) {\n                var k = n[S + 3], L = n[S], z = n[S + 1], E = n[S + 2], T = s[b + 3], I = s[b], D = s[b + 1], C = s[b + 2];\n                k == T && L == I && z == D && E == C ? (s[b] = 0, s[b + 1] = 0, s[b + 2] = 0, s[b + 3] = 0) : (s[b] = L, s[b + 1] = z, s[b + 2] = E, s[b + 3] = k);\n              } else if (v == 3) {\n                var k = n[S + 3], L = n[S], z = n[S + 1], E = n[S + 2], T = s[b + 3], I = s[b], D = s[b + 1], C = s[b + 2];\n                if (k == T && L == I && z == D && E == C) continue;\n                if (k < 220 && T > 20) return !1;\n              }\n          return !0;\n        }, i.encode = function(n, a, l, s, h, u) {\n          s == null && (s = 0), u == null && (u = !1);\n          for (var d = new Uint8Array(n[0].byteLength * n.length + 100), g = [137, 80, 78, 71, 13, 10, 26, 10], v = 0; v < 8; v++) d[v] = g[v];\n          var c = 8, R = i._bin, S = i.crc.crc, b = R.writeUint, x = R.writeUshort, m = R.writeASCII, k = i.encode.compressPNG(n, a, l, s, u);\n          b(d, c, 13), c += 4, m(d, c, \"IHDR\"), c += 4, b(d, c, a), c += 4, b(d, c, l), c += 4, d[c] = k.depth, c++, d[c] = k.ctype, c++, d[c] = 0, c++, d[c] = 0, c++, d[c] = 0, c++, b(d, c, S(d, c - 17, 17)), c += 4, b(d, c, 1), c += 4, m(d, c, \"sRGB\"), c += 4, d[c] = 1, c++, b(d, c, S(d, c - 5, 5)), c += 4;\n          var L = n.length > 1;\n          if (L && (b(d, c, 8), c += 4, m(d, c, \"acTL\"), c += 4, b(d, c, n.length), c += 4, b(d, c, 0), c += 4, b(d, c, S(d, c - 12, 12)), c += 4), k.ctype == 3) {\n            var z = k.plte.length;\n            b(d, c, z * 3), c += 4, m(d, c, \"PLTE\"), c += 4;\n            for (var v = 0; v < z; v++) {\n              var E = v * 3, T = k.plte[v], I = T & 255, D = T >> 8 & 255, C = T >> 16 & 255;\n              d[c + E + 0] = I, d[c + E + 1] = D, d[c + E + 2] = C;\n            }\n            if (c += z * 3, b(d, c, S(d, c - z * 3 - 4, z * 3 + 4)), c += 4, k.gotAlpha) {\n              b(d, c, z), c += 4, m(d, c, \"tRNS\"), c += 4;\n              for (var v = 0; v < z; v++) d[c + v] = k.plte[v] >> 24 & 255;\n              c += z, b(d, c, S(d, c - z - 4, z + 4)), c += 4;\n            }\n          }\n          for (var O = 0, N = 0; N < k.frames.length; N++) {\n            var U = k.frames[N];\n            L && (b(d, c, 26), c += 4, m(d, c, \"fcTL\"), c += 4, b(d, c, O++), c += 4, b(d, c, U.rect.width), c += 4, b(d, c, U.rect.height), c += 4, b(d, c, U.rect.x), c += 4, b(d, c, U.rect.y), c += 4, x(d, c, h[N]), c += 2, x(d, c, 1e3), c += 2, d[c] = U.dispose, c++, d[c] = U.blend, c++, b(d, c, S(d, c - 30, 30)), c += 4);\n            var X = U.cimg, z = X.length;\n            b(d, c, z + (N == 0 ? 0 : 4)), c += 4;\n            var Y = c;\n            m(d, c, N == 0 ? \"IDAT\" : \"fdAT\"), c += 4, N != 0 && (b(d, c, O++), c += 4);\n            for (var v = 0; v < z; v++) d[c + v] = X[v];\n            c += z, b(d, c, S(d, Y, c - Y)), c += 4;\n          }\n          return b(d, c, 0), c += 4, m(d, c, \"IEND\"), c += 4, b(d, c, S(d, c - 4, 4)), c += 4, d.buffer.slice(0, c);\n        }, i.encode.compressPNG = function(n, a, l, s, h) {\n          for (var u = i.encode.compress(n, a, l, s, !1, h), d = 0; d < n.length; d++) {\n            var g = u.frames[d];\n            g.rect.width;\n            var v = g.rect.height, c = g.bpl, R = g.bpp, S = new Uint8Array(v * c + v);\n            g.cimg = i.encode._filterZero(g.img, v, R, c, S);\n          }\n          return u;\n        }, i.encode.compress = function(n, a, l, s, h, u) {\n          u == null && (u = !1);\n          for (var d = 6, g = 8, v = 4, c = 255, R = 0; R < n.length; R++)\n            for (var S = new Uint8Array(n[R]), b = S.length, x = 0; x < b; x += 4) c &= S[x + 3];\n          var m = c != 255, k = {}, L = [];\n          if (n.length != 0 && (k[0] = 0, L.push(0), s != 0 && s--), s != 0) {\n            var z = i.quantize(n, s, h);\n            n = z.bufs;\n            for (var x = 0; x < z.plte.length; x++) {\n              var E = z.plte[x].est.rgba;\n              k[E] == null && (k[E] = L.length, L.push(E));\n            }\n          } else\n            for (var R = 0; R < n.length; R++)\n              for (var T = new Uint32Array(n[R]), b = T.length, x = 0; x < b; x++) {\n                var E = T[x];\n                if ((x < a || E != T[x - 1] && E != T[x - a]) && k[E] == null && (k[E] = L.length, L.push(E), L.length >= 300))\n                  break;\n              }\n          var I = m ? h : !1, D = L.length;\n          D <= 256 && u == !1 && (D <= 2 ? g = 1 : D <= 4 ? g = 2 : D <= 16 ? g = 4 : g = 8, h && (g = 8), m = !0);\n          for (var C = [], R = 0; R < n.length; R++) {\n            var O = new Uint8Array(n[R]), N = new Uint32Array(O.buffer), U = 0, X = 0, Y = a, q = l, V = 0;\n            if (R != 0 && !I) {\n              for (var ne = h || R == 1 || C[C.length - 2].dispose == 2 ? 1 : 2, ve = 0, be = 1e9, de = 0; de < ne; de++) {\n                for (var ze = new Uint8Array(n[R - 1 - de]), he = new Uint32Array(n[R - 1 - de]), ge = a, ue = l, re = -1, ie = -1, G = 0; G < l; G++) for (var W = 0; W < a; W++) {\n                  var x = G * a + W;\n                  N[x] != he[x] && (W < ge && (ge = W), W > re && (re = W), G < ue && (ue = G), G > ie && (ie = G));\n                }\n                var Ee = re == -1 ? 1 : (re - ge + 1) * (ie - ue + 1);\n                Ee < be && (be = Ee, ve = de, re == -1 ? (U = X = 0, Y = q = 1) : (U = ge, X = ue, Y = re - ge + 1, q = ie - ue + 1));\n              }\n              var ze = new Uint8Array(n[R - 1 - ve]);\n              ve == 1 && (C[C.length - 1].dispose = 2);\n              var te = new Uint8Array(Y * q * 4);\n              new Uint32Array(te.buffer), i._copyTile(ze, a, l, te, Y, q, -U, -X, 0), i._copyTile(O, a, l, te, Y, q, -U, -X, 3) ? (i._copyTile(O, a, l, te, Y, q, -U, -X, 2), V = 1) : (i._copyTile(O, a, l, te, Y, q, -U, -X, 0), V = 0), O = te, N = new Uint32Array(O.buffer);\n            }\n            var pe = 4 * Y;\n            if (D <= 256 && u == !1) {\n              pe = Math.ceil(g * Y / 8);\n              for (var te = new Uint8Array(pe * q), G = 0; G < q; G++) {\n                var x = G * pe, Ne = G * Y;\n                if (g == 8) for (var W = 0; W < Y; W++) te[x + W] = k[N[Ne + W]];\n                else if (g == 4) for (var W = 0; W < Y; W++) te[x + (W >> 1)] |= k[N[Ne + W]] << 4 - (W & 1) * 4;\n                else if (g == 2) for (var W = 0; W < Y; W++) te[x + (W >> 2)] |= k[N[Ne + W]] << 6 - (W & 3) * 2;\n                else if (g == 1) for (var W = 0; W < Y; W++) te[x + (W >> 3)] |= k[N[Ne + W]] << 7 - (W & 7) * 1;\n              }\n              O = te, d = 3, v = 1;\n            } else if (m == !1 && n.length == 1) {\n              for (var te = new Uint8Array(Y * q * 3), Ie = Y * q, x = 0; x < Ie; x++) {\n                var ye = x * 3, ce = x * 4;\n                te[ye] = O[ce], te[ye + 1] = O[ce + 1], te[ye + 2] = O[ce + 2];\n              }\n              O = te, d = 2, v = 3, pe = 3 * Y;\n            }\n            C.push({ rect: { x: U, y: X, width: Y, height: q }, img: O, bpl: pe, bpp: v, blend: V, dispose: I ? 1 : 0 });\n          }\n          return { ctype: d, depth: g, plte: L, gotAlpha: m, frames: C };\n        }, i.encode._filterZero = function(n, a, l, s, h) {\n          for (var u = [], d = 0; d < 5; d++)\n            if (!(a * s > 5e5 && (d == 2 || d == 3 || d == 4))) {\n              for (var g = 0; g < a; g++) i.encode._filterLine(h, n, g, s, l, d);\n              if (u.push(f.deflate(h)), l == 1) break;\n            }\n          for (var v, c = 1e9, R = 0; R < u.length; R++) u[R].length < c && (v = R, c = u[R].length);\n          return u[v];\n        }, i.encode._filterLine = function(n, a, l, s, h, u) {\n          var d = l * s, g = d + l, v = i.decode._paeth;\n          if (n[g] = u, g++, u == 0) for (var c = 0; c < s; c++) n[g + c] = a[d + c];\n          else if (u == 1) {\n            for (var c = 0; c < h; c++) n[g + c] = a[d + c];\n            for (var c = h; c < s; c++) n[g + c] = a[d + c] - a[d + c - h] + 256 & 255;\n          } else if (l == 0) {\n            for (var c = 0; c < h; c++) n[g + c] = a[d + c];\n            if (u == 2) for (var c = h; c < s; c++) n[g + c] = a[d + c];\n            if (u == 3) for (var c = h; c < s; c++) n[g + c] = a[d + c] - (a[d + c - h] >> 1) + 256 & 255;\n            if (u == 4) for (var c = h; c < s; c++) n[g + c] = a[d + c] - v(a[d + c - h], 0, 0) + 256 & 255;\n          } else {\n            if (u == 2)\n              for (var c = 0; c < s; c++) n[g + c] = a[d + c] + 256 - a[d + c - s] & 255;\n            if (u == 3) {\n              for (var c = 0; c < h; c++) n[g + c] = a[d + c] + 256 - (a[d + c - s] >> 1) & 255;\n              for (var c = h; c < s; c++) n[g + c] = a[d + c] + 256 - (a[d + c - s] + a[d + c - h] >> 1) & 255;\n            }\n            if (u == 4) {\n              for (var c = 0; c < h; c++) n[g + c] = a[d + c] + 256 - v(0, a[d + c - s], 0) & 255;\n              for (var c = h; c < s; c++) n[g + c] = a[d + c] + 256 - v(a[d + c - h], a[d + c - s], a[d + c - h - s]) & 255;\n            }\n          }\n        }, i.crc = {\n          table: function() {\n            for (var n = new Uint32Array(256), a = 0; a < 256; a++) {\n              for (var l = a, s = 0; s < 8; s++)\n                l & 1 ? l = 3988292384 ^ l >>> 1 : l = l >>> 1;\n              n[a] = l;\n            }\n            return n;\n          }(),\n          update: function(n, a, l, s) {\n            for (var h = 0; h < s; h++) n = i.crc.table[(n ^ a[l + h]) & 255] ^ n >>> 8;\n            return n;\n          },\n          crc: function(n, a, l) {\n            return i.crc.update(4294967295, n, a, l) ^ 4294967295;\n          }\n        }, i.quantize = function(n, a, l) {\n          for (var s = [], h = 0, u = 0; u < n.length; u++)\n            s.push(i.encode.alphaMul(new Uint8Array(n[u]), l)), h += n[u].byteLength;\n          for (var d = new Uint8Array(h), g = new Uint32Array(d.buffer), v = 0, u = 0; u < s.length; u++) {\n            for (var c = s[u], R = c.length, S = 0; S < R; S++) d[v + S] = c[S];\n            v += R;\n          }\n          var b = { i0: 0, i1: d.length, bst: null, est: null, tdst: 0, left: null, right: null };\n          b.bst = i.quantize.stats(d, b.i0, b.i1), b.est = i.quantize.estats(b.bst);\n          for (var x = [b]; x.length < a; ) {\n            for (var m = 0, k = 0, u = 0; u < x.length; u++) x[u].est.L > m && (m = x[u].est.L, k = u);\n            if (m < 1e-3) break;\n            var L = x[k], z = i.quantize.splitPixels(d, g, L.i0, L.i1, L.est.e, L.est.eMq255), E = { i0: L.i0, i1: z, bst: null, est: null, tdst: 0, left: null, right: null };\n            E.bst = i.quantize.stats(d, E.i0, E.i1), E.est = i.quantize.estats(E.bst);\n            var T = { i0: z, i1: L.i1, bst: null, est: null, tdst: 0, left: null, right: null };\n            T.bst = { R: [], m: [], N: L.bst.N - E.bst.N };\n            for (var u = 0; u < 16; u++) T.bst.R[u] = L.bst.R[u] - E.bst.R[u];\n            for (var u = 0; u < 4; u++) T.bst.m[u] = L.bst.m[u] - E.bst.m[u];\n            T.est = i.quantize.estats(T.bst), L.left = E, L.right = T, x[k] = E, x.push(T);\n          }\n          x.sort(function(ne, ve) {\n            return ve.bst.N - ne.bst.N;\n          });\n          for (var I = 0; I < s.length; I++) {\n            for (var D = i.quantize.planeDst, C = new Uint8Array(s[I].buffer), O = new Uint32Array(s[I].buffer), N = C.length, u = 0; u < N; u += 4) {\n              for (var U = C[u] * 0.00392156862745098, X = C[u + 1] * (1 / 255), Y = C[u + 2] * (1 / 255), q = C[u + 3] * (1 / 255), V = b; V.left; ) V = D(V.est, U, X, Y, q) <= 0 ? V.left : V.right;\n              O[u >> 2] = V.est.rgba;\n            }\n            s[I] = O.buffer;\n          }\n          return { bufs: s, plte: x };\n        }, i.quantize.getNearest = function(n, a, l, s, h) {\n          if (n.left == null)\n            return n.tdst = i.quantize.dist(n.est.q, a, l, s, h), n;\n          var u = i.quantize.planeDst(n.est, a, l, s, h), d = n.left, g = n.right;\n          u > 0 && (d = n.right, g = n.left);\n          var v = i.quantize.getNearest(d, a, l, s, h);\n          if (v.tdst <= u * u) return v;\n          var c = i.quantize.getNearest(g, a, l, s, h);\n          return c.tdst < v.tdst ? c : v;\n        }, i.quantize.planeDst = function(n, a, l, s, h) {\n          var u = n.e;\n          return u[0] * a + u[1] * l + u[2] * s + u[3] * h - n.eMq;\n        }, i.quantize.dist = function(n, a, l, s, h) {\n          var u = a - n[0], d = l - n[1], g = s - n[2], v = h - n[3];\n          return u * u + d * d + g * g + v * v;\n        }, i.quantize.splitPixels = function(n, a, l, s, h, u) {\n          var d = i.quantize.vecDot;\n          for (s -= 4; l < s; ) {\n            for (; d(n, l, h) <= u; ) l += 4;\n            for (; d(n, s, h) > u; ) s -= 4;\n            if (l >= s) break;\n            var g = a[l >> 2];\n            a[l >> 2] = a[s >> 2], a[s >> 2] = g, l += 4, s -= 4;\n          }\n          for (; d(n, l, h) > u; ) l -= 4;\n          return l + 4;\n        }, i.quantize.vecDot = function(n, a, l) {\n          return n[a] * l[0] + n[a + 1] * l[1] + n[a + 2] * l[2] + n[a + 3] * l[3];\n        }, i.quantize.stats = function(n, a, l) {\n          for (var s = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], h = [0, 0, 0, 0], u = l - a >> 2, d = a; d < l; d += 4) {\n            var g = n[d] * 0.00392156862745098, v = n[d + 1] * (1 / 255), c = n[d + 2] * (1 / 255), R = n[d + 3] * (1 / 255);\n            h[0] += g, h[1] += v, h[2] += c, h[3] += R, s[0] += g * g, s[1] += g * v, s[2] += g * c, s[3] += g * R, s[5] += v * v, s[6] += v * c, s[7] += v * R, s[10] += c * c, s[11] += c * R, s[15] += R * R;\n          }\n          return s[4] = s[1], s[8] = s[2], s[12] = s[3], s[9] = s[6], s[13] = s[7], s[14] = s[11], { R: s, m: h, N: u };\n        }, i.quantize.estats = function(n) {\n          var a = n.R, l = n.m, s = n.N, h = l[0], u = l[1], d = l[2], g = l[3], v = s == 0 ? 0 : 1 / s, c = [\n            a[0] - h * h * v,\n            a[1] - h * u * v,\n            a[2] - h * d * v,\n            a[3] - h * g * v,\n            a[4] - u * h * v,\n            a[5] - u * u * v,\n            a[6] - u * d * v,\n            a[7] - u * g * v,\n            a[8] - d * h * v,\n            a[9] - d * u * v,\n            a[10] - d * d * v,\n            a[11] - d * g * v,\n            a[12] - g * h * v,\n            a[13] - g * u * v,\n            a[14] - g * d * v,\n            a[15] - g * g * v\n          ], R = c, S = i.M4, b = [0.5, 0.5, 0.5, 0.5], x = 0, m = 0;\n          if (s != 0)\n            for (var k = 0; k < 10 && (b = S.multVec(R, b), m = Math.sqrt(S.dot(b, b)), b = S.sml(1 / m, b), !(Math.abs(m - x) < 1e-9)); k++)\n              x = m;\n          var L = [h * v, u * v, d * v, g * v], z = S.dot(S.sml(255, L), b), E = L[3] < 1e-3 ? 0 : 1 / L[3];\n          return {\n            Cov: c,\n            q: L,\n            e: b,\n            L: x,\n            eMq255: z,\n            eMq: S.dot(b, L),\n            rgba: (Math.round(255 * L[3]) << 24 | Math.round(255 * L[2] * E) << 16 | Math.round(255 * L[1] * E) << 8 | Math.round(255 * L[0] * E) << 0) >>> 0\n          };\n        }, i.M4 = {\n          multVec: function(n, a) {\n            return [\n              n[0] * a[0] + n[1] * a[1] + n[2] * a[2] + n[3] * a[3],\n              n[4] * a[0] + n[5] * a[1] + n[6] * a[2] + n[7] * a[3],\n              n[8] * a[0] + n[9] * a[1] + n[10] * a[2] + n[11] * a[3],\n              n[12] * a[0] + n[13] * a[1] + n[14] * a[2] + n[15] * a[3]\n            ];\n          },\n          dot: function(n, a) {\n            return n[0] * a[0] + n[1] * a[1] + n[2] * a[2] + n[3] * a[3];\n          },\n          sml: function(n, a) {\n            return [n * a[0], n * a[1], n * a[2], n * a[3]];\n          }\n        }, i.encode.alphaMul = function(n, a) {\n          for (var l = new Uint8Array(n.length), s = n.length >> 2, h = 0; h < s; h++) {\n            var u = h << 2, d = n[u + 3];\n            a && (d = d < 128 ? 0 : 255);\n            var g = d * (1 / 255);\n            l[u + 0] = n[u + 0] * g, l[u + 1] = n[u + 1] * g, l[u + 2] = n[u + 2] * g, l[u + 3] = d;\n          }\n          return l;\n        };\n      }(r, t);\n    })();\n  }(Qn)), Qn.exports;\n}\nvar nf = tf();\nconst Li = /* @__PURE__ */ Aa(nf), rf = 8, af = {\n  H: \"HEX\",\n  Z: \"Zlib compressed\",\n  2: \"Base32\"\n}, of = new Set(Object.keys(af)), ff = {\n  H: 2,\n  Z: 8,\n  2: 8\n}, Ma = {\n  1: {\n    L: { 0: 152, 1: 41, 2: 25, 4: 17, 8: 10 },\n    M: { 0: 128, 1: 34, 2: 20, 4: 14, 8: 8 },\n    Q: { 0: 104, 1: 27, 2: 16, 4: 11, 8: 7 },\n    H: { 0: 72, 1: 17, 2: 10, 4: 7, 8: 4 }\n  },\n  2: {\n    L: { 0: 272, 1: 77, 2: 47, 4: 32, 8: 20 },\n    M: { 0: 224, 1: 63, 2: 38, 4: 26, 8: 16 },\n    Q: { 0: 176, 1: 48, 2: 29, 4: 20, 8: 12 },\n    H: { 0: 128, 1: 34, 2: 20, 4: 14, 8: 8 }\n  },\n  3: {\n    L: { 0: 440, 1: 127, 2: 77, 4: 53, 8: 32 },\n    M: { 0: 352, 1: 101, 2: 61, 4: 42, 8: 26 },\n    Q: { 0: 272, 1: 77, 2: 47, 4: 32, 8: 20 },\n    H: { 0: 208, 1: 58, 2: 35, 4: 24, 8: 15 }\n  },\n  4: {\n    L: { 0: 640, 1: 187, 2: 114, 4: 78, 8: 48 },\n    M: { 0: 512, 1: 149, 2: 90, 4: 62, 8: 38 },\n    Q: { 0: 384, 1: 111, 2: 67, 4: 46, 8: 28 },\n    H: { 0: 288, 1: 82, 2: 50, 4: 34, 8: 21 }\n  },\n  5: {\n    L: { 0: 864, 1: 255, 2: 154, 4: 106, 8: 65 },\n    M: { 0: 688, 1: 202, 2: 122, 4: 84, 8: 52 },\n    Q: { 0: 496, 1: 144, 2: 87, 4: 60, 8: 37 },\n    H: { 0: 368, 1: 106, 2: 64, 4: 44, 8: 27 }\n  },\n  6: {\n    L: { 0: 1088, 1: 322, 2: 195, 4: 134, 8: 82 },\n    M: { 0: 864, 1: 255, 2: 154, 4: 106, 8: 65 },\n    Q: { 0: 608, 1: 178, 2: 108, 4: 74, 8: 45 },\n    H: { 0: 480, 1: 139, 2: 84, 4: 58, 8: 36 }\n  },\n  7: {\n    L: { 0: 1248, 1: 370, 2: 224, 4: 154, 8: 95 },\n    M: { 0: 992, 1: 293, 2: 178, 4: 122, 8: 75 },\n    Q: { 0: 704, 1: 207, 2: 125, 4: 86, 8: 53 },\n    H: { 0: 528, 1: 154, 2: 93, 4: 64, 8: 39 }\n  },\n  8: {\n    L: { 0: 1552, 1: 461, 2: 279, 4: 192, 8: 118 },\n    M: { 0: 1232, 1: 365, 2: 221, 4: 152, 8: 93 },\n    Q: { 0: 880, 1: 259, 2: 157, 4: 108, 8: 66 },\n    H: { 0: 688, 1: 202, 2: 122, 4: 84, 8: 52 }\n  },\n  9: {\n    L: { 0: 1856, 1: 552, 2: 335, 4: 230, 8: 141 },\n    M: { 0: 1456, 1: 432, 2: 262, 4: 180, 8: 111 },\n    Q: { 0: 1056, 1: 312, 2: 189, 4: 130, 8: 80 },\n    H: { 0: 800, 1: 235, 2: 143, 4: 98, 8: 60 }\n  },\n  10: {\n    L: { 0: 2192, 1: 652, 2: 395, 4: 271, 8: 167 },\n    M: { 0: 1728, 1: 513, 2: 311, 4: 213, 8: 131 },\n    Q: { 0: 1232, 1: 364, 2: 221, 4: 151, 8: 93 },\n    H: { 0: 976, 1: 288, 2: 174, 4: 119, 8: 74 }\n  },\n  11: {\n    L: { 0: 2592, 1: 772, 2: 468, 4: 321, 8: 198 },\n    M: { 0: 2032, 1: 604, 2: 366, 4: 251, 8: 155 },\n    Q: { 0: 1440, 1: 427, 2: 259, 4: 177, 8: 109 },\n    H: { 0: 1120, 1: 331, 2: 200, 4: 137, 8: 85 }\n  },\n  12: {\n    L: { 0: 2960, 1: 883, 2: 535, 4: 367, 8: 226 },\n    M: { 0: 2320, 1: 691, 2: 419, 4: 287, 8: 177 },\n    Q: { 0: 1648, 1: 489, 2: 296, 4: 203, 8: 125 },\n    H: { 0: 1264, 1: 374, 2: 227, 4: 155, 8: 96 }\n  },\n  13: {\n    L: { 0: 3424, 1: 1022, 2: 619, 4: 425, 8: 262 },\n    M: { 0: 2672, 1: 796, 2: 483, 4: 331, 8: 204 },\n    Q: { 0: 1952, 1: 580, 2: 352, 4: 241, 8: 149 },\n    H: { 0: 1440, 1: 427, 2: 259, 4: 177, 8: 109 }\n  },\n  14: {\n    L: { 0: 3688, 1: 1101, 2: 667, 4: 458, 8: 282 },\n    M: { 0: 2920, 1: 871, 2: 528, 4: 362, 8: 223 },\n    Q: { 0: 2088, 1: 621, 2: 376, 4: 258, 8: 159 },\n    H: { 0: 1576, 1: 468, 2: 283, 4: 194, 8: 120 }\n  },\n  15: {\n    L: { 0: 4184, 1: 1250, 2: 758, 4: 520, 8: 320 },\n    M: { 0: 3320, 1: 991, 2: 600, 4: 412, 8: 254 },\n    Q: { 0: 2360, 1: 703, 2: 426, 4: 292, 8: 180 },\n    H: { 0: 1784, 1: 530, 2: 321, 4: 220, 8: 136 }\n  },\n  16: {\n    L: { 0: 4712, 1: 1408, 2: 854, 4: 586, 8: 361 },\n    M: { 0: 3624, 1: 1082, 2: 656, 4: 450, 8: 277 },\n    Q: { 0: 2600, 1: 775, 2: 470, 4: 322, 8: 198 },\n    H: { 0: 2024, 1: 602, 2: 365, 4: 250, 8: 154 }\n  },\n  17: {\n    L: { 0: 5176, 1: 1548, 2: 938, 4: 644, 8: 397 },\n    M: { 0: 4056, 1: 1212, 2: 734, 4: 504, 8: 310 },\n    Q: { 0: 2936, 1: 876, 2: 531, 4: 364, 8: 224 },\n    H: { 0: 2264, 1: 674, 2: 408, 4: 280, 8: 173 }\n  },\n  18: {\n    L: { 0: 5768, 1: 1725, 2: 1046, 4: 718, 8: 442 },\n    M: { 0: 4504, 1: 1346, 2: 816, 4: 560, 8: 345 },\n    Q: { 0: 3176, 1: 948, 2: 574, 4: 394, 8: 243 },\n    H: { 0: 2504, 1: 746, 2: 452, 4: 310, 8: 191 }\n  },\n  19: {\n    L: { 0: 6360, 1: 1903, 2: 1153, 4: 792, 8: 488 },\n    M: { 0: 5016, 1: 1500, 2: 909, 4: 624, 8: 384 },\n    Q: { 0: 3560, 1: 1063, 2: 644, 4: 442, 8: 272 },\n    H: { 0: 2728, 1: 813, 2: 493, 4: 338, 8: 208 }\n  },\n  20: {\n    L: { 0: 6888, 1: 2061, 2: 1249, 4: 858, 8: 528 },\n    M: { 0: 5352, 1: 1600, 2: 970, 4: 666, 8: 410 },\n    Q: { 0: 3880, 1: 1159, 2: 702, 4: 482, 8: 297 },\n    H: { 0: 3080, 1: 919, 2: 557, 4: 382, 8: 235 }\n  },\n  21: {\n    L: { 0: 7456, 1: 2232, 2: 1352, 4: 929, 8: 572 },\n    M: { 0: 5712, 1: 1708, 2: 1035, 4: 711, 8: 438 },\n    Q: { 0: 4096, 1: 1224, 2: 742, 4: 509, 8: 314 },\n    H: { 0: 3248, 1: 969, 2: 587, 4: 403, 8: 248 }\n  },\n  22: {\n    L: { 0: 8048, 1: 2409, 2: 1460, 4: 1003, 8: 618 },\n    M: { 0: 6256, 1: 1872, 2: 1134, 4: 779, 8: 480 },\n    Q: { 0: 4544, 1: 1358, 2: 823, 4: 565, 8: 348 },\n    H: { 0: 3536, 1: 1056, 2: 640, 4: 439, 8: 270 }\n  },\n  23: {\n    L: { 0: 8752, 1: 2620, 2: 1588, 4: 1091, 8: 672 },\n    M: { 0: 6880, 1: 2059, 2: 1248, 4: 857, 8: 528 },\n    Q: { 0: 4912, 1: 1468, 2: 890, 4: 611, 8: 376 },\n    H: { 0: 3712, 1: 1108, 2: 672, 4: 461, 8: 284 }\n  },\n  24: {\n    L: { 0: 9392, 1: 2812, 2: 1704, 4: 1171, 8: 721 },\n    M: { 0: 7312, 1: 2188, 2: 1326, 4: 911, 8: 561 },\n    Q: { 0: 5312, 1: 1588, 2: 963, 4: 661, 8: 407 },\n    H: { 0: 4112, 1: 1228, 2: 744, 4: 511, 8: 315 }\n  },\n  25: {\n    L: { 0: 10208, 1: 3057, 2: 1853, 4: 1273, 8: 784 },\n    M: { 0: 8e3, 1: 2395, 2: 1451, 4: 997, 8: 614 },\n    Q: { 0: 5744, 1: 1718, 2: 1041, 4: 715, 8: 440 },\n    H: { 0: 4304, 1: 1286, 2: 779, 4: 535, 8: 330 }\n  },\n  26: {\n    L: { 0: 10960, 1: 3283, 2: 1990, 4: 1367, 8: 842 },\n    M: { 0: 8496, 1: 2544, 2: 1542, 4: 1059, 8: 652 },\n    Q: { 0: 6032, 1: 1804, 2: 1094, 4: 751, 8: 462 },\n    H: { 0: 4768, 1: 1425, 2: 864, 4: 593, 8: 365 }\n  },\n  27: {\n    L: { 0: 11744, 1: 3514, 2: 2132, 4: 1465, 8: 902 },\n    M: { 0: 9024, 1: 2701, 2: 1637, 4: 1125, 8: 692 },\n    Q: { 0: 6464, 1: 1933, 2: 1172, 4: 805, 8: 496 },\n    H: { 0: 5024, 1: 1501, 2: 910, 4: 625, 8: 385 }\n  },\n  28: {\n    L: { 0: 12248, 1: 3669, 2: 2223, 4: 1528, 8: 940 },\n    M: { 0: 9544, 1: 2857, 2: 1732, 4: 1190, 8: 732 },\n    Q: { 0: 6968, 1: 2085, 2: 1263, 4: 868, 8: 534 },\n    H: { 0: 5288, 1: 1581, 2: 958, 4: 658, 8: 405 }\n  },\n  29: {\n    L: { 0: 13048, 1: 3909, 2: 2369, 4: 1628, 8: 1002 },\n    M: { 0: 10136, 1: 3035, 2: 1839, 4: 1264, 8: 778 },\n    Q: { 0: 7288, 1: 2181, 2: 1322, 4: 908, 8: 559 },\n    H: { 0: 5608, 1: 1677, 2: 1016, 4: 698, 8: 430 }\n  },\n  30: {\n    L: { 0: 13880, 1: 4158, 2: 2520, 4: 1732, 8: 1066 },\n    M: { 0: 10984, 1: 3289, 2: 1994, 4: 1370, 8: 843 },\n    Q: { 0: 7880, 1: 2358, 2: 1429, 4: 982, 8: 604 },\n    H: { 0: 5960, 1: 1782, 2: 1080, 4: 742, 8: 457 }\n  },\n  31: {\n    L: { 0: 14744, 1: 4417, 2: 2677, 4: 1840, 8: 1132 },\n    M: { 0: 11640, 1: 3486, 2: 2113, 4: 1452, 8: 894 },\n    Q: { 0: 8264, 1: 2473, 2: 1499, 4: 1030, 8: 634 },\n    H: { 0: 6344, 1: 1897, 2: 1150, 4: 790, 8: 486 }\n  },\n  32: {\n    L: { 0: 15640, 1: 4686, 2: 2840, 4: 1952, 8: 1201 },\n    M: { 0: 12328, 1: 3693, 2: 2238, 4: 1538, 8: 947 },\n    Q: { 0: 8920, 1: 2670, 2: 1618, 4: 1112, 8: 684 },\n    H: { 0: 6760, 1: 2022, 2: 1226, 4: 842, 8: 518 }\n  },\n  33: {\n    L: { 0: 16568, 1: 4965, 2: 3009, 4: 2068, 8: 1273 },\n    M: { 0: 13048, 1: 3909, 2: 2369, 4: 1628, 8: 1002 },\n    Q: { 0: 9368, 1: 2805, 2: 1700, 4: 1168, 8: 719 },\n    H: { 0: 7208, 1: 2157, 2: 1307, 4: 898, 8: 553 }\n  },\n  34: {\n    L: { 0: 17528, 1: 5253, 2: 3183, 4: 2188, 8: 1347 },\n    M: { 0: 13800, 1: 4134, 2: 2506, 4: 1722, 8: 1060 },\n    Q: { 0: 9848, 1: 2949, 2: 1787, 4: 1228, 8: 756 },\n    H: { 0: 7688, 1: 2301, 2: 1394, 4: 958, 8: 590 }\n  },\n  35: {\n    L: { 0: 18448, 1: 5529, 2: 3351, 4: 2303, 8: 1417 },\n    M: { 0: 14496, 1: 4343, 2: 2632, 4: 1809, 8: 1113 },\n    Q: { 0: 10288, 1: 3081, 2: 1867, 4: 1283, 8: 790 },\n    H: { 0: 7888, 1: 2361, 2: 1431, 4: 983, 8: 605 }\n  },\n  36: {\n    L: { 0: 19472, 1: 5836, 2: 3537, 4: 2431, 8: 1496 },\n    M: { 0: 15312, 1: 4588, 2: 2780, 4: 1911, 8: 1176 },\n    Q: { 0: 10832, 1: 3244, 2: 1966, 4: 1351, 8: 832 },\n    H: { 0: 8432, 1: 2524, 2: 1530, 4: 1051, 8: 647 }\n  },\n  37: {\n    L: { 0: 20528, 1: 6153, 2: 3729, 4: 2563, 8: 1577 },\n    M: { 0: 15936, 1: 4775, 2: 2894, 4: 1989, 8: 1224 },\n    Q: { 0: 11408, 1: 3417, 2: 2071, 4: 1423, 8: 876 },\n    H: { 0: 8768, 1: 2625, 2: 1591, 4: 1093, 8: 673 }\n  },\n  38: {\n    L: { 0: 21616, 1: 6479, 2: 3927, 4: 2699, 8: 1661 },\n    M: { 0: 16816, 1: 5039, 2: 3054, 4: 2099, 8: 1292 },\n    Q: { 0: 12016, 1: 3599, 2: 2181, 4: 1499, 8: 923 },\n    H: { 0: 9136, 1: 2735, 2: 1658, 4: 1139, 8: 701 }\n  },\n  39: {\n    L: { 0: 22496, 1: 6743, 2: 4087, 4: 2809, 8: 1729 },\n    M: { 0: 17728, 1: 5313, 2: 3220, 4: 2213, 8: 1362 },\n    Q: { 0: 12656, 1: 3791, 2: 2298, 4: 1579, 8: 972 },\n    H: { 0: 9776, 1: 2927, 2: 1774, 4: 1219, 8: 750 }\n  },\n  40: {\n    L: { 0: 23648, 1: 7089, 2: 4296, 4: 2953, 8: 1817 },\n    M: { 0: 18672, 1: 5596, 2: 3391, 4: 2331, 8: 1435 },\n    Q: { 0: 13328, 1: 3993, 2: 2420, 4: 1663, 8: 1024 },\n    H: { 0: 10208, 1: 3057, 2: 1852, 4: 1273, 8: 784 }\n  }\n}, lf = {\n  1: 21,\n  2: 25,\n  3: 29,\n  4: 33,\n  5: 37,\n  6: 41,\n  7: 45,\n  8: 49,\n  9: 53,\n  10: 57,\n  11: 61,\n  12: 65,\n  13: 69,\n  14: 73,\n  15: 77,\n  16: 81,\n  17: 85,\n  18: 89,\n  19: 93,\n  20: 97,\n  21: 101,\n  22: 105,\n  23: 109,\n  24: 113,\n  25: 117,\n  26: 121,\n  27: 125,\n  28: 129,\n  29: 133,\n  30: 137,\n  31: 141,\n  32: 145,\n  33: 149,\n  34: 153,\n  35: 157,\n  36: 161,\n  37: 165,\n  38: 169,\n  39: 173,\n  40: 177\n};\n/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nfunction sf(e) {\n  return e instanceof Uint8Array || ArrayBuffer.isView(e) && e.constructor.name === \"Uint8Array\";\n}\nfunction Na(e, r) {\n  return Array.isArray(r) ? r.length === 0 ? !0 : e ? r.every((t) => typeof t == \"string\") : r.every((t) => Number.isSafeInteger(t)) : !1;\n}\nfunction gn(e, r) {\n  if (typeof r != \"string\")\n    throw new Error(`${e}: string expected`);\n  return !0;\n}\nfunction Lr(e) {\n  if (!Number.isSafeInteger(e))\n    throw new Error(`invalid integer: ${e}`);\n}\nfunction pr(e) {\n  if (!Array.isArray(e))\n    throw new Error(\"array expected\");\n}\nfunction vn(e, r) {\n  if (!Na(!0, r))\n    throw new Error(`${e}: array of strings expected`);\n}\nfunction hf(e, r) {\n  if (!Na(!1, r))\n    throw new Error(`${e}: array of numbers expected`);\n}\n// @__NO_SIDE_EFFECTS__\nfunction uf(...e) {\n  const r = (n) => n, t = (n, a) => (l) => n(a(l)), i = e.map((n) => n.encode).reduceRight(t, r), f = e.map((n) => n.decode).reduce(t, r);\n  return { encode: i, decode: f };\n}\n// @__NO_SIDE_EFFECTS__\nfunction cf(e) {\n  const r = typeof e == \"string\" ? e.split(\"\") : e, t = r.length;\n  vn(\"alphabet\", r);\n  const i = new Map(r.map((f, n) => [f, n]));\n  return {\n    encode: (f) => (pr(f), f.map((n) => {\n      if (!Number.isSafeInteger(n) || n < 0 || n >= t)\n        throw new Error(`alphabet.encode: digit index outside alphabet \"${n}\". Allowed: ${e}`);\n      return r[n];\n    })),\n    decode: (f) => (pr(f), f.map((n) => {\n      gn(\"alphabet.decode\", n);\n      const a = i.get(n);\n      if (a === void 0)\n        throw new Error(`Unknown letter: \"${n}\". Allowed: ${e}`);\n      return a;\n    }))\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction df(e = \"\") {\n  return gn(\"join\", e), {\n    encode: (r) => (vn(\"join.decode\", r), r.join(e)),\n    decode: (r) => (gn(\"join.decode\", r), r.split(e))\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction _f(e, r = \"=\") {\n  return Lr(e), gn(\"padding\", r), {\n    encode(t) {\n      for (vn(\"padding.encode\", t); t.length * e % 8; )\n        t.push(r);\n      return t;\n    },\n    decode(t) {\n      vn(\"padding.decode\", t);\n      let i = t.length;\n      if (i * e % 8)\n        throw new Error(\"padding: invalid, string should have whole number of bytes\");\n      for (; i > 0 && t[i - 1] === r; i--)\n        if ((i - 1) * e % 8 === 0)\n          throw new Error(\"padding: invalid, string has too much padding\");\n      return t.slice(0, i);\n    }\n  };\n}\nconst Za = (e, r) => r === 0 ? e : Za(r, e % r), wn = /* @__NO_SIDE_EFFECTS__ */ (e, r) => e + (r - Za(e, r)), ir = /* @__PURE__ */ (() => {\n  let e = [];\n  for (let r = 0; r < 40; r++)\n    e.push(2 ** r);\n  return e;\n})();\nfunction Bi(e, r, t, i) {\n  if (pr(e), r <= 0 || r > 32)\n    throw new Error(`convertRadix2: wrong from=${r}`);\n  if (t <= 0 || t > 32)\n    throw new Error(`convertRadix2: wrong to=${t}`);\n  if (/* @__PURE__ */ wn(r, t) > 32)\n    throw new Error(`convertRadix2: carry overflow from=${r} to=${t} carryBits=${/* @__PURE__ */ wn(r, t)}`);\n  let f = 0, n = 0;\n  const a = ir[r], l = ir[t] - 1, s = [];\n  for (const h of e) {\n    if (Lr(h), h >= a)\n      throw new Error(`convertRadix2: invalid data word=${h} from=${r}`);\n    if (f = f << r | h, n + r > 32)\n      throw new Error(`convertRadix2: carry overflow pos=${n} from=${r}`);\n    for (n += r; n >= t; n -= t)\n      s.push((f >> n - t & l) >>> 0);\n    const u = ir[n];\n    if (u === void 0)\n      throw new Error(\"invalid carry\");\n    f &= u - 1;\n  }\n  if (f = f << t - n & l, !i && n >= r)\n    throw new Error(\"Excess padding\");\n  if (!i && f > 0)\n    throw new Error(`Non-zero padding: ${f}`);\n  return i && n > 0 && s.push(f >>> 0), s;\n}\n// @__NO_SIDE_EFFECTS__\nfunction gf(e, r = !1) {\n  if (Lr(e), e <= 0 || e > 32)\n    throw new Error(\"radix2: bits should be in (0..32]\");\n  if (/* @__PURE__ */ wn(8, e) > 32 || /* @__PURE__ */ wn(e, 8) > 32)\n    throw new Error(\"radix2: carry overflow\");\n  return {\n    encode: (t) => {\n      if (!sf(t))\n        throw new Error(\"radix2.encode input should be Uint8Array\");\n      return Bi(Array.from(t), 8, e, !r);\n    },\n    decode: (t) => (hf(\"radix2.decode\", t), Uint8Array.from(Bi(t, e, 8, r)))\n  };\n}\nconst Oa = /* @__PURE__ */ uf(/* @__PURE__ */ gf(5), /* @__PURE__ */ cf(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567\"), /* @__PURE__ */ _f(5), /* @__PURE__ */ df(\"\"));\n/*! pako 2.1.0 https://github.com/nodeca/pako @license (MIT AND Zlib) */\nconst vf = 4, Mi = 0, Ni = 1, wf = 2;\nfunction Nt(e) {\n  let r = e.length;\n  for (; --r >= 0; )\n    e[r] = 0;\n}\nconst bf = 0, Ha = 1, pf = 2, xf = 3, Ef = 258, Br = 29, en = 256, Yt = en + 1 + Br, Lt = 30, Mr = 19, Ua = 2 * Yt + 1, gt = 15, ar = 16, kf = 7, Nr = 256, Fa = 16, $a = 17, Pa = 18, xr = (\n  /* extra bits for each length code */\n  new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0])\n), _n = (\n  /* extra bits for each distance code */\n  new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13])\n), mf = (\n  /* extra bits for each bit length code */\n  new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7])\n), qa = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), yf = 512, tt = new Array((Yt + 2) * 2);\nNt(tt);\nconst Pt = new Array(Lt * 2);\nNt(Pt);\nconst Qt = new Array(yf);\nNt(Qt);\nconst Vt = new Array(Ef - xf + 1);\nNt(Vt);\nconst Zr = new Array(Br);\nNt(Zr);\nconst bn = new Array(Lt);\nNt(bn);\nfunction or(e, r, t, i, f) {\n  this.static_tree = e, this.extra_bits = r, this.extra_base = t, this.elems = i, this.max_length = f, this.has_stree = e && e.length;\n}\nlet Ka, Ya, Qa;\nfunction fr(e, r) {\n  this.dyn_tree = e, this.max_code = 0, this.stat_desc = r;\n}\nconst Va = (e) => e < 256 ? Qt[e] : Qt[256 + (e >>> 7)], jt = (e, r) => {\n  e.pending_buf[e.pending++] = r & 255, e.pending_buf[e.pending++] = r >>> 8 & 255;\n}, Le = (e, r, t) => {\n  e.bi_valid > ar - t ? (e.bi_buf |= r << e.bi_valid & 65535, jt(e, e.bi_buf), e.bi_buf = r >> ar - e.bi_valid, e.bi_valid += t - ar) : (e.bi_buf |= r << e.bi_valid & 65535, e.bi_valid += t);\n}, je = (e, r, t) => {\n  Le(\n    e,\n    t[r * 2],\n    t[r * 2 + 1]\n    /*.Len*/\n  );\n}, ja = (e, r) => {\n  let t = 0;\n  do\n    t |= e & 1, e >>>= 1, t <<= 1;\n  while (--r > 0);\n  return t >>> 1;\n}, Af = (e) => {\n  e.bi_valid === 16 ? (jt(e, e.bi_buf), e.bi_buf = 0, e.bi_valid = 0) : e.bi_valid >= 8 && (e.pending_buf[e.pending++] = e.bi_buf & 255, e.bi_buf >>= 8, e.bi_valid -= 8);\n}, Sf = (e, r) => {\n  const t = r.dyn_tree, i = r.max_code, f = r.stat_desc.static_tree, n = r.stat_desc.has_stree, a = r.stat_desc.extra_bits, l = r.stat_desc.extra_base, s = r.stat_desc.max_length;\n  let h, u, d, g, v, c, R = 0;\n  for (g = 0; g <= gt; g++)\n    e.bl_count[g] = 0;\n  for (t[e.heap[e.heap_max] * 2 + 1] = 0, h = e.heap_max + 1; h < Ua; h++)\n    u = e.heap[h], g = t[t[u * 2 + 1] * 2 + 1] + 1, g > s && (g = s, R++), t[u * 2 + 1] = g, !(u > i) && (e.bl_count[g]++, v = 0, u >= l && (v = a[u - l]), c = t[u * 2], e.opt_len += c * (g + v), n && (e.static_len += c * (f[u * 2 + 1] + v)));\n  if (R !== 0) {\n    do {\n      for (g = s - 1; e.bl_count[g] === 0; )\n        g--;\n      e.bl_count[g]--, e.bl_count[g + 1] += 2, e.bl_count[s]--, R -= 2;\n    } while (R > 0);\n    for (g = s; g !== 0; g--)\n      for (u = e.bl_count[g]; u !== 0; )\n        d = e.heap[--h], !(d > i) && (t[d * 2 + 1] !== g && (e.opt_len += (g - t[d * 2 + 1]) * t[d * 2], t[d * 2 + 1] = g), u--);\n  }\n}, Xa = (e, r, t) => {\n  const i = new Array(gt + 1);\n  let f = 0, n, a;\n  for (n = 1; n <= gt; n++)\n    f = f + t[n - 1] << 1, i[n] = f;\n  for (a = 0; a <= r; a++) {\n    let l = e[a * 2 + 1];\n    l !== 0 && (e[a * 2] = ja(i[l]++, l));\n  }\n}, Rf = () => {\n  let e, r, t, i, f;\n  const n = new Array(gt + 1);\n  for (t = 0, i = 0; i < Br - 1; i++)\n    for (Zr[i] = t, e = 0; e < 1 << xr[i]; e++)\n      Vt[t++] = i;\n  for (Vt[t - 1] = i, f = 0, i = 0; i < 16; i++)\n    for (bn[i] = f, e = 0; e < 1 << _n[i]; e++)\n      Qt[f++] = i;\n  for (f >>= 7; i < Lt; i++)\n    for (bn[i] = f << 7, e = 0; e < 1 << _n[i] - 7; e++)\n      Qt[256 + f++] = i;\n  for (r = 0; r <= gt; r++)\n    n[r] = 0;\n  for (e = 0; e <= 143; )\n    tt[e * 2 + 1] = 8, e++, n[8]++;\n  for (; e <= 255; )\n    tt[e * 2 + 1] = 9, e++, n[9]++;\n  for (; e <= 279; )\n    tt[e * 2 + 1] = 7, e++, n[7]++;\n  for (; e <= 287; )\n    tt[e * 2 + 1] = 8, e++, n[8]++;\n  for (Xa(tt, Yt + 1, n), e = 0; e < Lt; e++)\n    Pt[e * 2 + 1] = 5, Pt[e * 2] = ja(e, 5);\n  Ka = new or(tt, xr, en + 1, Yt, gt), Ya = new or(Pt, _n, 0, Lt, gt), Qa = new or(new Array(0), mf, 0, Mr, kf);\n}, Ja = (e) => {\n  let r;\n  for (r = 0; r < Yt; r++)\n    e.dyn_ltree[r * 2] = 0;\n  for (r = 0; r < Lt; r++)\n    e.dyn_dtree[r * 2] = 0;\n  for (r = 0; r < Mr; r++)\n    e.bl_tree[r * 2] = 0;\n  e.dyn_ltree[Nr * 2] = 1, e.opt_len = e.static_len = 0, e.sym_next = e.matches = 0;\n}, Wa = (e) => {\n  e.bi_valid > 8 ? jt(e, e.bi_buf) : e.bi_valid > 0 && (e.pending_buf[e.pending++] = e.bi_buf), e.bi_buf = 0, e.bi_valid = 0;\n}, Zi = (e, r, t, i) => {\n  const f = r * 2, n = t * 2;\n  return e[f] < e[n] || e[f] === e[n] && i[r] <= i[t];\n}, lr = (e, r, t) => {\n  const i = e.heap[t];\n  let f = t << 1;\n  for (; f <= e.heap_len && (f < e.heap_len && Zi(r, e.heap[f + 1], e.heap[f], e.depth) && f++, !Zi(r, i, e.heap[f], e.depth)); )\n    e.heap[t] = e.heap[f], t = f, f <<= 1;\n  e.heap[t] = i;\n}, Oi = (e, r, t) => {\n  let i, f, n = 0, a, l;\n  if (e.sym_next !== 0)\n    do\n      i = e.pending_buf[e.sym_buf + n++] & 255, i += (e.pending_buf[e.sym_buf + n++] & 255) << 8, f = e.pending_buf[e.sym_buf + n++], i === 0 ? je(e, f, r) : (a = Vt[f], je(e, a + en + 1, r), l = xr[a], l !== 0 && (f -= Zr[a], Le(e, f, l)), i--, a = Va(i), je(e, a, t), l = _n[a], l !== 0 && (i -= bn[a], Le(e, i, l)));\n    while (n < e.sym_next);\n  je(e, Nr, r);\n}, Er = (e, r) => {\n  const t = r.dyn_tree, i = r.stat_desc.static_tree, f = r.stat_desc.has_stree, n = r.stat_desc.elems;\n  let a, l, s = -1, h;\n  for (e.heap_len = 0, e.heap_max = Ua, a = 0; a < n; a++)\n    t[a * 2] !== 0 ? (e.heap[++e.heap_len] = s = a, e.depth[a] = 0) : t[a * 2 + 1] = 0;\n  for (; e.heap_len < 2; )\n    h = e.heap[++e.heap_len] = s < 2 ? ++s : 0, t[h * 2] = 1, e.depth[h] = 0, e.opt_len--, f && (e.static_len -= i[h * 2 + 1]);\n  for (r.max_code = s, a = e.heap_len >> 1; a >= 1; a--)\n    lr(e, t, a);\n  h = n;\n  do\n    a = e.heap[\n      1\n      /*SMALLEST*/\n    ], e.heap[\n      1\n      /*SMALLEST*/\n    ] = e.heap[e.heap_len--], lr(\n      e,\n      t,\n      1\n      /*SMALLEST*/\n    ), l = e.heap[\n      1\n      /*SMALLEST*/\n    ], e.heap[--e.heap_max] = a, e.heap[--e.heap_max] = l, t[h * 2] = t[a * 2] + t[l * 2], e.depth[h] = (e.depth[a] >= e.depth[l] ? e.depth[a] : e.depth[l]) + 1, t[a * 2 + 1] = t[l * 2 + 1] = h, e.heap[\n      1\n      /*SMALLEST*/\n    ] = h++, lr(\n      e,\n      t,\n      1\n      /*SMALLEST*/\n    );\n  while (e.heap_len >= 2);\n  e.heap[--e.heap_max] = e.heap[\n    1\n    /*SMALLEST*/\n  ], Sf(e, r), Xa(t, s, e.bl_count);\n}, Hi = (e, r, t) => {\n  let i, f = -1, n, a = r[0 * 2 + 1], l = 0, s = 7, h = 4;\n  for (a === 0 && (s = 138, h = 3), r[(t + 1) * 2 + 1] = 65535, i = 0; i <= t; i++)\n    n = a, a = r[(i + 1) * 2 + 1], !(++l < s && n === a) && (l < h ? e.bl_tree[n * 2] += l : n !== 0 ? (n !== f && e.bl_tree[n * 2]++, e.bl_tree[Fa * 2]++) : l <= 10 ? e.bl_tree[$a * 2]++ : e.bl_tree[Pa * 2]++, l = 0, f = n, a === 0 ? (s = 138, h = 3) : n === a ? (s = 6, h = 3) : (s = 7, h = 4));\n}, Ui = (e, r, t) => {\n  let i, f = -1, n, a = r[0 * 2 + 1], l = 0, s = 7, h = 4;\n  for (a === 0 && (s = 138, h = 3), i = 0; i <= t; i++)\n    if (n = a, a = r[(i + 1) * 2 + 1], !(++l < s && n === a)) {\n      if (l < h)\n        do\n          je(e, n, e.bl_tree);\n        while (--l !== 0);\n      else n !== 0 ? (n !== f && (je(e, n, e.bl_tree), l--), je(e, Fa, e.bl_tree), Le(e, l - 3, 2)) : l <= 10 ? (je(e, $a, e.bl_tree), Le(e, l - 3, 3)) : (je(e, Pa, e.bl_tree), Le(e, l - 11, 7));\n      l = 0, f = n, a === 0 ? (s = 138, h = 3) : n === a ? (s = 6, h = 3) : (s = 7, h = 4);\n    }\n}, Tf = (e) => {\n  let r;\n  for (Hi(e, e.dyn_ltree, e.l_desc.max_code), Hi(e, e.dyn_dtree, e.d_desc.max_code), Er(e, e.bl_desc), r = Mr - 1; r >= 3 && e.bl_tree[qa[r] * 2 + 1] === 0; r--)\n    ;\n  return e.opt_len += 3 * (r + 1) + 5 + 5 + 4, r;\n}, zf = (e, r, t, i) => {\n  let f;\n  for (Le(e, r - 257, 5), Le(e, t - 1, 5), Le(e, i - 4, 4), f = 0; f < i; f++)\n    Le(e, e.bl_tree[qa[f] * 2 + 1], 3);\n  Ui(e, e.dyn_ltree, r - 1), Ui(e, e.dyn_dtree, t - 1);\n}, Cf = (e) => {\n  let r = 4093624447, t;\n  for (t = 0; t <= 31; t++, r >>>= 1)\n    if (r & 1 && e.dyn_ltree[t * 2] !== 0)\n      return Mi;\n  if (e.dyn_ltree[9 * 2] !== 0 || e.dyn_ltree[10 * 2] !== 0 || e.dyn_ltree[13 * 2] !== 0)\n    return Ni;\n  for (t = 32; t < en; t++)\n    if (e.dyn_ltree[t * 2] !== 0)\n      return Ni;\n  return Mi;\n};\nlet Fi = !1;\nconst If = (e) => {\n  Fi || (Rf(), Fi = !0), e.l_desc = new fr(e.dyn_ltree, Ka), e.d_desc = new fr(e.dyn_dtree, Ya), e.bl_desc = new fr(e.bl_tree, Qa), e.bi_buf = 0, e.bi_valid = 0, Ja(e);\n}, Ga = (e, r, t, i) => {\n  Le(e, (bf << 1) + (i ? 1 : 0), 3), Wa(e), jt(e, t), jt(e, ~t), t && e.pending_buf.set(e.window.subarray(r, r + t), e.pending), e.pending += t;\n}, Df = (e) => {\n  Le(e, Ha << 1, 3), je(e, Nr, tt), Af(e);\n}, Lf = (e, r, t, i) => {\n  let f, n, a = 0;\n  e.level > 0 ? (e.strm.data_type === wf && (e.strm.data_type = Cf(e)), Er(e, e.l_desc), Er(e, e.d_desc), a = Tf(e), f = e.opt_len + 3 + 7 >>> 3, n = e.static_len + 3 + 7 >>> 3, n <= f && (f = n)) : f = n = t + 5, t + 4 <= f && r !== -1 ? Ga(e, r, t, i) : e.strategy === vf || n === f ? (Le(e, (Ha << 1) + (i ? 1 : 0), 3), Oi(e, tt, Pt)) : (Le(e, (pf << 1) + (i ? 1 : 0), 3), zf(e, e.l_desc.max_code + 1, e.d_desc.max_code + 1, a + 1), Oi(e, e.dyn_ltree, e.dyn_dtree)), Ja(e), i && Wa(e);\n}, Bf = (e, r, t) => (e.pending_buf[e.sym_buf + e.sym_next++] = r, e.pending_buf[e.sym_buf + e.sym_next++] = r >> 8, e.pending_buf[e.sym_buf + e.sym_next++] = t, r === 0 ? e.dyn_ltree[t * 2]++ : (e.matches++, r--, e.dyn_ltree[(Vt[t] + en + 1) * 2]++, e.dyn_dtree[Va(r) * 2]++), e.sym_next === e.sym_end);\nvar Mf = If, Nf = Ga, Zf = Lf, Of = Bf, Hf = Df, Uf = {\n  _tr_init: Mf,\n  _tr_stored_block: Nf,\n  _tr_flush_block: Zf,\n  _tr_tally: Of,\n  _tr_align: Hf\n};\nconst Ff = (e, r, t, i) => {\n  let f = e & 65535 | 0, n = e >>> 16 & 65535 | 0, a = 0;\n  for (; t !== 0; ) {\n    a = t > 2e3 ? 2e3 : t, t -= a;\n    do\n      f = f + r[i++] | 0, n = n + f | 0;\n    while (--a);\n    f %= 65521, n %= 65521;\n  }\n  return f | n << 16 | 0;\n};\nvar Xt = Ff;\nconst $f = () => {\n  let e, r = [];\n  for (var t = 0; t < 256; t++) {\n    e = t;\n    for (var i = 0; i < 8; i++)\n      e = e & 1 ? 3988292384 ^ e >>> 1 : e >>> 1;\n    r[t] = e;\n  }\n  return r;\n}, Pf = new Uint32Array($f()), qf = (e, r, t, i) => {\n  const f = Pf, n = i + t;\n  e ^= -1;\n  for (let a = i; a < n; a++)\n    e = e >>> 8 ^ f[(e ^ r[a]) & 255];\n  return e ^ -1;\n};\nvar me = qf, bt = {\n  2: \"need dictionary\",\n  /* Z_NEED_DICT       2  */\n  1: \"stream end\",\n  /* Z_STREAM_END      1  */\n  0: \"\",\n  /* Z_OK              0  */\n  \"-1\": \"file error\",\n  /* Z_ERRNO         (-1) */\n  \"-2\": \"stream error\",\n  /* Z_STREAM_ERROR  (-2) */\n  \"-3\": \"data error\",\n  /* Z_DATA_ERROR    (-3) */\n  \"-4\": \"insufficient memory\",\n  /* Z_MEM_ERROR     (-4) */\n  \"-5\": \"buffer error\",\n  /* Z_BUF_ERROR     (-5) */\n  \"-6\": \"incompatible version\"\n  /* Z_VERSION_ERROR (-6) */\n}, tn = {\n  /* Allowed flush values; see deflate() and inflate() below for details */\n  Z_NO_FLUSH: 0,\n  Z_PARTIAL_FLUSH: 1,\n  Z_SYNC_FLUSH: 2,\n  Z_FULL_FLUSH: 3,\n  Z_FINISH: 4,\n  Z_BLOCK: 5,\n  Z_TREES: 6,\n  /* Return codes for the compression/decompression functions. Negative values\n  * are errors, positive values are used for special but normal events.\n  */\n  Z_OK: 0,\n  Z_STREAM_END: 1,\n  Z_NEED_DICT: 2,\n  Z_ERRNO: -1,\n  Z_STREAM_ERROR: -2,\n  Z_DATA_ERROR: -3,\n  Z_MEM_ERROR: -4,\n  Z_BUF_ERROR: -5,\n  //Z_VERSION_ERROR: -6,\n  /* compression levels */\n  Z_NO_COMPRESSION: 0,\n  Z_BEST_SPEED: 1,\n  Z_BEST_COMPRESSION: 9,\n  Z_DEFAULT_COMPRESSION: -1,\n  Z_FILTERED: 1,\n  Z_HUFFMAN_ONLY: 2,\n  Z_RLE: 3,\n  Z_FIXED: 4,\n  Z_DEFAULT_STRATEGY: 0,\n  /* Possible values of the data_type field (though see inflate()) */\n  Z_BINARY: 0,\n  Z_TEXT: 1,\n  //Z_ASCII:                1, // = Z_TEXT (deprecated)\n  Z_UNKNOWN: 2,\n  /* The deflate compression method */\n  Z_DEFLATED: 8\n  //Z_NULL:                 null // Use -1 or null inline, depending on var type\n};\nconst { _tr_init: Kf, _tr_stored_block: kr, _tr_flush_block: Yf, _tr_tally: st, _tr_align: Qf } = Uf, {\n  Z_NO_FLUSH: ht,\n  Z_PARTIAL_FLUSH: Vf,\n  Z_FULL_FLUSH: jf,\n  Z_FINISH: Fe,\n  Z_BLOCK: $i,\n  Z_OK: Se,\n  Z_STREAM_END: Pi,\n  Z_STREAM_ERROR: Xe,\n  Z_DATA_ERROR: Xf,\n  Z_BUF_ERROR: sr,\n  Z_DEFAULT_COMPRESSION: Jf,\n  Z_FILTERED: Wf,\n  Z_HUFFMAN_ONLY: sn,\n  Z_RLE: Gf,\n  Z_FIXED: el,\n  Z_DEFAULT_STRATEGY: tl,\n  Z_UNKNOWN: nl,\n  Z_DEFLATED: En\n} = tn, rl = 9, il = 15, al = 8, ol = 29, fl = 256, mr = fl + 1 + ol, ll = 30, sl = 19, hl = 2 * mr + 1, ul = 15, oe = 3, lt = 258, Je = lt + oe + 1, cl = 32, Bt = 42, Or = 57, yr = 69, Ar = 73, Sr = 91, Rr = 103, vt = 113, Ft = 666, Ce = 1, Zt = 2, pt = 3, Ot = 4, dl = 3, wt = (e, r) => (e.msg = bt[r], r), qi = (e) => e * 2 - (e > 4 ? 9 : 0), ft = (e) => {\n  let r = e.length;\n  for (; --r >= 0; )\n    e[r] = 0;\n}, _l = (e) => {\n  let r, t, i, f = e.w_size;\n  r = e.hash_size, i = r;\n  do\n    t = e.head[--i], e.head[i] = t >= f ? t - f : 0;\n  while (--r);\n  r = f, i = r;\n  do\n    t = e.prev[--i], e.prev[i] = t >= f ? t - f : 0;\n  while (--r);\n};\nlet gl = (e, r, t) => (r << e.hash_shift ^ t) & e.hash_mask, ut = gl;\nconst Be = (e) => {\n  const r = e.state;\n  let t = r.pending;\n  t > e.avail_out && (t = e.avail_out), t !== 0 && (e.output.set(r.pending_buf.subarray(r.pending_out, r.pending_out + t), e.next_out), e.next_out += t, r.pending_out += t, e.total_out += t, e.avail_out -= t, r.pending -= t, r.pending === 0 && (r.pending_out = 0));\n}, Me = (e, r) => {\n  Yf(e, e.block_start >= 0 ? e.block_start : -1, e.strstart - e.block_start, r), e.block_start = e.strstart, Be(e.strm);\n}, se = (e, r) => {\n  e.pending_buf[e.pending++] = r;\n}, Ut = (e, r) => {\n  e.pending_buf[e.pending++] = r >>> 8 & 255, e.pending_buf[e.pending++] = r & 255;\n}, Tr = (e, r, t, i) => {\n  let f = e.avail_in;\n  return f > i && (f = i), f === 0 ? 0 : (e.avail_in -= f, r.set(e.input.subarray(e.next_in, e.next_in + f), t), e.state.wrap === 1 ? e.adler = Xt(e.adler, r, f, t) : e.state.wrap === 2 && (e.adler = me(e.adler, r, f, t)), e.next_in += f, e.total_in += f, f);\n}, eo = (e, r) => {\n  let t = e.max_chain_length, i = e.strstart, f, n, a = e.prev_length, l = e.nice_match;\n  const s = e.strstart > e.w_size - Je ? e.strstart - (e.w_size - Je) : 0, h = e.window, u = e.w_mask, d = e.prev, g = e.strstart + lt;\n  let v = h[i + a - 1], c = h[i + a];\n  e.prev_length >= e.good_match && (t >>= 2), l > e.lookahead && (l = e.lookahead);\n  do\n    if (f = r, !(h[f + a] !== c || h[f + a - 1] !== v || h[f] !== h[i] || h[++f] !== h[i + 1])) {\n      i += 2, f++;\n      do\n        ;\n      while (h[++i] === h[++f] && h[++i] === h[++f] && h[++i] === h[++f] && h[++i] === h[++f] && h[++i] === h[++f] && h[++i] === h[++f] && h[++i] === h[++f] && h[++i] === h[++f] && i < g);\n      if (n = lt - (g - i), i = g - lt, n > a) {\n        if (e.match_start = r, a = n, n >= l)\n          break;\n        v = h[i + a - 1], c = h[i + a];\n      }\n    }\n  while ((r = d[r & u]) > s && --t !== 0);\n  return a <= e.lookahead ? a : e.lookahead;\n}, Mt = (e) => {\n  const r = e.w_size;\n  let t, i, f;\n  do {\n    if (i = e.window_size - e.lookahead - e.strstart, e.strstart >= r + (r - Je) && (e.window.set(e.window.subarray(r, r + r - i), 0), e.match_start -= r, e.strstart -= r, e.block_start -= r, e.insert > e.strstart && (e.insert = e.strstart), _l(e), i += r), e.strm.avail_in === 0)\n      break;\n    if (t = Tr(e.strm, e.window, e.strstart + e.lookahead, i), e.lookahead += t, e.lookahead + e.insert >= oe)\n      for (f = e.strstart - e.insert, e.ins_h = e.window[f], e.ins_h = ut(e, e.ins_h, e.window[f + 1]); e.insert && (e.ins_h = ut(e, e.ins_h, e.window[f + oe - 1]), e.prev[f & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = f, f++, e.insert--, !(e.lookahead + e.insert < oe)); )\n        ;\n  } while (e.lookahead < Je && e.strm.avail_in !== 0);\n}, to = (e, r) => {\n  let t = e.pending_buf_size - 5 > e.w_size ? e.w_size : e.pending_buf_size - 5, i, f, n, a = 0, l = e.strm.avail_in;\n  do {\n    if (i = 65535, n = e.bi_valid + 42 >> 3, e.strm.avail_out < n || (n = e.strm.avail_out - n, f = e.strstart - e.block_start, i > f + e.strm.avail_in && (i = f + e.strm.avail_in), i > n && (i = n), i < t && (i === 0 && r !== Fe || r === ht || i !== f + e.strm.avail_in)))\n      break;\n    a = r === Fe && i === f + e.strm.avail_in ? 1 : 0, kr(e, 0, 0, a), e.pending_buf[e.pending - 4] = i, e.pending_buf[e.pending - 3] = i >> 8, e.pending_buf[e.pending - 2] = ~i, e.pending_buf[e.pending - 1] = ~i >> 8, Be(e.strm), f && (f > i && (f = i), e.strm.output.set(e.window.subarray(e.block_start, e.block_start + f), e.strm.next_out), e.strm.next_out += f, e.strm.avail_out -= f, e.strm.total_out += f, e.block_start += f, i -= f), i && (Tr(e.strm, e.strm.output, e.strm.next_out, i), e.strm.next_out += i, e.strm.avail_out -= i, e.strm.total_out += i);\n  } while (a === 0);\n  return l -= e.strm.avail_in, l && (l >= e.w_size ? (e.matches = 2, e.window.set(e.strm.input.subarray(e.strm.next_in - e.w_size, e.strm.next_in), 0), e.strstart = e.w_size, e.insert = e.strstart) : (e.window_size - e.strstart <= l && (e.strstart -= e.w_size, e.window.set(e.window.subarray(e.w_size, e.w_size + e.strstart), 0), e.matches < 2 && e.matches++, e.insert > e.strstart && (e.insert = e.strstart)), e.window.set(e.strm.input.subarray(e.strm.next_in - l, e.strm.next_in), e.strstart), e.strstart += l, e.insert += l > e.w_size - e.insert ? e.w_size - e.insert : l), e.block_start = e.strstart), e.high_water < e.strstart && (e.high_water = e.strstart), a ? Ot : r !== ht && r !== Fe && e.strm.avail_in === 0 && e.strstart === e.block_start ? Zt : (n = e.window_size - e.strstart, e.strm.avail_in > n && e.block_start >= e.w_size && (e.block_start -= e.w_size, e.strstart -= e.w_size, e.window.set(e.window.subarray(e.w_size, e.w_size + e.strstart), 0), e.matches < 2 && e.matches++, n += e.w_size, e.insert > e.strstart && (e.insert = e.strstart)), n > e.strm.avail_in && (n = e.strm.avail_in), n && (Tr(e.strm, e.window, e.strstart, n), e.strstart += n, e.insert += n > e.w_size - e.insert ? e.w_size - e.insert : n), e.high_water < e.strstart && (e.high_water = e.strstart), n = e.bi_valid + 42 >> 3, n = e.pending_buf_size - n > 65535 ? 65535 : e.pending_buf_size - n, t = n > e.w_size ? e.w_size : n, f = e.strstart - e.block_start, (f >= t || (f || r === Fe) && r !== ht && e.strm.avail_in === 0 && f <= n) && (i = f > n ? n : f, a = r === Fe && e.strm.avail_in === 0 && i === f ? 1 : 0, kr(e, e.block_start, i, a), e.block_start += i, Be(e.strm)), a ? pt : Ce);\n}, hr = (e, r) => {\n  let t, i;\n  for (; ; ) {\n    if (e.lookahead < Je) {\n      if (Mt(e), e.lookahead < Je && r === ht)\n        return Ce;\n      if (e.lookahead === 0)\n        break;\n    }\n    if (t = 0, e.lookahead >= oe && (e.ins_h = ut(e, e.ins_h, e.window[e.strstart + oe - 1]), t = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = e.strstart), t !== 0 && e.strstart - t <= e.w_size - Je && (e.match_length = eo(e, t)), e.match_length >= oe)\n      if (i = st(e, e.strstart - e.match_start, e.match_length - oe), e.lookahead -= e.match_length, e.match_length <= e.max_lazy_match && e.lookahead >= oe) {\n        e.match_length--;\n        do\n          e.strstart++, e.ins_h = ut(e, e.ins_h, e.window[e.strstart + oe - 1]), t = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = e.strstart;\n        while (--e.match_length !== 0);\n        e.strstart++;\n      } else\n        e.strstart += e.match_length, e.match_length = 0, e.ins_h = e.window[e.strstart], e.ins_h = ut(e, e.ins_h, e.window[e.strstart + 1]);\n    else\n      i = st(e, 0, e.window[e.strstart]), e.lookahead--, e.strstart++;\n    if (i && (Me(e, !1), e.strm.avail_out === 0))\n      return Ce;\n  }\n  return e.insert = e.strstart < oe - 1 ? e.strstart : oe - 1, r === Fe ? (Me(e, !0), e.strm.avail_out === 0 ? pt : Ot) : e.sym_next && (Me(e, !1), e.strm.avail_out === 0) ? Ce : Zt;\n}, It = (e, r) => {\n  let t, i, f;\n  for (; ; ) {\n    if (e.lookahead < Je) {\n      if (Mt(e), e.lookahead < Je && r === ht)\n        return Ce;\n      if (e.lookahead === 0)\n        break;\n    }\n    if (t = 0, e.lookahead >= oe && (e.ins_h = ut(e, e.ins_h, e.window[e.strstart + oe - 1]), t = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = e.strstart), e.prev_length = e.match_length, e.prev_match = e.match_start, e.match_length = oe - 1, t !== 0 && e.prev_length < e.max_lazy_match && e.strstart - t <= e.w_size - Je && (e.match_length = eo(e, t), e.match_length <= 5 && (e.strategy === Wf || e.match_length === oe && e.strstart - e.match_start > 4096) && (e.match_length = oe - 1)), e.prev_length >= oe && e.match_length <= e.prev_length) {\n      f = e.strstart + e.lookahead - oe, i = st(e, e.strstart - 1 - e.prev_match, e.prev_length - oe), e.lookahead -= e.prev_length - 1, e.prev_length -= 2;\n      do\n        ++e.strstart <= f && (e.ins_h = ut(e, e.ins_h, e.window[e.strstart + oe - 1]), t = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = e.strstart);\n      while (--e.prev_length !== 0);\n      if (e.match_available = 0, e.match_length = oe - 1, e.strstart++, i && (Me(e, !1), e.strm.avail_out === 0))\n        return Ce;\n    } else if (e.match_available) {\n      if (i = st(e, 0, e.window[e.strstart - 1]), i && Me(e, !1), e.strstart++, e.lookahead--, e.strm.avail_out === 0)\n        return Ce;\n    } else\n      e.match_available = 1, e.strstart++, e.lookahead--;\n  }\n  return e.match_available && (i = st(e, 0, e.window[e.strstart - 1]), e.match_available = 0), e.insert = e.strstart < oe - 1 ? e.strstart : oe - 1, r === Fe ? (Me(e, !0), e.strm.avail_out === 0 ? pt : Ot) : e.sym_next && (Me(e, !1), e.strm.avail_out === 0) ? Ce : Zt;\n}, vl = (e, r) => {\n  let t, i, f, n;\n  const a = e.window;\n  for (; ; ) {\n    if (e.lookahead <= lt) {\n      if (Mt(e), e.lookahead <= lt && r === ht)\n        return Ce;\n      if (e.lookahead === 0)\n        break;\n    }\n    if (e.match_length = 0, e.lookahead >= oe && e.strstart > 0 && (f = e.strstart - 1, i = a[f], i === a[++f] && i === a[++f] && i === a[++f])) {\n      n = e.strstart + lt;\n      do\n        ;\n      while (i === a[++f] && i === a[++f] && i === a[++f] && i === a[++f] && i === a[++f] && i === a[++f] && i === a[++f] && i === a[++f] && f < n);\n      e.match_length = lt - (n - f), e.match_length > e.lookahead && (e.match_length = e.lookahead);\n    }\n    if (e.match_length >= oe ? (t = st(e, 1, e.match_length - oe), e.lookahead -= e.match_length, e.strstart += e.match_length, e.match_length = 0) : (t = st(e, 0, e.window[e.strstart]), e.lookahead--, e.strstart++), t && (Me(e, !1), e.strm.avail_out === 0))\n      return Ce;\n  }\n  return e.insert = 0, r === Fe ? (Me(e, !0), e.strm.avail_out === 0 ? pt : Ot) : e.sym_next && (Me(e, !1), e.strm.avail_out === 0) ? Ce : Zt;\n}, wl = (e, r) => {\n  let t;\n  for (; ; ) {\n    if (e.lookahead === 0 && (Mt(e), e.lookahead === 0)) {\n      if (r === ht)\n        return Ce;\n      break;\n    }\n    if (e.match_length = 0, t = st(e, 0, e.window[e.strstart]), e.lookahead--, e.strstart++, t && (Me(e, !1), e.strm.avail_out === 0))\n      return Ce;\n  }\n  return e.insert = 0, r === Fe ? (Me(e, !0), e.strm.avail_out === 0 ? pt : Ot) : e.sym_next && (Me(e, !1), e.strm.avail_out === 0) ? Ce : Zt;\n};\nfunction Ve(e, r, t, i, f) {\n  this.good_length = e, this.max_lazy = r, this.nice_length = t, this.max_chain = i, this.func = f;\n}\nconst $t = [\n  /*      good lazy nice chain */\n  new Ve(0, 0, 0, 0, to),\n  /* 0 store only */\n  new Ve(4, 4, 8, 4, hr),\n  /* 1 max speed, no lazy matches */\n  new Ve(4, 5, 16, 8, hr),\n  /* 2 */\n  new Ve(4, 6, 32, 32, hr),\n  /* 3 */\n  new Ve(4, 4, 16, 16, It),\n  /* 4 lazy matches */\n  new Ve(8, 16, 32, 32, It),\n  /* 5 */\n  new Ve(8, 16, 128, 128, It),\n  /* 6 */\n  new Ve(8, 32, 128, 256, It),\n  /* 7 */\n  new Ve(32, 128, 258, 1024, It),\n  /* 8 */\n  new Ve(32, 258, 258, 4096, It)\n  /* 9 max compression */\n], bl = (e) => {\n  e.window_size = 2 * e.w_size, ft(e.head), e.max_lazy_match = $t[e.level].max_lazy, e.good_match = $t[e.level].good_length, e.nice_match = $t[e.level].nice_length, e.max_chain_length = $t[e.level].max_chain, e.strstart = 0, e.block_start = 0, e.lookahead = 0, e.insert = 0, e.match_length = e.prev_length = oe - 1, e.match_available = 0, e.ins_h = 0;\n};\nfunction pl() {\n  this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = En, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new Uint16Array(hl * 2), this.dyn_dtree = new Uint16Array((2 * ll + 1) * 2), this.bl_tree = new Uint16Array((2 * sl + 1) * 2), ft(this.dyn_ltree), ft(this.dyn_dtree), ft(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new Uint16Array(ul + 1), this.heap = new Uint16Array(2 * mr + 1), ft(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new Uint16Array(2 * mr + 1), ft(this.depth), this.sym_buf = 0, this.lit_bufsize = 0, this.sym_next = 0, this.sym_end = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;\n}\nconst nn = (e) => {\n  if (!e)\n    return 1;\n  const r = e.state;\n  return !r || r.strm !== e || r.status !== Bt && //#ifdef GZIP\n  r.status !== Or && //#endif\n  r.status !== yr && r.status !== Ar && r.status !== Sr && r.status !== Rr && r.status !== vt && r.status !== Ft ? 1 : 0;\n}, no = (e) => {\n  if (nn(e))\n    return wt(e, Xe);\n  e.total_in = e.total_out = 0, e.data_type = nl;\n  const r = e.state;\n  return r.pending = 0, r.pending_out = 0, r.wrap < 0 && (r.wrap = -r.wrap), r.status = //#ifdef GZIP\n  r.wrap === 2 ? Or : (\n    //#endif\n    r.wrap ? Bt : vt\n  ), e.adler = r.wrap === 2 ? 0 : 1, r.last_flush = -2, Kf(r), Se;\n}, ro = (e) => {\n  const r = no(e);\n  return r === Se && bl(e.state), r;\n}, xl = (e, r) => nn(e) || e.state.wrap !== 2 ? Xe : (e.state.gzhead = r, Se), io = (e, r, t, i, f, n) => {\n  if (!e)\n    return Xe;\n  let a = 1;\n  if (r === Jf && (r = 6), i < 0 ? (a = 0, i = -i) : i > 15 && (a = 2, i -= 16), f < 1 || f > rl || t !== En || i < 8 || i > 15 || r < 0 || r > 9 || n < 0 || n > el || i === 8 && a !== 1)\n    return wt(e, Xe);\n  i === 8 && (i = 9);\n  const l = new pl();\n  return e.state = l, l.strm = e, l.status = Bt, l.wrap = a, l.gzhead = null, l.w_bits = i, l.w_size = 1 << l.w_bits, l.w_mask = l.w_size - 1, l.hash_bits = f + 7, l.hash_size = 1 << l.hash_bits, l.hash_mask = l.hash_size - 1, l.hash_shift = ~~((l.hash_bits + oe - 1) / oe), l.window = new Uint8Array(l.w_size * 2), l.head = new Uint16Array(l.hash_size), l.prev = new Uint16Array(l.w_size), l.lit_bufsize = 1 << f + 6, l.pending_buf_size = l.lit_bufsize * 4, l.pending_buf = new Uint8Array(l.pending_buf_size), l.sym_buf = l.lit_bufsize, l.sym_end = (l.lit_bufsize - 1) * 3, l.level = r, l.strategy = n, l.method = t, ro(e);\n}, El = (e, r) => io(e, r, En, il, al, tl), kl = (e, r) => {\n  if (nn(e) || r > $i || r < 0)\n    return e ? wt(e, Xe) : Xe;\n  const t = e.state;\n  if (!e.output || e.avail_in !== 0 && !e.input || t.status === Ft && r !== Fe)\n    return wt(e, e.avail_out === 0 ? sr : Xe);\n  const i = t.last_flush;\n  if (t.last_flush = r, t.pending !== 0) {\n    if (Be(e), e.avail_out === 0)\n      return t.last_flush = -1, Se;\n  } else if (e.avail_in === 0 && qi(r) <= qi(i) && r !== Fe)\n    return wt(e, sr);\n  if (t.status === Ft && e.avail_in !== 0)\n    return wt(e, sr);\n  if (t.status === Bt && t.wrap === 0 && (t.status = vt), t.status === Bt) {\n    let f = En + (t.w_bits - 8 << 4) << 8, n = -1;\n    if (t.strategy >= sn || t.level < 2 ? n = 0 : t.level < 6 ? n = 1 : t.level === 6 ? n = 2 : n = 3, f |= n << 6, t.strstart !== 0 && (f |= cl), f += 31 - f % 31, Ut(t, f), t.strstart !== 0 && (Ut(t, e.adler >>> 16), Ut(t, e.adler & 65535)), e.adler = 1, t.status = vt, Be(e), t.pending !== 0)\n      return t.last_flush = -1, Se;\n  }\n  if (t.status === Or) {\n    if (e.adler = 0, se(t, 31), se(t, 139), se(t, 8), t.gzhead)\n      se(\n        t,\n        (t.gzhead.text ? 1 : 0) + (t.gzhead.hcrc ? 2 : 0) + (t.gzhead.extra ? 4 : 0) + (t.gzhead.name ? 8 : 0) + (t.gzhead.comment ? 16 : 0)\n      ), se(t, t.gzhead.time & 255), se(t, t.gzhead.time >> 8 & 255), se(t, t.gzhead.time >> 16 & 255), se(t, t.gzhead.time >> 24 & 255), se(t, t.level === 9 ? 2 : t.strategy >= sn || t.level < 2 ? 4 : 0), se(t, t.gzhead.os & 255), t.gzhead.extra && t.gzhead.extra.length && (se(t, t.gzhead.extra.length & 255), se(t, t.gzhead.extra.length >> 8 & 255)), t.gzhead.hcrc && (e.adler = me(e.adler, t.pending_buf, t.pending, 0)), t.gzindex = 0, t.status = yr;\n    else if (se(t, 0), se(t, 0), se(t, 0), se(t, 0), se(t, 0), se(t, t.level === 9 ? 2 : t.strategy >= sn || t.level < 2 ? 4 : 0), se(t, dl), t.status = vt, Be(e), t.pending !== 0)\n      return t.last_flush = -1, Se;\n  }\n  if (t.status === yr) {\n    if (t.gzhead.extra) {\n      let f = t.pending, n = (t.gzhead.extra.length & 65535) - t.gzindex;\n      for (; t.pending + n > t.pending_buf_size; ) {\n        let l = t.pending_buf_size - t.pending;\n        if (t.pending_buf.set(t.gzhead.extra.subarray(t.gzindex, t.gzindex + l), t.pending), t.pending = t.pending_buf_size, t.gzhead.hcrc && t.pending > f && (e.adler = me(e.adler, t.pending_buf, t.pending - f, f)), t.gzindex += l, Be(e), t.pending !== 0)\n          return t.last_flush = -1, Se;\n        f = 0, n -= l;\n      }\n      let a = new Uint8Array(t.gzhead.extra);\n      t.pending_buf.set(a.subarray(t.gzindex, t.gzindex + n), t.pending), t.pending += n, t.gzhead.hcrc && t.pending > f && (e.adler = me(e.adler, t.pending_buf, t.pending - f, f)), t.gzindex = 0;\n    }\n    t.status = Ar;\n  }\n  if (t.status === Ar) {\n    if (t.gzhead.name) {\n      let f = t.pending, n;\n      do {\n        if (t.pending === t.pending_buf_size) {\n          if (t.gzhead.hcrc && t.pending > f && (e.adler = me(e.adler, t.pending_buf, t.pending - f, f)), Be(e), t.pending !== 0)\n            return t.last_flush = -1, Se;\n          f = 0;\n        }\n        t.gzindex < t.gzhead.name.length ? n = t.gzhead.name.charCodeAt(t.gzindex++) & 255 : n = 0, se(t, n);\n      } while (n !== 0);\n      t.gzhead.hcrc && t.pending > f && (e.adler = me(e.adler, t.pending_buf, t.pending - f, f)), t.gzindex = 0;\n    }\n    t.status = Sr;\n  }\n  if (t.status === Sr) {\n    if (t.gzhead.comment) {\n      let f = t.pending, n;\n      do {\n        if (t.pending === t.pending_buf_size) {\n          if (t.gzhead.hcrc && t.pending > f && (e.adler = me(e.adler, t.pending_buf, t.pending - f, f)), Be(e), t.pending !== 0)\n            return t.last_flush = -1, Se;\n          f = 0;\n        }\n        t.gzindex < t.gzhead.comment.length ? n = t.gzhead.comment.charCodeAt(t.gzindex++) & 255 : n = 0, se(t, n);\n      } while (n !== 0);\n      t.gzhead.hcrc && t.pending > f && (e.adler = me(e.adler, t.pending_buf, t.pending - f, f));\n    }\n    t.status = Rr;\n  }\n  if (t.status === Rr) {\n    if (t.gzhead.hcrc) {\n      if (t.pending + 2 > t.pending_buf_size && (Be(e), t.pending !== 0))\n        return t.last_flush = -1, Se;\n      se(t, e.adler & 255), se(t, e.adler >> 8 & 255), e.adler = 0;\n    }\n    if (t.status = vt, Be(e), t.pending !== 0)\n      return t.last_flush = -1, Se;\n  }\n  if (e.avail_in !== 0 || t.lookahead !== 0 || r !== ht && t.status !== Ft) {\n    let f = t.level === 0 ? to(t, r) : t.strategy === sn ? wl(t, r) : t.strategy === Gf ? vl(t, r) : $t[t.level].func(t, r);\n    if ((f === pt || f === Ot) && (t.status = Ft), f === Ce || f === pt)\n      return e.avail_out === 0 && (t.last_flush = -1), Se;\n    if (f === Zt && (r === Vf ? Qf(t) : r !== $i && (kr(t, 0, 0, !1), r === jf && (ft(t.head), t.lookahead === 0 && (t.strstart = 0, t.block_start = 0, t.insert = 0))), Be(e), e.avail_out === 0))\n      return t.last_flush = -1, Se;\n  }\n  return r !== Fe ? Se : t.wrap <= 0 ? Pi : (t.wrap === 2 ? (se(t, e.adler & 255), se(t, e.adler >> 8 & 255), se(t, e.adler >> 16 & 255), se(t, e.adler >> 24 & 255), se(t, e.total_in & 255), se(t, e.total_in >> 8 & 255), se(t, e.total_in >> 16 & 255), se(t, e.total_in >> 24 & 255)) : (Ut(t, e.adler >>> 16), Ut(t, e.adler & 65535)), Be(e), t.wrap > 0 && (t.wrap = -t.wrap), t.pending !== 0 ? Se : Pi);\n}, ml = (e) => {\n  if (nn(e))\n    return Xe;\n  const r = e.state.status;\n  return e.state = null, r === vt ? wt(e, Xf) : Se;\n}, yl = (e, r) => {\n  let t = r.length;\n  if (nn(e))\n    return Xe;\n  const i = e.state, f = i.wrap;\n  if (f === 2 || f === 1 && i.status !== Bt || i.lookahead)\n    return Xe;\n  if (f === 1 && (e.adler = Xt(e.adler, r, t, 0)), i.wrap = 0, t >= i.w_size) {\n    f === 0 && (ft(i.head), i.strstart = 0, i.block_start = 0, i.insert = 0);\n    let s = new Uint8Array(i.w_size);\n    s.set(r.subarray(t - i.w_size, t), 0), r = s, t = i.w_size;\n  }\n  const n = e.avail_in, a = e.next_in, l = e.input;\n  for (e.avail_in = t, e.next_in = 0, e.input = r, Mt(i); i.lookahead >= oe; ) {\n    let s = i.strstart, h = i.lookahead - (oe - 1);\n    do\n      i.ins_h = ut(i, i.ins_h, i.window[s + oe - 1]), i.prev[s & i.w_mask] = i.head[i.ins_h], i.head[i.ins_h] = s, s++;\n    while (--h);\n    i.strstart = s, i.lookahead = oe - 1, Mt(i);\n  }\n  return i.strstart += i.lookahead, i.block_start = i.strstart, i.insert = i.lookahead, i.lookahead = 0, i.match_length = i.prev_length = oe - 1, i.match_available = 0, e.next_in = a, e.input = l, e.avail_in = n, i.wrap = f, Se;\n};\nvar Al = El, Sl = io, Rl = ro, Tl = no, zl = xl, Cl = kl, Il = ml, Dl = yl, Ll = \"pako deflate (from Nodeca project)\", qt = {\n  deflateInit: Al,\n  deflateInit2: Sl,\n  deflateReset: Rl,\n  deflateResetKeep: Tl,\n  deflateSetHeader: zl,\n  deflate: Cl,\n  deflateEnd: Il,\n  deflateSetDictionary: Dl,\n  deflateInfo: Ll\n};\nconst Bl = (e, r) => Object.prototype.hasOwnProperty.call(e, r);\nvar Ml = function(e) {\n  const r = Array.prototype.slice.call(arguments, 1);\n  for (; r.length; ) {\n    const t = r.shift();\n    if (t) {\n      if (typeof t != \"object\")\n        throw new TypeError(t + \"must be non-object\");\n      for (const i in t)\n        Bl(t, i) && (e[i] = t[i]);\n    }\n  }\n  return e;\n}, Nl = (e) => {\n  let r = 0;\n  for (let i = 0, f = e.length; i < f; i++)\n    r += e[i].length;\n  const t = new Uint8Array(r);\n  for (let i = 0, f = 0, n = e.length; i < n; i++) {\n    let a = e[i];\n    t.set(a, f), f += a.length;\n  }\n  return t;\n}, kn = {\n  assign: Ml,\n  flattenChunks: Nl\n};\nlet ao = !0;\ntry {\n  String.fromCharCode.apply(null, new Uint8Array(1));\n} catch {\n  ao = !1;\n}\nconst Jt = new Uint8Array(256);\nfor (let e = 0; e < 256; e++)\n  Jt[e] = e >= 252 ? 6 : e >= 248 ? 5 : e >= 240 ? 4 : e >= 224 ? 3 : e >= 192 ? 2 : 1;\nJt[254] = Jt[254] = 1;\nvar Zl = (e) => {\n  if (typeof TextEncoder == \"function\" && TextEncoder.prototype.encode)\n    return new TextEncoder().encode(e);\n  let r, t, i, f, n, a = e.length, l = 0;\n  for (f = 0; f < a; f++)\n    t = e.charCodeAt(f), (t & 64512) === 55296 && f + 1 < a && (i = e.charCodeAt(f + 1), (i & 64512) === 56320 && (t = 65536 + (t - 55296 << 10) + (i - 56320), f++)), l += t < 128 ? 1 : t < 2048 ? 2 : t < 65536 ? 3 : 4;\n  for (r = new Uint8Array(l), n = 0, f = 0; n < l; f++)\n    t = e.charCodeAt(f), (t & 64512) === 55296 && f + 1 < a && (i = e.charCodeAt(f + 1), (i & 64512) === 56320 && (t = 65536 + (t - 55296 << 10) + (i - 56320), f++)), t < 128 ? r[n++] = t : t < 2048 ? (r[n++] = 192 | t >>> 6, r[n++] = 128 | t & 63) : t < 65536 ? (r[n++] = 224 | t >>> 12, r[n++] = 128 | t >>> 6 & 63, r[n++] = 128 | t & 63) : (r[n++] = 240 | t >>> 18, r[n++] = 128 | t >>> 12 & 63, r[n++] = 128 | t >>> 6 & 63, r[n++] = 128 | t & 63);\n  return r;\n};\nconst Ol = (e, r) => {\n  if (r < 65534 && e.subarray && ao)\n    return String.fromCharCode.apply(null, e.length === r ? e : e.subarray(0, r));\n  let t = \"\";\n  for (let i = 0; i < r; i++)\n    t += String.fromCharCode(e[i]);\n  return t;\n};\nvar Hl = (e, r) => {\n  const t = r || e.length;\n  if (typeof TextDecoder == \"function\" && TextDecoder.prototype.decode)\n    return new TextDecoder().decode(e.subarray(0, r));\n  let i, f;\n  const n = new Array(t * 2);\n  for (f = 0, i = 0; i < t; ) {\n    let a = e[i++];\n    if (a < 128) {\n      n[f++] = a;\n      continue;\n    }\n    let l = Jt[a];\n    if (l > 4) {\n      n[f++] = 65533, i += l - 1;\n      continue;\n    }\n    for (a &= l === 2 ? 31 : l === 3 ? 15 : 7; l > 1 && i < t; )\n      a = a << 6 | e[i++] & 63, l--;\n    if (l > 1) {\n      n[f++] = 65533;\n      continue;\n    }\n    a < 65536 ? n[f++] = a : (a -= 65536, n[f++] = 55296 | a >> 10 & 1023, n[f++] = 56320 | a & 1023);\n  }\n  return Ol(n, f);\n}, Ul = (e, r) => {\n  r = r || e.length, r > e.length && (r = e.length);\n  let t = r - 1;\n  for (; t >= 0 && (e[t] & 192) === 128; )\n    t--;\n  return t < 0 || t === 0 ? r : t + Jt[e[t]] > r ? t : r;\n}, Wt = {\n  string2buf: Zl,\n  buf2string: Hl,\n  utf8border: Ul\n};\nfunction Fl() {\n  this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = \"\", this.state = null, this.data_type = 2, this.adler = 0;\n}\nvar oo = Fl;\nconst fo = Object.prototype.toString, {\n  Z_NO_FLUSH: $l,\n  Z_SYNC_FLUSH: Pl,\n  Z_FULL_FLUSH: ql,\n  Z_FINISH: Kl,\n  Z_OK: pn,\n  Z_STREAM_END: Yl,\n  Z_DEFAULT_COMPRESSION: Ql,\n  Z_DEFAULT_STRATEGY: Vl,\n  Z_DEFLATED: jl\n} = tn;\nfunction rn(e) {\n  this.options = kn.assign({\n    level: Ql,\n    method: jl,\n    chunkSize: 16384,\n    windowBits: 15,\n    memLevel: 8,\n    strategy: Vl\n  }, e || {});\n  let r = this.options;\n  r.raw && r.windowBits > 0 ? r.windowBits = -r.windowBits : r.gzip && r.windowBits > 0 && r.windowBits < 16 && (r.windowBits += 16), this.err = 0, this.msg = \"\", this.ended = !1, this.chunks = [], this.strm = new oo(), this.strm.avail_out = 0;\n  let t = qt.deflateInit2(\n    this.strm,\n    r.level,\n    r.method,\n    r.windowBits,\n    r.memLevel,\n    r.strategy\n  );\n  if (t !== pn)\n    throw new Error(bt[t]);\n  if (r.header && qt.deflateSetHeader(this.strm, r.header), r.dictionary) {\n    let i;\n    if (typeof r.dictionary == \"string\" ? i = Wt.string2buf(r.dictionary) : fo.call(r.dictionary) === \"[object ArrayBuffer]\" ? i = new Uint8Array(r.dictionary) : i = r.dictionary, t = qt.deflateSetDictionary(this.strm, i), t !== pn)\n      throw new Error(bt[t]);\n    this._dict_set = !0;\n  }\n}\nrn.prototype.push = function(e, r) {\n  const t = this.strm, i = this.options.chunkSize;\n  let f, n;\n  if (this.ended)\n    return !1;\n  for (r === ~~r ? n = r : n = r === !0 ? Kl : $l, typeof e == \"string\" ? t.input = Wt.string2buf(e) : fo.call(e) === \"[object ArrayBuffer]\" ? t.input = new Uint8Array(e) : t.input = e, t.next_in = 0, t.avail_in = t.input.length; ; ) {\n    if (t.avail_out === 0 && (t.output = new Uint8Array(i), t.next_out = 0, t.avail_out = i), (n === Pl || n === ql) && t.avail_out <= 6) {\n      this.onData(t.output.subarray(0, t.next_out)), t.avail_out = 0;\n      continue;\n    }\n    if (f = qt.deflate(t, n), f === Yl)\n      return t.next_out > 0 && this.onData(t.output.subarray(0, t.next_out)), f = qt.deflateEnd(this.strm), this.onEnd(f), this.ended = !0, f === pn;\n    if (t.avail_out === 0) {\n      this.onData(t.output);\n      continue;\n    }\n    if (n > 0 && t.next_out > 0) {\n      this.onData(t.output.subarray(0, t.next_out)), t.avail_out = 0;\n      continue;\n    }\n    if (t.avail_in === 0) break;\n  }\n  return !0;\n};\nrn.prototype.onData = function(e) {\n  this.chunks.push(e);\n};\nrn.prototype.onEnd = function(e) {\n  e === pn && (this.result = kn.flattenChunks(this.chunks)), this.chunks = [], this.err = e, this.msg = this.strm.msg;\n};\nfunction Hr(e, r) {\n  const t = new rn(r);\n  if (t.push(e, !0), t.err)\n    throw t.msg || bt[t.err];\n  return t.result;\n}\nfunction Xl(e, r) {\n  return r = r || {}, r.raw = !0, Hr(e, r);\n}\nfunction Jl(e, r) {\n  return r = r || {}, r.gzip = !0, Hr(e, r);\n}\nvar Wl = rn, Gl = Hr, e0 = Xl, t0 = Jl, n0 = {\n  Deflate: Wl,\n  deflate: Gl,\n  deflateRaw: e0,\n  gzip: t0\n};\nconst hn = 16209, r0 = 16191;\nvar i0 = function(r, t) {\n  let i, f, n, a, l, s, h, u, d, g, v, c, R, S, b, x, m, k, L, z, E, T, I, D;\n  const C = r.state;\n  i = r.next_in, I = r.input, f = i + (r.avail_in - 5), n = r.next_out, D = r.output, a = n - (t - r.avail_out), l = n + (r.avail_out - 257), s = C.dmax, h = C.wsize, u = C.whave, d = C.wnext, g = C.window, v = C.hold, c = C.bits, R = C.lencode, S = C.distcode, b = (1 << C.lenbits) - 1, x = (1 << C.distbits) - 1;\n  e:\n    do {\n      c < 15 && (v += I[i++] << c, c += 8, v += I[i++] << c, c += 8), m = R[v & b];\n      t:\n        for (; ; ) {\n          if (k = m >>> 24, v >>>= k, c -= k, k = m >>> 16 & 255, k === 0)\n            D[n++] = m & 65535;\n          else if (k & 16) {\n            L = m & 65535, k &= 15, k && (c < k && (v += I[i++] << c, c += 8), L += v & (1 << k) - 1, v >>>= k, c -= k), c < 15 && (v += I[i++] << c, c += 8, v += I[i++] << c, c += 8), m = S[v & x];\n            n:\n              for (; ; ) {\n                if (k = m >>> 24, v >>>= k, c -= k, k = m >>> 16 & 255, k & 16) {\n                  if (z = m & 65535, k &= 15, c < k && (v += I[i++] << c, c += 8, c < k && (v += I[i++] << c, c += 8)), z += v & (1 << k) - 1, z > s) {\n                    r.msg = \"invalid distance too far back\", C.mode = hn;\n                    break e;\n                  }\n                  if (v >>>= k, c -= k, k = n - a, z > k) {\n                    if (k = z - k, k > u && C.sane) {\n                      r.msg = \"invalid distance too far back\", C.mode = hn;\n                      break e;\n                    }\n                    if (E = 0, T = g, d === 0) {\n                      if (E += h - k, k < L) {\n                        L -= k;\n                        do\n                          D[n++] = g[E++];\n                        while (--k);\n                        E = n - z, T = D;\n                      }\n                    } else if (d < k) {\n                      if (E += h + d - k, k -= d, k < L) {\n                        L -= k;\n                        do\n                          D[n++] = g[E++];\n                        while (--k);\n                        if (E = 0, d < L) {\n                          k = d, L -= k;\n                          do\n                            D[n++] = g[E++];\n                          while (--k);\n                          E = n - z, T = D;\n                        }\n                      }\n                    } else if (E += d - k, k < L) {\n                      L -= k;\n                      do\n                        D[n++] = g[E++];\n                      while (--k);\n                      E = n - z, T = D;\n                    }\n                    for (; L > 2; )\n                      D[n++] = T[E++], D[n++] = T[E++], D[n++] = T[E++], L -= 3;\n                    L && (D[n++] = T[E++], L > 1 && (D[n++] = T[E++]));\n                  } else {\n                    E = n - z;\n                    do\n                      D[n++] = D[E++], D[n++] = D[E++], D[n++] = D[E++], L -= 3;\n                    while (L > 2);\n                    L && (D[n++] = D[E++], L > 1 && (D[n++] = D[E++]));\n                  }\n                } else if ((k & 64) === 0) {\n                  m = S[(m & 65535) + (v & (1 << k) - 1)];\n                  continue n;\n                } else {\n                  r.msg = \"invalid distance code\", C.mode = hn;\n                  break e;\n                }\n                break;\n              }\n          } else if ((k & 64) === 0) {\n            m = R[(m & 65535) + (v & (1 << k) - 1)];\n            continue t;\n          } else if (k & 32) {\n            C.mode = r0;\n            break e;\n          } else {\n            r.msg = \"invalid literal/length code\", C.mode = hn;\n            break e;\n          }\n          break;\n        }\n    } while (i < f && n < l);\n  L = c >> 3, i -= L, c -= L << 3, v &= (1 << c) - 1, r.next_in = i, r.next_out = n, r.avail_in = i < f ? 5 + (f - i) : 5 - (i - f), r.avail_out = n < l ? 257 + (l - n) : 257 - (n - l), C.hold = v, C.bits = c;\n};\nconst Dt = 15, Ki = 852, Yi = 592, Qi = 0, ur = 1, Vi = 2, a0 = new Uint16Array([\n  /* Length codes 257..285 base */\n  3,\n  4,\n  5,\n  6,\n  7,\n  8,\n  9,\n  10,\n  11,\n  13,\n  15,\n  17,\n  19,\n  23,\n  27,\n  31,\n  35,\n  43,\n  51,\n  59,\n  67,\n  83,\n  99,\n  115,\n  131,\n  163,\n  195,\n  227,\n  258,\n  0,\n  0\n]), o0 = new Uint8Array([\n  /* Length codes 257..285 extra */\n  16,\n  16,\n  16,\n  16,\n  16,\n  16,\n  16,\n  16,\n  17,\n  17,\n  17,\n  17,\n  18,\n  18,\n  18,\n  18,\n  19,\n  19,\n  19,\n  19,\n  20,\n  20,\n  20,\n  20,\n  21,\n  21,\n  21,\n  21,\n  16,\n  72,\n  78\n]), f0 = new Uint16Array([\n  /* Distance codes 0..29 base */\n  1,\n  2,\n  3,\n  4,\n  5,\n  7,\n  9,\n  13,\n  17,\n  25,\n  33,\n  49,\n  65,\n  97,\n  129,\n  193,\n  257,\n  385,\n  513,\n  769,\n  1025,\n  1537,\n  2049,\n  3073,\n  4097,\n  6145,\n  8193,\n  12289,\n  16385,\n  24577,\n  0,\n  0\n]), l0 = new Uint8Array([\n  /* Distance codes 0..29 extra */\n  16,\n  16,\n  16,\n  16,\n  17,\n  17,\n  18,\n  18,\n  19,\n  19,\n  20,\n  20,\n  21,\n  21,\n  22,\n  22,\n  23,\n  23,\n  24,\n  24,\n  25,\n  25,\n  26,\n  26,\n  27,\n  27,\n  28,\n  28,\n  29,\n  29,\n  64,\n  64\n]), s0 = (e, r, t, i, f, n, a, l) => {\n  const s = l.bits;\n  let h = 0, u = 0, d = 0, g = 0, v = 0, c = 0, R = 0, S = 0, b = 0, x = 0, m, k, L, z, E, T = null, I;\n  const D = new Uint16Array(Dt + 1), C = new Uint16Array(Dt + 1);\n  let O = null, N, U, X;\n  for (h = 0; h <= Dt; h++)\n    D[h] = 0;\n  for (u = 0; u < i; u++)\n    D[r[t + u]]++;\n  for (v = s, g = Dt; g >= 1 && D[g] === 0; g--)\n    ;\n  if (v > g && (v = g), g === 0)\n    return f[n++] = 1 << 24 | 64 << 16 | 0, f[n++] = 1 << 24 | 64 << 16 | 0, l.bits = 1, 0;\n  for (d = 1; d < g && D[d] === 0; d++)\n    ;\n  for (v < d && (v = d), S = 1, h = 1; h <= Dt; h++)\n    if (S <<= 1, S -= D[h], S < 0)\n      return -1;\n  if (S > 0 && (e === Qi || g !== 1))\n    return -1;\n  for (C[1] = 0, h = 1; h < Dt; h++)\n    C[h + 1] = C[h] + D[h];\n  for (u = 0; u < i; u++)\n    r[t + u] !== 0 && (a[C[r[t + u]]++] = u);\n  if (e === Qi ? (T = O = a, I = 20) : e === ur ? (T = a0, O = o0, I = 257) : (T = f0, O = l0, I = 0), x = 0, u = 0, h = d, E = n, c = v, R = 0, L = -1, b = 1 << v, z = b - 1, e === ur && b > Ki || e === Vi && b > Yi)\n    return 1;\n  for (; ; ) {\n    N = h - R, a[u] + 1 < I ? (U = 0, X = a[u]) : a[u] >= I ? (U = O[a[u] - I], X = T[a[u] - I]) : (U = 96, X = 0), m = 1 << h - R, k = 1 << c, d = k;\n    do\n      k -= m, f[E + (x >> R) + k] = N << 24 | U << 16 | X | 0;\n    while (k !== 0);\n    for (m = 1 << h - 1; x & m; )\n      m >>= 1;\n    if (m !== 0 ? (x &= m - 1, x += m) : x = 0, u++, --D[h] === 0) {\n      if (h === g)\n        break;\n      h = r[t + a[u]];\n    }\n    if (h > v && (x & z) !== L) {\n      for (R === 0 && (R = v), E += d, c = h - R, S = 1 << c; c + R < g && (S -= D[c + R], !(S <= 0)); )\n        c++, S <<= 1;\n      if (b += 1 << c, e === ur && b > Ki || e === Vi && b > Yi)\n        return 1;\n      L = x & z, f[L] = v << 24 | c << 16 | E - n | 0;\n    }\n  }\n  return x !== 0 && (f[E + x] = h - R << 24 | 64 << 16 | 0), l.bits = v, 0;\n};\nvar Kt = s0;\nconst h0 = 0, lo = 1, so = 2, {\n  Z_FINISH: ji,\n  Z_BLOCK: u0,\n  Z_TREES: un,\n  Z_OK: xt,\n  Z_STREAM_END: c0,\n  Z_NEED_DICT: d0,\n  Z_STREAM_ERROR: $e,\n  Z_DATA_ERROR: ho,\n  Z_MEM_ERROR: uo,\n  Z_BUF_ERROR: _0,\n  Z_DEFLATED: Xi\n} = tn, mn = 16180, Ji = 16181, Wi = 16182, Gi = 16183, ea = 16184, ta = 16185, na = 16186, ra = 16187, ia = 16188, aa = 16189, xn = 16190, et = 16191, cr = 16192, oa = 16193, dr = 16194, fa = 16195, la = 16196, sa = 16197, ha = 16198, cn = 16199, dn = 16200, ua = 16201, ca = 16202, da = 16203, _a = 16204, ga = 16205, _r = 16206, va = 16207, wa = 16208, _e = 16209, co = 16210, _o = 16211, g0 = 852, v0 = 592, w0 = 15, b0 = w0, ba = (e) => (e >>> 24 & 255) + (e >>> 8 & 65280) + ((e & 65280) << 8) + ((e & 255) << 24);\nfunction p0() {\n  this.strm = null, this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new Uint16Array(320), this.work = new Uint16Array(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;\n}\nconst mt = (e) => {\n  if (!e)\n    return 1;\n  const r = e.state;\n  return !r || r.strm !== e || r.mode < mn || r.mode > _o ? 1 : 0;\n}, go = (e) => {\n  if (mt(e))\n    return $e;\n  const r = e.state;\n  return e.total_in = e.total_out = r.total = 0, e.msg = \"\", r.wrap && (e.adler = r.wrap & 1), r.mode = mn, r.last = 0, r.havedict = 0, r.flags = -1, r.dmax = 32768, r.head = null, r.hold = 0, r.bits = 0, r.lencode = r.lendyn = new Int32Array(g0), r.distcode = r.distdyn = new Int32Array(v0), r.sane = 1, r.back = -1, xt;\n}, vo = (e) => {\n  if (mt(e))\n    return $e;\n  const r = e.state;\n  return r.wsize = 0, r.whave = 0, r.wnext = 0, go(e);\n}, wo = (e, r) => {\n  let t;\n  if (mt(e))\n    return $e;\n  const i = e.state;\n  return r < 0 ? (t = 0, r = -r) : (t = (r >> 4) + 5, r < 48 && (r &= 15)), r && (r < 8 || r > 15) ? $e : (i.window !== null && i.wbits !== r && (i.window = null), i.wrap = t, i.wbits = r, vo(e));\n}, bo = (e, r) => {\n  if (!e)\n    return $e;\n  const t = new p0();\n  e.state = t, t.strm = e, t.window = null, t.mode = mn;\n  const i = wo(e, r);\n  return i !== xt && (e.state = null), i;\n}, x0 = (e) => bo(e, b0);\nlet pa = !0, gr, vr;\nconst E0 = (e) => {\n  if (pa) {\n    gr = new Int32Array(512), vr = new Int32Array(32);\n    let r = 0;\n    for (; r < 144; )\n      e.lens[r++] = 8;\n    for (; r < 256; )\n      e.lens[r++] = 9;\n    for (; r < 280; )\n      e.lens[r++] = 7;\n    for (; r < 288; )\n      e.lens[r++] = 8;\n    for (Kt(lo, e.lens, 0, 288, gr, 0, e.work, { bits: 9 }), r = 0; r < 32; )\n      e.lens[r++] = 5;\n    Kt(so, e.lens, 0, 32, vr, 0, e.work, { bits: 5 }), pa = !1;\n  }\n  e.lencode = gr, e.lenbits = 9, e.distcode = vr, e.distbits = 5;\n}, po = (e, r, t, i) => {\n  let f;\n  const n = e.state;\n  return n.window === null && (n.wsize = 1 << n.wbits, n.wnext = 0, n.whave = 0, n.window = new Uint8Array(n.wsize)), i >= n.wsize ? (n.window.set(r.subarray(t - n.wsize, t), 0), n.wnext = 0, n.whave = n.wsize) : (f = n.wsize - n.wnext, f > i && (f = i), n.window.set(r.subarray(t - i, t - i + f), n.wnext), i -= f, i ? (n.window.set(r.subarray(t - i, t), 0), n.wnext = i, n.whave = n.wsize) : (n.wnext += f, n.wnext === n.wsize && (n.wnext = 0), n.whave < n.wsize && (n.whave += f))), 0;\n}, k0 = (e, r) => {\n  let t, i, f, n, a, l, s, h, u, d, g, v, c, R, S = 0, b, x, m, k, L, z, E, T;\n  const I = new Uint8Array(4);\n  let D, C;\n  const O = (\n    /* permutation of code lengths */\n    new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15])\n  );\n  if (mt(e) || !e.output || !e.input && e.avail_in !== 0)\n    return $e;\n  t = e.state, t.mode === et && (t.mode = cr), a = e.next_out, f = e.output, s = e.avail_out, n = e.next_in, i = e.input, l = e.avail_in, h = t.hold, u = t.bits, d = l, g = s, T = xt;\n  e:\n    for (; ; )\n      switch (t.mode) {\n        case mn:\n          if (t.wrap === 0) {\n            t.mode = cr;\n            break;\n          }\n          for (; u < 16; ) {\n            if (l === 0)\n              break e;\n            l--, h += i[n++] << u, u += 8;\n          }\n          if (t.wrap & 2 && h === 35615) {\n            t.wbits === 0 && (t.wbits = 15), t.check = 0, I[0] = h & 255, I[1] = h >>> 8 & 255, t.check = me(t.check, I, 2, 0), h = 0, u = 0, t.mode = Ji;\n            break;\n          }\n          if (t.head && (t.head.done = !1), !(t.wrap & 1) || /* check if zlib header allowed */\n          (((h & 255) << 8) + (h >> 8)) % 31) {\n            e.msg = \"incorrect header check\", t.mode = _e;\n            break;\n          }\n          if ((h & 15) !== Xi) {\n            e.msg = \"unknown compression method\", t.mode = _e;\n            break;\n          }\n          if (h >>>= 4, u -= 4, E = (h & 15) + 8, t.wbits === 0 && (t.wbits = E), E > 15 || E > t.wbits) {\n            e.msg = \"invalid window size\", t.mode = _e;\n            break;\n          }\n          t.dmax = 1 << t.wbits, t.flags = 0, e.adler = t.check = 1, t.mode = h & 512 ? aa : et, h = 0, u = 0;\n          break;\n        case Ji:\n          for (; u < 16; ) {\n            if (l === 0)\n              break e;\n            l--, h += i[n++] << u, u += 8;\n          }\n          if (t.flags = h, (t.flags & 255) !== Xi) {\n            e.msg = \"unknown compression method\", t.mode = _e;\n            break;\n          }\n          if (t.flags & 57344) {\n            e.msg = \"unknown header flags set\", t.mode = _e;\n            break;\n          }\n          t.head && (t.head.text = h >> 8 & 1), t.flags & 512 && t.wrap & 4 && (I[0] = h & 255, I[1] = h >>> 8 & 255, t.check = me(t.check, I, 2, 0)), h = 0, u = 0, t.mode = Wi;\n        /* falls through */\n        case Wi:\n          for (; u < 32; ) {\n            if (l === 0)\n              break e;\n            l--, h += i[n++] << u, u += 8;\n          }\n          t.head && (t.head.time = h), t.flags & 512 && t.wrap & 4 && (I[0] = h & 255, I[1] = h >>> 8 & 255, I[2] = h >>> 16 & 255, I[3] = h >>> 24 & 255, t.check = me(t.check, I, 4, 0)), h = 0, u = 0, t.mode = Gi;\n        /* falls through */\n        case Gi:\n          for (; u < 16; ) {\n            if (l === 0)\n              break e;\n            l--, h += i[n++] << u, u += 8;\n          }\n          t.head && (t.head.xflags = h & 255, t.head.os = h >> 8), t.flags & 512 && t.wrap & 4 && (I[0] = h & 255, I[1] = h >>> 8 & 255, t.check = me(t.check, I, 2, 0)), h = 0, u = 0, t.mode = ea;\n        /* falls through */\n        case ea:\n          if (t.flags & 1024) {\n            for (; u < 16; ) {\n              if (l === 0)\n                break e;\n              l--, h += i[n++] << u, u += 8;\n            }\n            t.length = h, t.head && (t.head.extra_len = h), t.flags & 512 && t.wrap & 4 && (I[0] = h & 255, I[1] = h >>> 8 & 255, t.check = me(t.check, I, 2, 0)), h = 0, u = 0;\n          } else t.head && (t.head.extra = null);\n          t.mode = ta;\n        /* falls through */\n        case ta:\n          if (t.flags & 1024 && (v = t.length, v > l && (v = l), v && (t.head && (E = t.head.extra_len - t.length, t.head.extra || (t.head.extra = new Uint8Array(t.head.extra_len)), t.head.extra.set(\n            i.subarray(\n              n,\n              // extra field is limited to 65536 bytes\n              // - no need for additional size check\n              n + v\n            ),\n            /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/\n            E\n          )), t.flags & 512 && t.wrap & 4 && (t.check = me(t.check, i, v, n)), l -= v, n += v, t.length -= v), t.length))\n            break e;\n          t.length = 0, t.mode = na;\n        /* falls through */\n        case na:\n          if (t.flags & 2048) {\n            if (l === 0)\n              break e;\n            v = 0;\n            do\n              E = i[n + v++], t.head && E && t.length < 65536 && (t.head.name += String.fromCharCode(E));\n            while (E && v < l);\n            if (t.flags & 512 && t.wrap & 4 && (t.check = me(t.check, i, v, n)), l -= v, n += v, E)\n              break e;\n          } else t.head && (t.head.name = null);\n          t.length = 0, t.mode = ra;\n        /* falls through */\n        case ra:\n          if (t.flags & 4096) {\n            if (l === 0)\n              break e;\n            v = 0;\n            do\n              E = i[n + v++], t.head && E && t.length < 65536 && (t.head.comment += String.fromCharCode(E));\n            while (E && v < l);\n            if (t.flags & 512 && t.wrap & 4 && (t.check = me(t.check, i, v, n)), l -= v, n += v, E)\n              break e;\n          } else t.head && (t.head.comment = null);\n          t.mode = ia;\n        /* falls through */\n        case ia:\n          if (t.flags & 512) {\n            for (; u < 16; ) {\n              if (l === 0)\n                break e;\n              l--, h += i[n++] << u, u += 8;\n            }\n            if (t.wrap & 4 && h !== (t.check & 65535)) {\n              e.msg = \"header crc mismatch\", t.mode = _e;\n              break;\n            }\n            h = 0, u = 0;\n          }\n          t.head && (t.head.hcrc = t.flags >> 9 & 1, t.head.done = !0), e.adler = t.check = 0, t.mode = et;\n          break;\n        case aa:\n          for (; u < 32; ) {\n            if (l === 0)\n              break e;\n            l--, h += i[n++] << u, u += 8;\n          }\n          e.adler = t.check = ba(h), h = 0, u = 0, t.mode = xn;\n        /* falls through */\n        case xn:\n          if (t.havedict === 0)\n            return e.next_out = a, e.avail_out = s, e.next_in = n, e.avail_in = l, t.hold = h, t.bits = u, d0;\n          e.adler = t.check = 1, t.mode = et;\n        /* falls through */\n        case et:\n          if (r === u0 || r === un)\n            break e;\n        /* falls through */\n        case cr:\n          if (t.last) {\n            h >>>= u & 7, u -= u & 7, t.mode = _r;\n            break;\n          }\n          for (; u < 3; ) {\n            if (l === 0)\n              break e;\n            l--, h += i[n++] << u, u += 8;\n          }\n          switch (t.last = h & 1, h >>>= 1, u -= 1, h & 3) {\n            case 0:\n              t.mode = oa;\n              break;\n            case 1:\n              if (E0(t), t.mode = cn, r === un) {\n                h >>>= 2, u -= 2;\n                break e;\n              }\n              break;\n            case 2:\n              t.mode = la;\n              break;\n            case 3:\n              e.msg = \"invalid block type\", t.mode = _e;\n          }\n          h >>>= 2, u -= 2;\n          break;\n        case oa:\n          for (h >>>= u & 7, u -= u & 7; u < 32; ) {\n            if (l === 0)\n              break e;\n            l--, h += i[n++] << u, u += 8;\n          }\n          if ((h & 65535) !== (h >>> 16 ^ 65535)) {\n            e.msg = \"invalid stored block lengths\", t.mode = _e;\n            break;\n          }\n          if (t.length = h & 65535, h = 0, u = 0, t.mode = dr, r === un)\n            break e;\n        /* falls through */\n        case dr:\n          t.mode = fa;\n        /* falls through */\n        case fa:\n          if (v = t.length, v) {\n            if (v > l && (v = l), v > s && (v = s), v === 0)\n              break e;\n            f.set(i.subarray(n, n + v), a), l -= v, n += v, s -= v, a += v, t.length -= v;\n            break;\n          }\n          t.mode = et;\n          break;\n        case la:\n          for (; u < 14; ) {\n            if (l === 0)\n              break e;\n            l--, h += i[n++] << u, u += 8;\n          }\n          if (t.nlen = (h & 31) + 257, h >>>= 5, u -= 5, t.ndist = (h & 31) + 1, h >>>= 5, u -= 5, t.ncode = (h & 15) + 4, h >>>= 4, u -= 4, t.nlen > 286 || t.ndist > 30) {\n            e.msg = \"too many length or distance symbols\", t.mode = _e;\n            break;\n          }\n          t.have = 0, t.mode = sa;\n        /* falls through */\n        case sa:\n          for (; t.have < t.ncode; ) {\n            for (; u < 3; ) {\n              if (l === 0)\n                break e;\n              l--, h += i[n++] << u, u += 8;\n            }\n            t.lens[O[t.have++]] = h & 7, h >>>= 3, u -= 3;\n          }\n          for (; t.have < 19; )\n            t.lens[O[t.have++]] = 0;\n          if (t.lencode = t.lendyn, t.lenbits = 7, D = { bits: t.lenbits }, T = Kt(h0, t.lens, 0, 19, t.lencode, 0, t.work, D), t.lenbits = D.bits, T) {\n            e.msg = \"invalid code lengths set\", t.mode = _e;\n            break;\n          }\n          t.have = 0, t.mode = ha;\n        /* falls through */\n        case ha:\n          for (; t.have < t.nlen + t.ndist; ) {\n            for (; S = t.lencode[h & (1 << t.lenbits) - 1], b = S >>> 24, x = S >>> 16 & 255, m = S & 65535, !(b <= u); ) {\n              if (l === 0)\n                break e;\n              l--, h += i[n++] << u, u += 8;\n            }\n            if (m < 16)\n              h >>>= b, u -= b, t.lens[t.have++] = m;\n            else {\n              if (m === 16) {\n                for (C = b + 2; u < C; ) {\n                  if (l === 0)\n                    break e;\n                  l--, h += i[n++] << u, u += 8;\n                }\n                if (h >>>= b, u -= b, t.have === 0) {\n                  e.msg = \"invalid bit length repeat\", t.mode = _e;\n                  break;\n                }\n                E = t.lens[t.have - 1], v = 3 + (h & 3), h >>>= 2, u -= 2;\n              } else if (m === 17) {\n                for (C = b + 3; u < C; ) {\n                  if (l === 0)\n                    break e;\n                  l--, h += i[n++] << u, u += 8;\n                }\n                h >>>= b, u -= b, E = 0, v = 3 + (h & 7), h >>>= 3, u -= 3;\n              } else {\n                for (C = b + 7; u < C; ) {\n                  if (l === 0)\n                    break e;\n                  l--, h += i[n++] << u, u += 8;\n                }\n                h >>>= b, u -= b, E = 0, v = 11 + (h & 127), h >>>= 7, u -= 7;\n              }\n              if (t.have + v > t.nlen + t.ndist) {\n                e.msg = \"invalid bit length repeat\", t.mode = _e;\n                break;\n              }\n              for (; v--; )\n                t.lens[t.have++] = E;\n            }\n          }\n          if (t.mode === _e)\n            break;\n          if (t.lens[256] === 0) {\n            e.msg = \"invalid code -- missing end-of-block\", t.mode = _e;\n            break;\n          }\n          if (t.lenbits = 9, D = { bits: t.lenbits }, T = Kt(lo, t.lens, 0, t.nlen, t.lencode, 0, t.work, D), t.lenbits = D.bits, T) {\n            e.msg = \"invalid literal/lengths set\", t.mode = _e;\n            break;\n          }\n          if (t.distbits = 6, t.distcode = t.distdyn, D = { bits: t.distbits }, T = Kt(so, t.lens, t.nlen, t.ndist, t.distcode, 0, t.work, D), t.distbits = D.bits, T) {\n            e.msg = \"invalid distances set\", t.mode = _e;\n            break;\n          }\n          if (t.mode = cn, r === un)\n            break e;\n        /* falls through */\n        case cn:\n          t.mode = dn;\n        /* falls through */\n        case dn:\n          if (l >= 6 && s >= 258) {\n            e.next_out = a, e.avail_out = s, e.next_in = n, e.avail_in = l, t.hold = h, t.bits = u, i0(e, g), a = e.next_out, f = e.output, s = e.avail_out, n = e.next_in, i = e.input, l = e.avail_in, h = t.hold, u = t.bits, t.mode === et && (t.back = -1);\n            break;\n          }\n          for (t.back = 0; S = t.lencode[h & (1 << t.lenbits) - 1], b = S >>> 24, x = S >>> 16 & 255, m = S & 65535, !(b <= u); ) {\n            if (l === 0)\n              break e;\n            l--, h += i[n++] << u, u += 8;\n          }\n          if (x && (x & 240) === 0) {\n            for (k = b, L = x, z = m; S = t.lencode[z + ((h & (1 << k + L) - 1) >> k)], b = S >>> 24, x = S >>> 16 & 255, m = S & 65535, !(k + b <= u); ) {\n              if (l === 0)\n                break e;\n              l--, h += i[n++] << u, u += 8;\n            }\n            h >>>= k, u -= k, t.back += k;\n          }\n          if (h >>>= b, u -= b, t.back += b, t.length = m, x === 0) {\n            t.mode = ga;\n            break;\n          }\n          if (x & 32) {\n            t.back = -1, t.mode = et;\n            break;\n          }\n          if (x & 64) {\n            e.msg = \"invalid literal/length code\", t.mode = _e;\n            break;\n          }\n          t.extra = x & 15, t.mode = ua;\n        /* falls through */\n        case ua:\n          if (t.extra) {\n            for (C = t.extra; u < C; ) {\n              if (l === 0)\n                break e;\n              l--, h += i[n++] << u, u += 8;\n            }\n            t.length += h & (1 << t.extra) - 1, h >>>= t.extra, u -= t.extra, t.back += t.extra;\n          }\n          t.was = t.length, t.mode = ca;\n        /* falls through */\n        case ca:\n          for (; S = t.distcode[h & (1 << t.distbits) - 1], b = S >>> 24, x = S >>> 16 & 255, m = S & 65535, !(b <= u); ) {\n            if (l === 0)\n              break e;\n            l--, h += i[n++] << u, u += 8;\n          }\n          if ((x & 240) === 0) {\n            for (k = b, L = x, z = m; S = t.distcode[z + ((h & (1 << k + L) - 1) >> k)], b = S >>> 24, x = S >>> 16 & 255, m = S & 65535, !(k + b <= u); ) {\n              if (l === 0)\n                break e;\n              l--, h += i[n++] << u, u += 8;\n            }\n            h >>>= k, u -= k, t.back += k;\n          }\n          if (h >>>= b, u -= b, t.back += b, x & 64) {\n            e.msg = \"invalid distance code\", t.mode = _e;\n            break;\n          }\n          t.offset = m, t.extra = x & 15, t.mode = da;\n        /* falls through */\n        case da:\n          if (t.extra) {\n            for (C = t.extra; u < C; ) {\n              if (l === 0)\n                break e;\n              l--, h += i[n++] << u, u += 8;\n            }\n            t.offset += h & (1 << t.extra) - 1, h >>>= t.extra, u -= t.extra, t.back += t.extra;\n          }\n          if (t.offset > t.dmax) {\n            e.msg = \"invalid distance too far back\", t.mode = _e;\n            break;\n          }\n          t.mode = _a;\n        /* falls through */\n        case _a:\n          if (s === 0)\n            break e;\n          if (v = g - s, t.offset > v) {\n            if (v = t.offset - v, v > t.whave && t.sane) {\n              e.msg = \"invalid distance too far back\", t.mode = _e;\n              break;\n            }\n            v > t.wnext ? (v -= t.wnext, c = t.wsize - v) : c = t.wnext - v, v > t.length && (v = t.length), R = t.window;\n          } else\n            R = f, c = a - t.offset, v = t.length;\n          v > s && (v = s), s -= v, t.length -= v;\n          do\n            f[a++] = R[c++];\n          while (--v);\n          t.length === 0 && (t.mode = dn);\n          break;\n        case ga:\n          if (s === 0)\n            break e;\n          f[a++] = t.length, s--, t.mode = dn;\n          break;\n        case _r:\n          if (t.wrap) {\n            for (; u < 32; ) {\n              if (l === 0)\n                break e;\n              l--, h |= i[n++] << u, u += 8;\n            }\n            if (g -= s, e.total_out += g, t.total += g, t.wrap & 4 && g && (e.adler = t.check = /*UPDATE_CHECK(state.check, put - _out, _out);*/\n            t.flags ? me(t.check, f, g, a - g) : Xt(t.check, f, g, a - g)), g = s, t.wrap & 4 && (t.flags ? h : ba(h)) !== t.check) {\n              e.msg = \"incorrect data check\", t.mode = _e;\n              break;\n            }\n            h = 0, u = 0;\n          }\n          t.mode = va;\n        /* falls through */\n        case va:\n          if (t.wrap && t.flags) {\n            for (; u < 32; ) {\n              if (l === 0)\n                break e;\n              l--, h += i[n++] << u, u += 8;\n            }\n            if (t.wrap & 4 && h !== (t.total & 4294967295)) {\n              e.msg = \"incorrect length check\", t.mode = _e;\n              break;\n            }\n            h = 0, u = 0;\n          }\n          t.mode = wa;\n        /* falls through */\n        case wa:\n          T = c0;\n          break e;\n        case _e:\n          T = ho;\n          break e;\n        case co:\n          return uo;\n        case _o:\n        /* falls through */\n        default:\n          return $e;\n      }\n  return e.next_out = a, e.avail_out = s, e.next_in = n, e.avail_in = l, t.hold = h, t.bits = u, (t.wsize || g !== e.avail_out && t.mode < _e && (t.mode < _r || r !== ji)) && po(e, e.output, e.next_out, g - e.avail_out), d -= e.avail_in, g -= e.avail_out, e.total_in += d, e.total_out += g, t.total += g, t.wrap & 4 && g && (e.adler = t.check = /*UPDATE_CHECK(state.check, strm.next_out - _out, _out);*/\n  t.flags ? me(t.check, f, g, e.next_out - g) : Xt(t.check, f, g, e.next_out - g)), e.data_type = t.bits + (t.last ? 64 : 0) + (t.mode === et ? 128 : 0) + (t.mode === cn || t.mode === dr ? 256 : 0), (d === 0 && g === 0 || r === ji) && T === xt && (T = _0), T;\n}, m0 = (e) => {\n  if (mt(e))\n    return $e;\n  let r = e.state;\n  return r.window && (r.window = null), e.state = null, xt;\n}, y0 = (e, r) => {\n  if (mt(e))\n    return $e;\n  const t = e.state;\n  return (t.wrap & 2) === 0 ? $e : (t.head = r, r.done = !1, xt);\n}, A0 = (e, r) => {\n  const t = r.length;\n  let i, f, n;\n  return mt(e) || (i = e.state, i.wrap !== 0 && i.mode !== xn) ? $e : i.mode === xn && (f = 1, f = Xt(f, r, t, 0), f !== i.check) ? ho : (n = po(e, r, t, t), n ? (i.mode = co, uo) : (i.havedict = 1, xt));\n};\nvar S0 = vo, R0 = wo, T0 = go, z0 = x0, C0 = bo, I0 = k0, D0 = m0, L0 = y0, B0 = A0, M0 = \"pako inflate (from Nodeca project)\", nt = {\n  inflateReset: S0,\n  inflateReset2: R0,\n  inflateResetKeep: T0,\n  inflateInit: z0,\n  inflateInit2: C0,\n  inflate: I0,\n  inflateEnd: D0,\n  inflateGetHeader: L0,\n  inflateSetDictionary: B0,\n  inflateInfo: M0\n};\nfunction N0() {\n  this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = \"\", this.comment = \"\", this.hcrc = 0, this.done = !1;\n}\nvar Z0 = N0;\nconst xo = Object.prototype.toString, {\n  Z_NO_FLUSH: O0,\n  Z_FINISH: H0,\n  Z_OK: Gt,\n  Z_STREAM_END: wr,\n  Z_NEED_DICT: br,\n  Z_STREAM_ERROR: U0,\n  Z_DATA_ERROR: xa,\n  Z_MEM_ERROR: F0\n} = tn;\nfunction an(e) {\n  this.options = kn.assign({\n    chunkSize: 1024 * 64,\n    windowBits: 15,\n    to: \"\"\n  }, e || {});\n  const r = this.options;\n  r.raw && r.windowBits >= 0 && r.windowBits < 16 && (r.windowBits = -r.windowBits, r.windowBits === 0 && (r.windowBits = -15)), r.windowBits >= 0 && r.windowBits < 16 && !(e && e.windowBits) && (r.windowBits += 32), r.windowBits > 15 && r.windowBits < 48 && (r.windowBits & 15) === 0 && (r.windowBits |= 15), this.err = 0, this.msg = \"\", this.ended = !1, this.chunks = [], this.strm = new oo(), this.strm.avail_out = 0;\n  let t = nt.inflateInit2(\n    this.strm,\n    r.windowBits\n  );\n  if (t !== Gt)\n    throw new Error(bt[t]);\n  if (this.header = new Z0(), nt.inflateGetHeader(this.strm, this.header), r.dictionary && (typeof r.dictionary == \"string\" ? r.dictionary = Wt.string2buf(r.dictionary) : xo.call(r.dictionary) === \"[object ArrayBuffer]\" && (r.dictionary = new Uint8Array(r.dictionary)), r.raw && (t = nt.inflateSetDictionary(this.strm, r.dictionary), t !== Gt)))\n    throw new Error(bt[t]);\n}\nan.prototype.push = function(e, r) {\n  const t = this.strm, i = this.options.chunkSize, f = this.options.dictionary;\n  let n, a, l;\n  if (this.ended) return !1;\n  for (r === ~~r ? a = r : a = r === !0 ? H0 : O0, xo.call(e) === \"[object ArrayBuffer]\" ? t.input = new Uint8Array(e) : t.input = e, t.next_in = 0, t.avail_in = t.input.length; ; ) {\n    for (t.avail_out === 0 && (t.output = new Uint8Array(i), t.next_out = 0, t.avail_out = i), n = nt.inflate(t, a), n === br && f && (n = nt.inflateSetDictionary(t, f), n === Gt ? n = nt.inflate(t, a) : n === xa && (n = br)); t.avail_in > 0 && n === wr && t.state.wrap > 0 && e[t.next_in] !== 0; )\n      nt.inflateReset(t), n = nt.inflate(t, a);\n    switch (n) {\n      case U0:\n      case xa:\n      case br:\n      case F0:\n        return this.onEnd(n), this.ended = !0, !1;\n    }\n    if (l = t.avail_out, t.next_out && (t.avail_out === 0 || n === wr))\n      if (this.options.to === \"string\") {\n        let s = Wt.utf8border(t.output, t.next_out), h = t.next_out - s, u = Wt.buf2string(t.output, s);\n        t.next_out = h, t.avail_out = i - h, h && t.output.set(t.output.subarray(s, s + h), 0), this.onData(u);\n      } else\n        this.onData(t.output.length === t.next_out ? t.output : t.output.subarray(0, t.next_out));\n    if (!(n === Gt && l === 0)) {\n      if (n === wr)\n        return n = nt.inflateEnd(this.strm), this.onEnd(n), this.ended = !0, !0;\n      if (t.avail_in === 0) break;\n    }\n  }\n  return !0;\n};\nan.prototype.onData = function(e) {\n  this.chunks.push(e);\n};\nan.prototype.onEnd = function(e) {\n  e === Gt && (this.options.to === \"string\" ? this.result = this.chunks.join(\"\") : this.result = kn.flattenChunks(this.chunks)), this.chunks = [], this.err = e, this.msg = this.strm.msg;\n};\nfunction Ur(e, r) {\n  const t = new an(r);\n  if (t.push(e), t.err) throw t.msg || bt[t.err];\n  return t.result;\n}\nfunction $0(e, r) {\n  return r = r || {}, r.raw = !0, Ur(e, r);\n}\nvar P0 = an, q0 = Ur, K0 = $0, Y0 = Ur, Q0 = {\n  Inflate: P0,\n  inflate: q0,\n  inflateRaw: K0,\n  ungzip: Y0\n};\nconst { Deflate: V0, deflate: j0, deflateRaw: X0, gzip: J0 } = n0, { Inflate: W0, inflate: G0, inflateRaw: e1, ungzip: t1 } = Q0;\nvar n1 = V0, r1 = j0, i1 = X0, a1 = J0, o1 = W0, f1 = G0, l1 = e1, s1 = t1, h1 = tn, Eo = {\n  Deflate: n1,\n  deflate: r1,\n  deflateRaw: i1,\n  gzip: a1,\n  Inflate: o1,\n  inflate: f1,\n  inflateRaw: l1,\n  ungzip: s1,\n  constants: h1\n};\nfunction zr(e) {\n  const r = e.match(/.{1,2}/g) ?? [];\n  return Uint8Array.from(r.map((t) => parseInt(t, 16)));\n}\nfunction u1(e) {\n  const r = atob(e), t = r.length, i = new Uint8Array(t);\n  for (let f = 0; f < t; f++)\n    i[f] = r.charCodeAt(f);\n  return i;\n}\nfunction Ea(e) {\n  if (e < 0 || e > 1295 || !Number.isInteger(e))\n    throw new Error(\"Out of range\");\n  return e.toString(36).toUpperCase().padStart(2, \"0\");\n}\nasync function c1(e) {\n  const r = new FileReader();\n  return new Promise((t, i) => {\n    r.onload = (f) => {\n      var a;\n      const n = (a = f.target) == null ? void 0 : a.result;\n      n instanceof ArrayBuffer ? t(new Uint8Array(n)) : i(new Error(\"FileReader result is not an ArrayBuffer\"));\n    }, r.readAsArrayBuffer(e);\n  });\n}\nfunction ka(e) {\n  const r = e.reduce((f, n) => f + n.length, 0), t = new Uint8Array(r);\n  let i = 0;\n  for (const f of e)\n    t.set(f, i), i += f.length;\n  return t;\n}\nfunction Cr(e) {\n  return e in Ma;\n}\nfunction ma(e) {\n  return e >= 1 && e <= 1295;\n}\nfunction d1(e) {\n  const r = {\n    minVersion: e.minVersion ?? 5,\n    maxVersion: e.maxVersion ?? 40,\n    minSplit: e.minSplit ?? 1,\n    maxSplit: e.maxSplit ?? 1295,\n    encoding: e.encoding ?? \"Z\"\n  };\n  if (r.minVersion > r.maxVersion || !Cr(r.minVersion) || !Cr(r.maxVersion))\n    throw new Error(\"min/max version out of range\");\n  if (!ma(r.minSplit) || !ma(r.maxSplit) || r.minSplit > r.maxSplit)\n    throw new Error(\"min/max split out of range\");\n  return r;\n}\nfunction ya(e) {\n  try {\n    return new Uint8Array([112, 115, 98, 116, 255]).every((r, t) => r === e[t]);\n  } catch {\n    return !1;\n  }\n}\nfunction _1(e) {\n  e = [...e];\n  for (let r = e.length - 1; r > 0; r--) {\n    const t = Math.floor(Math.random() * (r + 1)), i = e[r];\n    e[r] = e[t], e[t] = i;\n  }\n  return e;\n}\nfunction g1(e) {\n  if (!Cr(e))\n    throw new Error(\"Invalid version\");\n  return Ma[e][\"L\"][2];\n}\nfunction v1(e, r) {\n  if (r = r ?? \"Z\", r === \"H\")\n    return {\n      encoding: r,\n      encoded: e.reduce((t, i) => t + i.toString(16).padStart(2, \"0\"), \"\").toUpperCase()\n    };\n  if (r === \"Z\") {\n    const t = Eo.deflate(e, { windowBits: -10 });\n    t.length >= e.length ? r = \"2\" : (r = \"Z\", e = t);\n  }\n  return {\n    encoding: r,\n    // base32 without padding\n    encoded: Oa.encode(e).replace(/=*$/, \"\")\n  };\n}\nfunction w1(e, r) {\n  if (r === \"H\")\n    return ka(e.map((i) => zr(i)));\n  const t = ka(\n    e.map((i) => {\n      const f = (8 - i.length % 8) % 8;\n      return Oa.decode(i + \"=\".repeat(f));\n    })\n  );\n  return r === \"Z\" ? Eo.inflate(t, { windowBits: -10 }) : t;\n}\nasync function x1(e, r, t = {}) {\n  if (typeof window > \"u\")\n    throw new Error(\"renderQRImage is only available in a web browser environment.\");\n  const i = t.mode ?? \"animated\";\n  let f = 4;\n  if (typeof t.margin == \"number\" && t.margin >= 0)\n    f = t.margin;\n  else if (typeof t.margin == \"string\" && /^\\d+(\\.\\d+)?%$/.test(t.margin)) {\n    const h = Number(t.margin.slice(0, -1));\n    f = lf[r] * h / 100;\n  } else if (t.margin !== void 0)\n    throw new Error(\n      'Invalid margin value. Expected a non-negative number or percentage string like \"10%\". Got: ' + t.margin\n    );\n  f = Math.round(f);\n  const n = t.scale ?? 4;\n  if (n < 1)\n    throw new Error(\"scale cannot be less than 1\");\n  let a = 0, l = 0;\n  const s = [];\n  for (let h = 0; h < e.length; h++) {\n    const u = e[h], d = await qo.toDataURL([{ data: u, mode: \"alphanumeric\" }], {\n      errorCorrectionLevel: \"L\",\n      version: r,\n      margin: f,\n      scale: n\n    }), g = new Image();\n    if (g.src = d, await g.decode(), h === 0)\n      a = g.width, l = g.height;\n    else if (g.width !== a)\n      throw new Error(\"QR codes must all be the same size\");\n    s.push(g);\n  }\n  if (i === \"stacked\") {\n    const h = a / 1.5, u = l * e.length + h * (e.length - 1), d = document.createElement(\"canvas\"), g = d.getContext(\"2d\");\n    if (!g)\n      throw new Error(\"Could not get 2d context for canvas element.\");\n    d.width = a, d.height = u, g.fillStyle = \"#fff\", g.fillRect(0, 0, a, u);\n    for (let c = 0; c < s.length; c++) {\n      const R = c * (l + h);\n      if (g.drawImage(s[c], 0, R), c < s.length - 1) {\n        const S = R + l + h / 2, b = a / 6, x = b * 2, m = a / 2;\n        g.save(), g.globalAlpha = 0.05, g.beginPath(), g.moveTo(m, S + b / 2), g.lineTo(m + x / 2, S - b / 2), g.lineTo(m - x / 2, S - b / 2), g.closePath(), g.fillStyle = \"#000\", g.fill(), g.restore();\n      }\n    }\n    const v = g.getImageData(0, 0, a, u).data;\n    return Li.encode([v.buffer], a, u, 0);\n  } else {\n    const h = e.length > 1 ? 2 * n : 0, u = [];\n    for (let d = 0; d < s.length; d++) {\n      d === 0 && (l += h);\n      const g = document.createElement(\"canvas\"), v = g.getContext(\"2d\");\n      if (!v)\n        throw new Error(\"Could not get 2d context for canvas element.\");\n      const c = s[d];\n      if (g.width = c.width, g.height = c.height + h, v.drawImage(c, 0, 0), h > 0) {\n        v.fillStyle = \"#fff\", v.fillRect(0, c.height, g.width, h);\n        const S = f * n, b = h / 2, x = (g.width - 2 * S) / e.length;\n        v.fillStyle = \"#ccc\", v.fillRect(S, c.height, g.width - 2 * S, b), v.fillStyle = \"#000\", v.fillRect(S + x * d, c.height, x, b);\n      }\n      const R = v.getImageData(0, 0, a, g.height).data;\n      u.push(R.buffer);\n    }\n    return Li.encode(\n      t.randomizeOrder ? _1(u) : u,\n      a,\n      l,\n      0,\n      e.map(() => t.frameDelay ?? 250)\n    );\n  }\n}\nfunction E1(e) {\n  const r = new Set(e.map((h) => h.slice(0, 6)));\n  if (r.size !== 1)\n    throw new Error(\"conflicting/variable filetype/encodings/sizes\");\n  const t = [...r][0];\n  if (t.slice(0, 2) !== \"B$\")\n    throw new Error(\"fixed header not found, expected B$\");\n  if (!of.has(t[2]))\n    throw new Error(`bad encoding: ${t[2]}`);\n  const i = t[2], f = t[3];\n  if (!/^[A-Z]$/.test(f))\n    throw new Error(\"fileType must be a single uppercase letter\");\n  const n = parseInt(t.slice(4, 6), 36);\n  if (n < 1)\n    throw new Error(\"zero parts?\");\n  const a = /* @__PURE__ */ new Map();\n  for (const h of e) {\n    const u = parseInt(h.slice(6, 8), 36);\n    if (u >= n)\n      throw new Error(`got part ${u} but only expecting ${n}`);\n    if (a.has(u) && a.get(u) !== h.slice(8))\n      throw new Error(`Duplicate part 0x${u.toString(16)} has wrong content`);\n    a.set(u, h.slice(8));\n  }\n  const l = [];\n  for (let h = 0; h < n; h++) {\n    const u = a.get(h);\n    if (!u)\n      throw new Error(`Part ${h} is missing`);\n    l.push(u);\n  }\n  const s = w1(l, i);\n  return { fileType: f, encoding: i, raw: s };\n}\nfunction b1(e, r, t) {\n  const i = ff[t], f = g1(e) - rf, n = f - f % i, a = Math.ceil(r / n);\n  return a === 1 ? { count: 1, perEach: r } : {\n    count: (a - 1) * n + f >= r ? a : a + 1,\n    perEach: n\n  };\n}\nfunction p1(e, r) {\n  const t = [];\n  for (let i = r.minVersion; i <= r.maxVersion; i++) {\n    const { count: f, perEach: n } = b1(i, e, r.encoding);\n    r.minSplit <= f && f <= r.maxSplit && t.push({ version: i, count: f, perEach: n });\n  }\n  if (!t.length)\n    throw new Error(\"Cannot make it fit\");\n  return t.sort((i, f) => i.count - f.count || i.version - f.version), t[0];\n}\nfunction k1(e, r, t = {}) {\n  if (!/^[A-Z]$/.test(r))\n    throw new Error(\"fileType must be a single uppercase letter A-Z\");\n  const i = d1(t), { encoding: f, encoded: n } = v1(e, i.encoding), { version: a, count: l, perEach: s } = p1(n.length, i), h = [];\n  for (let u = 0, d = 0; d < n.length; u++, d += s)\n    h.push(\n      `B$${f}${r}` + Ea(l) + Ea(u) + n.slice(d, d + s)\n    );\n  return { version: a, parts: h, encoding: f };\n}\nasync function m1(e) {\n  let r, t;\n  if (e instanceof File && (e = await c1(e)), e instanceof Uint8Array) {\n    if (r = e, ya(e))\n      return console.debug('Detected type \"P\" from binary input'), { fileType: \"P\", raw: r };\n    if (r[0] === 1 || r[0] === 2)\n      return console.debug('Detected type \"T\" from binary input'), { fileType: \"T\", raw: r };\n    try {\n      t = new TextDecoder(\"utf-8\", { fatal: !0 }).decode(r);\n    } catch {\n      return console.debug('Detected type \"B\" from binary input'), { fileType: \"B\", raw: r };\n    }\n  } else if (typeof e == \"string\")\n    t = e;\n  else\n    throw new Error(\"Invalid input - must be a File, Uint8Array or string\");\n  const i = t.trim();\n  if (/^70736274ff[0-9A-Fa-f]+$/.test(i))\n    return console.debug('Detected type \"P\" from hex input'), { fileType: \"P\", raw: zr(i) };\n  if (/^0[1,2]000000[0-9A-Fa-f]+$/.test(i))\n    return console.debug('Detected type \"T\" from hex input'), { fileType: \"T\", raw: zr(i) };\n  if (/^[A-Za-z0-9+/=]+$/.test(i)) {\n    const f = u1(t);\n    if (ya(f))\n      return console.debug('Detected type \"P\" from base64 input'), { fileType: \"P\", raw: f };\n    if (f[0] === 1 || f[0] === 2)\n      return console.debug('Detected type \"T\" from base64 input'), { fileType: \"T\", raw: f };\n  }\n  r = r ?? new TextEncoder().encode(t);\n  try {\n    return JSON.parse(t), console.debug('Detected type \"J\"'), { fileType: \"J\", raw: r };\n  } catch {\n    return console.debug('Detected type \"U\"'), { fileType: \"U\", raw: r };\n  }\n}\n\n\n\n//# sourceURL=webpack://bitcoin-toolkit/./node_modules/bbqr/dist/bbqr.js?");

/***/ }),

/***/ "./src/bbqr-reader.js":
/*!****************************!*\
  !*** ./src/bbqr-reader.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var bbqr__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! bbqr */ \"./node_modules/bbqr/dist/bbqr.js\");\nfunction _regenerator() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */ var e, t, r = \"function\" == typeof Symbol ? Symbol : {}, n = r.iterator || \"@@iterator\", o = r.toStringTag || \"@@toStringTag\"; function i(r, n, o, i) { var c = n && n.prototype instanceof Generator ? n : Generator, u = Object.create(c.prototype); return _regeneratorDefine2(u, \"_invoke\", function (r, n, o) { var i, c, u, f = 0, p = o || [], y = !1, G = { p: 0, n: 0, v: e, a: d, f: d.bind(e, 4), d: function d(t, r) { return i = t, c = 0, u = e, G.n = r, a; } }; function d(r, n) { for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) { var o, i = p[t], d = G.p, l = i[2]; r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0)); } if (o || r > 1) return a; throw y = !0, n; } return function (o, p, l) { if (f > 1) throw TypeError(\"Generator is already running\"); for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) { i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u); try { if (f = 2, i) { if (c || (o = \"next\"), t = i[o]) { if (!(t = t.call(i, u))) throw TypeError(\"iterator result is not an object\"); if (!t.done) return t; u = t.value, c < 2 && (c = 0); } else 1 === c && (t = i.return) && t.call(i), c < 2 && (u = TypeError(\"The iterator does not provide a '\" + o + \"' method\"), c = 1); i = e; } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break; } catch (t) { i = e, c = 1, u = t; } finally { f = 1; } } return { value: t, done: y }; }; }(r, o, i), !0), u; } var a = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} t = Object.getPrototypeOf; var c = [][n] ? t(t([][n]())) : (_regeneratorDefine2(t = {}, n, function () { return this; }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c); function f(e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine2(e, o, \"GeneratorFunction\")), e.prototype = Object.create(u), e; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine2(u, \"constructor\", GeneratorFunctionPrototype), _regeneratorDefine2(GeneratorFunctionPrototype, \"constructor\", GeneratorFunction), GeneratorFunction.displayName = \"GeneratorFunction\", _regeneratorDefine2(GeneratorFunctionPrototype, o, \"GeneratorFunction\"), _regeneratorDefine2(u), _regeneratorDefine2(u, o, \"Generator\"), _regeneratorDefine2(u, n, function () { return this; }), _regeneratorDefine2(u, \"toString\", function () { return \"[object Generator]\"; }), (_regenerator = function _regenerator() { return { w: i, m: f }; })(); }\nfunction _regeneratorDefine2(e, r, n, t) { var i = Object.defineProperty; try { i({}, \"\", {}); } catch (e) { i = 0; } _regeneratorDefine2 = function _regeneratorDefine(e, r, n, t) { if (r) i ? i(e, r, { value: n, enumerable: !t, configurable: !t, writable: !t }) : e[r] = n;else { var o = function o(r, n) { _regeneratorDefine2(e, r, function (e) { return this._invoke(r, n, e); }); }; o(\"next\", 0), o(\"throw\", 1), o(\"return\", 2); } }, _regeneratorDefine2(e, r, n, t); }\nfunction asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }\nfunction _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, \"next\", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, \"throw\", n); } _next(void 0); }); }; }\n// BBQr Reader - Bitcoin QR Code Scanner\n// Simplified version with only scanning/decoding functionality\n\n\n\n// Global state\nvar state = {\n  camera: {\n    stream: null,\n    isScanning: false,\n    scanCount: 0,\n    parts: []\n  },\n  lastDecodedData: null\n};\n\n// DOM elements\nvar elements = {};\n\n// Initialize DOM elements\nfunction initializeElements() {\n  var _elements$canvas;\n  elements.decodeOutput = document.getElementById('decode-output');\n  elements.copyBtn = document.getElementById('copy-btn');\n  elements.scanBtn = document.getElementById('scan-btn');\n  elements.video = document.getElementById('camera-video');\n  elements.canvas = document.getElementById('camera-canvas');\n  elements.ctx = (_elements$canvas = elements.canvas) === null || _elements$canvas === void 0 ? void 0 : _elements$canvas.getContext('2d');\n  elements.stopScanBtn = document.getElementById('stop-scan-btn');\n  elements.clearBtn = document.getElementById('clear-btn');\n  elements.noResults = document.getElementById('no-results');\n  elements.resultActions = document.getElementById('result-actions');\n  elements.scanStatus = document.getElementById('scan-status');\n  elements.cameraContainer = document.getElementById('camera-container');\n}\n\n// Utility functions\nfunction clearContainer(container) {\n  container.innerHTML = '';\n}\nfunction showStatus(container, message) {\n  var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'info';\n  var append = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  if (!append) {\n    var existingMessages = container.querySelectorAll('.status-message');\n    existingMessages.forEach(function (msg) {\n      return msg.remove();\n    });\n  }\n  var statusEl = document.createElement('div');\n  statusEl.className = \"status-message status-\".concat(type);\n  statusEl.textContent = message;\n  container.appendChild(statusEl);\n  return statusEl;\n}\n\n// Format decode results for display\nfunction formatDecodeResult(fileType, raw) {\n  var isFromCamera = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var u8 = raw instanceof Uint8Array ? raw : new Uint8Array(raw);\n  var prefix = isFromCamera ? '📱 扫描成功!\\n\\n' : '📄 解码成功!\\n\\n';\n  var typeLabels = {\n    'U': 'Unicode 文本',\n    'J': 'JSON 数据',\n    'P': 'PSBT (部分签名比特币交易)',\n    'B': '二进制数据'\n  };\n  var result = \"\".concat(prefix);\n\n  // PSBT specific analysis - show only key information\n  if (fileType === 'P') {\n    try {\n      var psbtInfo = analyzePSBT(u8);\n      if (psbtInfo.isValid) {\n        result += \"\\uD83D\\uDD0D PSBT \\u4EA4\\u6613\\u4FE1\\u606F\\n\";\n        result += \"\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\n\";\n        if (psbtInfo.inputCount !== null) {\n          result += \"\\uD83D\\uDCE5 \\u8F93\\u5165 (Inputs): \".concat(psbtInfo.inputCount, \"\\n\");\n        }\n        if (psbtInfo.outputCount !== null) {\n          result += \"\\uD83D\\uDCE4 \\u8F93\\u51FA (Outputs): \".concat(psbtInfo.outputCount, \"\\n\");\n        }\n        if (psbtInfo.hasSignatures !== null) {\n          result += \"\\u270D\\uFE0F  \\u7B7E\\u540D\\u72B6\\u6001: \".concat(psbtInfo.hasSignatures ? '✅ 已签名' : '❌ 未签名', \"\\n\");\n        }\n        if (psbtInfo.networkType) {\n          result += \"\\uD83C\\uDF10 \\u7F51\\u7EDC: \".concat(psbtInfo.networkType, \"\\n\");\n        }\n\n        // Show output details if available\n        if (psbtInfo.outputs && psbtInfo.outputs.length > 0) {\n          result += \"\\n\\uD83D\\uDCB0 \\u8F93\\u51FA\\u8BE6\\u60C5:\\n\";\n          psbtInfo.outputs.forEach(function (output, index) {\n            var btcAmount = (output.value / 100000000).toFixed(8);\n            result += \"  \".concat(index + 1, \". \").concat(btcAmount, \" BTC \\u2192 \").concat(output.address, \"\\n\");\n          });\n          if (psbtInfo.totalOutputValue > 0) {\n            var totalBTC = (psbtInfo.totalOutputValue / 100000000).toFixed(8);\n            result += \"  \\u603B\\u8BA1: \".concat(totalBTC, \" BTC\\n\");\n          }\n        }\n        result += \"\\uD83D\\uDCCA \\u6570\\u636E\\u5927\\u5C0F: \".concat(u8.length, \" \\u5B57\\u8282\\n\");\n        if (psbtInfo.hasSignatures) {\n          result += \"\\n\\uD83C\\uDFAF \\u6B64\\u4EA4\\u6613\\u5DF2\\u7B7E\\u540D\\uFF0C\\u53EF\\u4EE5\\u5E7F\\u64AD\\u5230\\u6BD4\\u7279\\u5E01\\u7F51\\u7EDC\\n\";\n        } else {\n          result += \"\\n\\u23F3 \\u6B64\\u4EA4\\u6613\\u5C1A\\u672A\\u7B7E\\u540D\\uFF0C\\u9700\\u8981\\u4F7F\\u7528\\u94B1\\u5305\\u8FDB\\u884C\\u7B7E\\u540D\\n\";\n        }\n      } else {\n        result += \"\\u274C PSBT \\u89E3\\u6790\\u5931\\u8D25\\n\";\n        result += \"\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\n\";\n        result += \"\\u9519\\u8BEF: \".concat(psbtInfo.error, \"\\n\");\n        result += \"\\u6570\\u636E\\u5927\\u5C0F: \".concat(u8.length, \" \\u5B57\\u8282\\n\");\n      }\n    } catch (error) {\n      result += \"\\u274C PSBT \\u5206\\u6790\\u5931\\u8D25\\n\";\n      result += \"\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\n\";\n      result += \"\\u9519\\u8BEF: \".concat(error.message, \"\\n\");\n      result += \"\\u6570\\u636E\\u5927\\u5C0F: \".concat(u8.length, \" \\u5B57\\u8282\\n\");\n    }\n  } else {\n    // For other file types, show basic info\n    result += \"\\uD83D\\uDCC4 \\u6587\\u4EF6\\u7C7B\\u578B: \".concat(typeLabels[fileType] || fileType, \"\\n\");\n    result += \"\\uD83D\\uDCCA \\u6570\\u636E\\u5927\\u5C0F: \".concat(u8.length, \" \\u5B57\\u8282\\n\");\n    result += \"\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\u2501\\n\";\n    if (fileType === 'U') {\n      var text = new TextDecoder().decode(u8);\n      result += \"\\uD83D\\uDCDD \\u5185\\u5BB9:\\n\".concat(text);\n    } else if (fileType === 'J') {\n      var _text = new TextDecoder().decode(u8);\n      try {\n        var parsed = JSON.parse(_text);\n        result += \"\\u2705 JSON \\u5185\\u5BB9:\\n\".concat(JSON.stringify(parsed, null, 2));\n      } catch (e) {\n        result += \"\\u26A0\\uFE0F JSON \\u89E3\\u6790\\u5931\\u8D25:\\n\".concat(_text);\n      }\n    } else {\n      result += \"\\uD83D\\uDCC1 \\u4E8C\\u8FDB\\u5236\\u6570\\u636E\\uFF0C\\u5927\\u5C0F: \".concat(u8.length, \" \\u5B57\\u8282\");\n    }\n  }\n  return result;\n}\n\n// Enhanced PSBT Analysis Function\nfunction analyzePSBT(data) {\n  try {\n    // Check PSBT magic bytes: \"psbt\" + 0xff separator\n    var magicBytes = new Uint8Array([0x70, 0x73, 0x62, 0x74, 0xff]);\n    if (data.length < 5) {\n      return {\n        isValid: false,\n        error: 'PSBT 数据太短'\n      };\n    }\n\n    // Check magic bytes\n    var hasValidMagic = data[0] === magicBytes[0] && data[1] === magicBytes[1] && data[2] === magicBytes[2] && data[3] === magicBytes[3] && data[4] === magicBytes[4];\n    if (!hasValidMagic) {\n      return {\n        isValid: false,\n        error: '不是有效的 PSBT 格式'\n      };\n    }\n\n    // Enhanced parsing for transaction details\n    var inputCount = 0;\n    var outputCount = 0;\n    var hasSignatures = false;\n    var version = null;\n    var outputs = [];\n    var totalOutputValue = 0;\n    try {\n      // Parse global map to find unsigned transaction\n      var unsignedTx = null;\n      var globalOffset = 5;\n      while (globalOffset < data.length - 1) {\n        var keyLen = data[globalOffset];\n        if (keyLen === 0x00) {\n          globalOffset++;\n          break; // End of global map\n        }\n\n        // Check if this is the unsigned transaction key (0x00)\n        if (keyLen === 1 && data[globalOffset + 1] === 0x00) {\n          globalOffset += 2; // Skip key\n          var valueLen = readVarint(data, globalOffset);\n          globalOffset += getVarintSize(data, globalOffset);\n\n          // Extract unsigned transaction\n          unsignedTx = data.slice(globalOffset, globalOffset + valueLen.value);\n          globalOffset += valueLen.value;\n          console.log('Found unsigned transaction, length:', unsignedTx.length);\n        } else {\n          // Skip this key-value pair\n          globalOffset += keyLen + 1; // Skip key\n          if (globalOffset >= data.length) break;\n          var _valueLen = readVarint(data, globalOffset);\n          globalOffset += getVarintSize(data, globalOffset) + _valueLen.value;\n        }\n        if (globalOffset >= data.length) break;\n      }\n\n      // Parse unsigned transaction if found\n      if (unsignedTx && unsignedTx.length > 10) {\n        var txOffset = 0;\n\n        // Read version (4 bytes, little endian)\n        version = unsignedTx[txOffset] | unsignedTx[txOffset + 1] << 8 | unsignedTx[txOffset + 2] << 16 | unsignedTx[txOffset + 3] << 24;\n        txOffset += 4;\n\n        // Read input count\n        var inputCountVarint = readVarint(unsignedTx, txOffset);\n        inputCount = inputCountVarint.value;\n        txOffset += getVarintSize(unsignedTx, txOffset);\n\n        // Skip inputs\n        for (var i = 0; i < inputCount && txOffset < unsignedTx.length - 8; i++) {\n          txOffset += 32; // Previous output hash\n          txOffset += 4; // Previous output index\n\n          if (txOffset >= unsignedTx.length) break;\n\n          // Skip script\n          var scriptLen = readVarint(unsignedTx, txOffset);\n          txOffset += getVarintSize(unsignedTx, txOffset) + scriptLen.value;\n          if (txOffset >= unsignedTx.length) break;\n          txOffset += 4; // Sequence\n        }\n\n        // Read output count\n        if (txOffset < unsignedTx.length) {\n          var outputCountVarint = readVarint(unsignedTx, txOffset);\n          outputCount = outputCountVarint.value;\n          txOffset += getVarintSize(unsignedTx, txOffset);\n\n          // Parse outputs\n          console.log('Parsing outputs, count:', outputCount, 'txOffset:', txOffset);\n          for (var _i = 0; _i < outputCount && txOffset < unsignedTx.length - 8; _i++) {\n            if (txOffset + 8 >= unsignedTx.length) break;\n\n            // Read value (8 bytes, little endian)\n            var value = 0;\n            for (var j = 0; j < 8; j++) {\n              value += unsignedTx[txOffset + j] * Math.pow(256, j);\n            }\n            txOffset += 8;\n\n            // Read script\n            var _scriptLen = readVarint(unsignedTx, txOffset);\n            txOffset += getVarintSize(unsignedTx, txOffset);\n            if (txOffset + _scriptLen.value > unsignedTx.length) break;\n            var script = unsignedTx.slice(txOffset, txOffset + _scriptLen.value);\n            txOffset += _scriptLen.value;\n\n            // Try to decode address from script\n            var address = decodeScriptToAddress(script);\n            console.log(\"Output \".concat(_i + 1, \": value=\").concat(value, \", address=\").concat(address, \", scriptLen=\").concat(_scriptLen.value));\n            outputs.push({\n              value: value,\n              address: address,\n              script: Array.from(script).map(function (b) {\n                return b.toString(16).padStart(2, '0');\n              }).join('')\n            });\n            totalOutputValue += value;\n          }\n          console.log('Total outputs parsed:', outputs.length, 'totalOutputValue:', totalOutputValue);\n        }\n      }\n\n      // Look for signatures in the PSBT data\n      for (var _i2 = 5; _i2 < data.length - 8; _i2++) {\n        if (data[_i2] === 0x30) {\n          var derLen = data[_i2 + 1];\n          if (derLen >= 0x44 && derLen <= 0x48 && _i2 + derLen + 2 < data.length) {\n            if (data[_i2 + 2] === 0x02) {\n              hasSignatures = true;\n              break;\n            }\n          }\n        }\n      }\n    } catch (parseError) {\n      console.warn('Enhanced PSBT parsing failed, using basic info:', parseError);\n    }\n\n    // If we couldn't parse details, provide basic info\n    if (inputCount === 0 && outputCount === 0) {\n      inputCount = '无法解析';\n      outputCount = '无法解析';\n    }\n    return {\n      isValid: true,\n      version: version,\n      inputCount: inputCount,\n      outputCount: outputCount,\n      outputs: outputs,\n      totalOutputValue: totalOutputValue,\n      hasSignatures: hasSignatures,\n      networkType: 'Bitcoin',\n      error: null\n    };\n  } catch (error) {\n    return {\n      isValid: false,\n      error: \"\\u89E3\\u6790\\u5931\\u8D25: \".concat(error.message)\n    };\n  }\n}\n\n// Helper functions for PSBT parsing\nfunction readVarint(data, offset) {\n  if (offset >= data.length) return {\n    value: 0,\n    size: 1\n  };\n  var first = data[offset];\n  if (first < 0xfd) {\n    return {\n      value: first,\n      size: 1\n    };\n  } else if (first === 0xfd) {\n    if (offset + 2 >= data.length) return {\n      value: 0,\n      size: 1\n    };\n    return {\n      value: data[offset + 1] | data[offset + 2] << 8,\n      size: 3\n    };\n  } else if (first === 0xfe) {\n    if (offset + 4 >= data.length) return {\n      value: 0,\n      size: 1\n    };\n    return {\n      value: data[offset + 1] | data[offset + 2] << 8 | data[offset + 3] << 16 | data[offset + 4] << 24,\n      size: 5\n    };\n  }\n  return {\n    value: 0,\n    size: 1\n  };\n}\nfunction getVarintSize(data, offset) {\n  if (offset >= data.length) return 1;\n  var first = data[offset];\n  if (first < 0xfd) return 1;else if (first === 0xfd) return 3;else if (first === 0xfe) return 5;else return 9;\n}\nfunction decodeScriptToAddress(script) {\n  if (!script || script.length === 0) return '未知地址';\n  try {\n    // P2PKH (Pay to Public Key Hash) - starts with OP_DUP OP_HASH160\n    if (script.length === 25 && script[0] === 0x76 && script[1] === 0xa9 && script[2] === 0x14) {\n      var hash160 = script.slice(3, 23);\n      return \"1\".concat(Array.from(hash160).map(function (b) {\n        return b.toString(16).padStart(2, '0');\n      }).join('').substring(0, 8), \"...\");\n    }\n\n    // P2SH (Pay to Script Hash) - starts with OP_HASH160\n    if (script.length === 23 && script[0] === 0xa9 && script[1] === 0x14) {\n      var _hash = script.slice(2, 22);\n      return \"3\".concat(Array.from(_hash).map(function (b) {\n        return b.toString(16).padStart(2, '0');\n      }).join('').substring(0, 8), \"...\");\n    }\n\n    // P2WPKH (Pay to Witness Public Key Hash) - OP_0 + 20 bytes\n    if (script.length === 22 && script[0] === 0x00 && script[1] === 0x14) {\n      return \"bc1q\".concat(Array.from(script.slice(2)).map(function (b) {\n        return b.toString(16).padStart(2, '0');\n      }).join('').substring(0, 8), \"...\");\n    }\n\n    // P2WSH (Pay to Witness Script Hash) - OP_0 + 32 bytes\n    if (script.length === 34 && script[0] === 0x00 && script[1] === 0x20) {\n      return \"bc1q\".concat(Array.from(script.slice(2)).map(function (b) {\n        return b.toString(16).padStart(2, '0');\n      }).join('').substring(0, 8), \"...\");\n    }\n\n    // P2TR (Pay to Taproot) - OP_1 + 32 bytes\n    if (script.length === 34 && script[0] === 0x51 && script[1] === 0x20) {\n      return \"bc1p\".concat(Array.from(script.slice(2)).map(function (b) {\n        return b.toString(16).padStart(2, '0');\n      }).join('').substring(0, 8), \"...\");\n    }\n    return \"\\u811A\\u672C\\u5730\\u5740 (\".concat(script.length, \"\\u5B57\\u8282)\");\n  } catch (error) {\n    return '地址解析失败';\n  }\n}\n\n// Copy functionality\nfunction handleCopyClick() {\n  return _handleCopyClick.apply(this, arguments);\n} // Browser detection utilities\nfunction _handleCopyClick() {\n  _handleCopyClick = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee() {\n    var result, originalText, _t;\n    return _regenerator().w(function (_context) {\n      while (1) switch (_context.n) {\n        case 0:\n          if (state.lastDecodedData) {\n            _context.n = 1;\n            break;\n          }\n          alert('没有可复制的数据');\n          return _context.a(2);\n        case 1:\n          _context.p = 1;\n          result = formatDecodeResult(state.lastDecodedData.fileType, state.lastDecodedData.raw, true);\n          _context.n = 2;\n          return navigator.clipboard.writeText(result);\n        case 2:\n          originalText = elements.copyBtn.textContent;\n          elements.copyBtn.textContent = '✅ 已复制';\n          elements.copyBtn.classList.remove('gradient-button-success');\n          elements.copyBtn.classList.add('bg-green-600');\n          setTimeout(function () {\n            elements.copyBtn.textContent = originalText;\n            elements.copyBtn.classList.add('gradient-button-success');\n            elements.copyBtn.classList.remove('bg-green-600');\n          }, 2000);\n          _context.n = 4;\n          break;\n        case 3:\n          _context.p = 3;\n          _t = _context.v;\n          console.error('Copy failed:', _t);\n          alert('复制失败，请手动选择文本复制');\n        case 4:\n          return _context.a(2);\n      }\n    }, _callee, null, [[1, 3]]);\n  }));\n  return _handleCopyClick.apply(this, arguments);\n}\nfunction isSafari() {\n  return /^((?!chrome|android).)*safari/i.test(navigator.userAgent);\n}\nfunction isIOS() {\n  return /iPad|iPhone|iPod/.test(navigator.userAgent);\n}\n\n// Camera functionality\nfunction getCameraStream() {\n  return _getCameraStream.apply(this, arguments);\n}\nfunction _getCameraStream() {\n  _getCameraStream = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee2() {\n    var constraints, stream, basicConstraints, _stream, _t2, _t3;\n    return _regenerator().w(function (_context2) {\n      while (1) switch (_context2.n) {\n        case 0:\n          constraints = {\n            video: {\n              facingMode: 'environment',\n              width: {\n                ideal: 1280,\n                max: 1920\n              },\n              height: {\n                ideal: 720,\n                max: 1080\n              },\n              frameRate: {\n                ideal: 30,\n                max: 60\n              }\n            },\n            audio: false\n          };\n          _context2.p = 1;\n          _context2.n = 2;\n          return navigator.mediaDevices.getUserMedia(constraints);\n        case 2:\n          stream = _context2.v;\n          console.log('Camera stream obtained:', stream.getVideoTracks()[0].getSettings());\n          return _context2.a(2, stream);\n        case 3:\n          _context2.p = 3;\n          _t2 = _context2.v;\n          console.error('Camera access error:', _t2);\n\n          // Try with basic constraints as fallback\n          _context2.p = 4;\n          basicConstraints = {\n            video: {\n              facingMode: 'environment'\n            },\n            audio: false\n          };\n          _context2.n = 5;\n          return navigator.mediaDevices.getUserMedia(basicConstraints);\n        case 5:\n          _stream = _context2.v;\n          console.log('Camera stream obtained with basic constraints');\n          return _context2.a(2, _stream);\n        case 6:\n          _context2.p = 6;\n          _t3 = _context2.v;\n          console.error('Basic camera access also failed:', _t3);\n          throw _t3;\n        case 7:\n          return _context2.a(2);\n      }\n    }, _callee2, null, [[4, 6], [1, 3]]);\n  }));\n  return _getCameraStream.apply(this, arguments);\n}\nfunction stopCameraStream() {\n  if (state.camera.stream) {\n    state.camera.stream.getTracks().forEach(function (track) {\n      track.stop();\n      console.log('Camera track stopped:', track.kind);\n    });\n    state.camera.stream = null;\n  }\n  state.camera.isScanning = false;\n  state.camera.scanCount = 0;\n\n  // Hide camera interface\n  if (elements.video) {\n    elements.video.classList.add('hidden');\n  }\n  if (elements.cameraContainer) {\n    elements.cameraContainer.classList.add('hidden');\n  }\n  if (elements.scanStatus) {\n    elements.scanStatus.classList.add('hidden');\n  }\n  if (elements.stopScanBtn) {\n    elements.stopScanBtn.classList.add('hidden');\n  }\n  if (elements.scanBtn) {\n    elements.scanBtn.classList.remove('hidden');\n    elements.scanBtn.disabled = false;\n    elements.scanBtn.textContent = '📷 开始相机扫描';\n  }\n  state.camera.parts = [];\n}\n\n// Camera scanning functionality\nfunction handleScanClick() {\n  return _handleScanClick.apply(this, arguments);\n}\nfunction _handleScanClick() {\n  _handleScanClick = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee3() {\n    var isDevelopment, _t4;\n    return _regenerator().w(function (_context3) {\n      while (1) switch (_context3.n) {\n        case 0:\n          clearContainer(elements.decodeOutput);\n          elements.copyBtn.classList.add('hidden');\n          elements.scanBtn.disabled = true;\n          elements.scanBtn.textContent = '初始化相机...';\n          _context3.p = 1;\n          // Check HTTPS requirement on iOS\n          isDevelopment = location.hostname === 'localhost' || location.hostname === '127.0.0.1' || location.hostname.startsWith('192.168.') || location.hostname.startsWith('10.') || location.hostname.endsWith('.local');\n          if (!(isIOS() && location.protocol !== 'https:' && !isDevelopment)) {\n            _context3.n = 2;\n            break;\n          }\n          throw new Error('Camera requires HTTPS on iOS devices. For testing, use localhost or HTTPS.');\n        case 2:\n          showStatus(elements.decodeOutput, '正在启动相机...', 'info');\n          _context3.n = 3;\n          return getCameraStream();\n        case 3:\n          state.camera.stream = _context3.v;\n          if (state.camera.stream) {\n            _context3.n = 4;\n            break;\n          }\n          throw new Error('Failed to get camera stream');\n        case 4:\n          elements.video.srcObject = state.camera.stream;\n\n          // Show camera container and video\n          if (elements.cameraContainer) {\n            elements.cameraContainer.classList.remove('hidden');\n          }\n          elements.video.classList.remove('hidden');\n\n          // Show stop button, hide start button\n          if (elements.stopScanBtn) {\n            elements.stopScanBtn.classList.remove('hidden');\n          }\n          elements.scanBtn.classList.add('hidden');\n\n          // iOS Safari specific settings\n          if (isIOS()) {\n            elements.video.setAttribute('webkit-playsinline', 'true');\n            elements.video.setAttribute('playsinline', 'true');\n          }\n\n          // Wait for video to load\n          _context3.n = 5;\n          return new Promise(function (resolve, reject) {\n            var timeout = setTimeout(function () {\n              reject(new Error('Video load timeout'));\n            }, 10000);\n            elements.video.onloadedmetadata = function () {\n              clearTimeout(timeout);\n              resolve();\n            };\n            elements.video.onerror = function () {\n              clearTimeout(timeout);\n              reject(new Error('Video load error'));\n            };\n          });\n        case 5:\n          _context3.n = 6;\n          return elements.video.play();\n        case 6:\n          _context3.n = 7;\n          return new Promise(function (resolve) {\n            return setTimeout(resolve, 500);\n          });\n        case 7:\n          // Stabilization delay\n\n          // Set canvas size\n          elements.canvas.width = elements.video.videoWidth || 640;\n          elements.canvas.height = elements.video.videoHeight || 480;\n\n          // Reset camera state\n          state.camera.isScanning = true;\n          state.camera.scanCount = 0;\n          state.camera.parts = [];\n\n          // Show scan status in the camera view\n          if (elements.scanStatus) {\n            elements.scanStatus.classList.remove('hidden');\n            elements.scanStatus.innerHTML = \"\\n        <div class=\\\"text-center\\\">\\n          <div class=\\\"text-white font-bold text-lg mb-1\\\">\\n            0/? \\u51C6\\u5907\\u626B\\u63CF\\n          </div>\\n          <div class=\\\"text-white text-xs opacity-90\\\">\\n            \\u8BF7\\u5C06\\u76F8\\u673A\\u5BF9\\u51C6 BBQr \\u7801\\n          </div>\\n        </div>\\n      \";\n          }\n          startScanLoop();\n          _context3.n = 9;\n          break;\n        case 8:\n          _context3.p = 8;\n          _t4 = _context3.v;\n          handleScanError(_t4);\n        case 9:\n          return _context3.a(2);\n      }\n    }, _callee3, null, [[1, 8]]);\n  }));\n  return _handleScanClick.apply(this, arguments);\n}\nfunction startScanLoop() {\n  var maxScans = 600; // 20 seconds at ~30fps\n  var lastScanTime = 0;\n  function scanFrame(timestamp) {\n    // Throttle to ~10fps for better performance\n    if (timestamp - lastScanTime < 100) {\n      if (state.camera.scanCount < maxScans && state.camera.isScanning) {\n        requestAnimationFrame(scanFrame);\n      }\n      return;\n    }\n    lastScanTime = timestamp;\n    state.camera.scanCount++;\n\n    // Check for timeout or manual stop\n    if (!state.camera.isScanning || state.camera.scanCount > maxScans) {\n      if (state.camera.scanCount > maxScans) {\n        if (elements.scanStatus) {\n          elements.scanStatus.innerHTML = '<div class=\"p-3 bg-red-50 text-red-800 border border-red-200 rounded-xl text-sm font-medium\">⏰ 扫描超时，请重试</div>';\n        }\n        setTimeout(function () {\n          stopCameraStream();\n        }, 2000);\n      } else {\n        stopCameraStream();\n      }\n      return;\n    }\n\n    // Check if video is ended or paused\n    if (elements.video.paused || elements.video.ended) {\n      stopCameraStream();\n      return;\n    }\n    try {\n      if (elements.video.readyState === elements.video.HAVE_ENOUGH_DATA) {\n        elements.ctx.drawImage(elements.video, 0, 0, elements.canvas.width, elements.canvas.height);\n        var imageData = elements.ctx.getImageData(0, 0, elements.canvas.width, elements.canvas.height);\n        var code = jsQR(imageData.data, elements.canvas.width, elements.canvas.height);\n        if (code !== null && code !== void 0 && code.data && !state.camera.parts.includes(code.data)) {\n          state.camera.parts.push(code.data);\n\n          // Update scan status with enhanced progress\n          if (elements.scanStatus) {\n            // Try to determine expected total parts from first QR code\n            var expectedParts = '?';\n            try {\n              // BBQr format typically includes part info in the QR data\n              var firstPart = state.camera.parts[0];\n              if (firstPart && firstPart.includes('/')) {\n                var match = firstPart.match(/(\\d+)\\/(\\d+)/);\n                if (match) {\n                  expectedParts = match[2];\n                }\n              }\n            } catch (e) {\n              // Ignore parsing errors\n            }\n            elements.scanStatus.innerHTML = \"\\n              <div class=\\\"text-center\\\">\\n                <div class=\\\"text-green-400 font-bold text-lg mb-1\\\">\\n                  \".concat(state.camera.parts.length, \"/\").concat(expectedParts, \" \\u5DF2\\u5B8C\\u6210\\n                </div>\\n                <div class=\\\"text-white text-xs opacity-90\\\">\\n                  \\u7EE7\\u7EED\\u626B\\u63CF QR \\u7801\\u7247\\u6BB5...\\n                </div>\\n              </div>\\n            \");\n          }\n\n          // Try to join parts\n          try {\n            var _joinQRs = (0,bbqr__WEBPACK_IMPORTED_MODULE_0__.joinQRs)(state.camera.parts),\n              fileType = _joinQRs.fileType,\n              raw = _joinQRs.raw;\n            var u8 = raw instanceof Uint8Array ? raw : new Uint8Array(raw);\n\n            // Success! Store and display result\n            state.lastDecodedData = {\n              fileType: fileType,\n              raw: u8\n            };\n\n            // Show completion status with PSBT details\n            if (elements.scanStatus) {\n              var statusContent = \"\\n                <div class=\\\"text-center\\\">\\n                  <div class=\\\"text-green-400 font-bold text-lg mb-2\\\">\\n                    \\u2705 \".concat(state.camera.parts.length, \"/\").concat(state.camera.parts.length, \" \\u626B\\u63CF\\u5B8C\\u6210\\n                  </div>\\n              \");\n\n              // Add PSBT details if it's a PSBT\n              if (fileType === 'P') {\n                try {\n                  var psbtInfo = analyzePSBT(u8);\n                  if (psbtInfo.isValid) {\n                    statusContent += \"\\n                      <div class=\\\"text-white text-xs space-y-1 opacity-90\\\">\\n                        <div>\\uD83D\\uDCE5 \\u8F93\\u5165: \".concat(psbtInfo.inputCount, \" \\u4E2A</div>\\n                        <div>\\uD83D\\uDCE4 \\u8F93\\u51FA: \").concat(psbtInfo.outputCount, \" \\u4E2A</div>\\n                    \");\n\n                    // Show output addresses and amounts\n                    if (psbtInfo.outputs && psbtInfo.outputs.length > 0) {\n                      statusContent += \"<div class=\\\"mt-2 space-y-1\\\">\";\n                      psbtInfo.outputs.forEach(function (output, index) {\n                        var btcAmount = (output.value / 100000000).toFixed(8);\n                        statusContent += \"\\n                          <div class=\\\"text-xs\\\">\\n                            <div>\\uD83D\\uDCB0 \".concat(btcAmount, \" BTC</div>\\n                            <div class=\\\"text-gray-300\\\">\").concat(output.address, \"</div>\\n                          </div>\\n                        \");\n                      });\n                      statusContent += \"</div>\";\n                    }\n                    statusContent += \"\\n                        <div class=\\\"mt-1\\\">\\n                          \".concat(psbtInfo.hasSignatures ? '✅ 已签名' : '❌ 未签名', \"\\n                        </div>\\n                      </div>\\n                    \");\n                  }\n                } catch (e) {\n                  console.warn('Failed to analyze PSBT for status:', e);\n                }\n              }\n              statusContent += \"</div>\";\n              elements.scanStatus.innerHTML = statusContent;\n            }\n\n            // Wait a moment then hide camera and show results\n            setTimeout(function () {\n              // Hide camera interface\n              if (elements.cameraContainer) {\n                elements.cameraContainer.classList.add('hidden');\n              }\n              if (elements.scanStatus) {\n                elements.scanStatus.classList.add('hidden');\n              }\n              if (elements.stopScanBtn) {\n                elements.stopScanBtn.classList.add('hidden');\n              }\n              elements.scanBtn.classList.remove('hidden');\n\n              // Show enhanced results\n              var result = formatDecodeResult(fileType, u8, true);\n              if (elements.decodeOutput) {\n                elements.decodeOutput.textContent = result;\n                elements.decodeOutput.classList.remove('hidden');\n              }\n              if (elements.noResults) {\n                elements.noResults.classList.add('hidden');\n              }\n              if (elements.resultActions) {\n                elements.resultActions.classList.remove('hidden');\n              }\n              elements.copyBtn.classList.remove('hidden');\n\n              // Stop camera\n              stopCameraStream();\n            }, 2000);\n            return; // Exit scan loop\n          } catch (joinError) {\n            // Not enough parts yet, continue scanning\n            console.log('Join failed, need more parts:', joinError.message);\n          }\n        }\n      }\n    } catch (error) {\n      console.error('Scan frame error:', error);\n    }\n\n    // Continue scanning\n    if (state.camera.scanCount < maxScans && state.camera.isScanning) {\n      requestAnimationFrame(scanFrame);\n    }\n  }\n  requestAnimationFrame(scanFrame);\n}\nfunction handleScanError(error) {\n  console.error('Camera scan error:', error);\n  var errorMsg = '📷 相机扫描失败\\n\\n';\n  switch (error.name) {\n    case 'NotAllowedError':\n      errorMsg += '相机权限被拒绝，请允许相机访问';\n      break;\n    case 'NotFoundError':\n      errorMsg += '未找到相机设备';\n      break;\n    case 'NotSupportedError':\n      errorMsg += '浏览器不支持相机功能';\n      break;\n    case 'NotReadableError':\n      errorMsg += '相机正在被其他应用使用';\n      break;\n    case 'OverconstrainedError':\n      errorMsg += '相机约束无法满足';\n      break;\n    default:\n      errorMsg += error.message;\n  }\n\n  // iOS-specific guidance\n  if (isIOS()) {\n    errorMsg += '\\n\\n📱 iOS 设备注意事项:\\n• 请使用 Safari 浏览器\\n• 允许相机权限\\n• 确保使用 HTTPS (非 HTTP)';\n  }\n\n  // Show error in scan status if available, otherwise in decode output\n  if (elements.scanStatus) {\n    elements.scanStatus.innerHTML = \"<div class=\\\"p-3 bg-red-50 text-red-800 border border-red-200 rounded-xl text-sm font-medium\\\">\".concat(errorMsg, \"</div>\");\n    setTimeout(function () {\n      stopCameraStream();\n    }, 3000);\n  } else {\n    clearContainer(elements.decodeOutput);\n    showStatus(elements.decodeOutput, errorMsg, 'error');\n    stopCameraStream();\n  }\n}\n\n// Clear decode results\nfunction clearDecodeResults() {\n  if (elements.decodeOutput) {\n    elements.decodeOutput.classList.add('hidden');\n    elements.decodeOutput.textContent = '';\n  }\n  if (elements.noResults) {\n    elements.noResults.classList.remove('hidden');\n  }\n  if (elements.resultActions) {\n    elements.resultActions.classList.add('hidden');\n  }\n  state.lastDecodedData = null;\n}\n\n// Initialize BBQr Reader functionality\nfunction initBBQrReader() {\n  initializeElements();\n\n  // Elements specific to reader (camera scanning only)\n  var readerElements = ['decodeOutput', 'copyBtn', 'scanBtn'];\n  var missingElements = readerElements.filter(function (name) {\n    return !elements[name];\n  });\n  if (missingElements.length > 0) {\n    console.error('Missing required reader elements:', missingElements);\n    return;\n  }\n\n  // Set up reader event listeners (camera scanning only)\n  elements.copyBtn.addEventListener('click', handleCopyClick);\n  elements.scanBtn.addEventListener('click', handleScanClick);\n  if (elements.stopScanBtn) {\n    elements.stopScanBtn.addEventListener('click', function () {\n      stopCameraStream();\n      elements.scanBtn.disabled = false;\n      elements.stopScanBtn.classList.add('hidden');\n      elements.scanBtn.classList.remove('hidden');\n    });\n  }\n  if (elements.clearBtn) {\n    elements.clearBtn.addEventListener('click', function () {\n      clearDecodeResults();\n    });\n  }\n\n  // Clean up camera stream when page is hidden/unloaded\n  document.addEventListener('visibilitychange', function () {\n    if (document.hidden && state.camera.isScanning) {\n      stopCameraStream();\n      elements.scanBtn.disabled = false;\n      elements.scanBtn.textContent = '扫描相机';\n    }\n  });\n  window.addEventListener('beforeunload', function () {\n    stopCameraStream();\n  });\n  console.log('BBQr Reader initialized successfully');\n}\n\n// Expose functions to window for page initialization\nwindow.initBBQrReader = initBBQrReader;\n\n// Initialize when DOM is loaded\ndocument.addEventListener('DOMContentLoaded', function () {\n  if (window.initBBQrReader) {\n    window.initBBQrReader();\n  }\n});\n\n//# sourceURL=webpack://bitcoin-toolkit/./src/bbqr-reader.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/bbqr-reader.js");
/******/ 	
/******/ })()
;