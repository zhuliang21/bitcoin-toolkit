<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Bitcoin Price API Status</title>
  <link rel="icon" href="icon/favicon.ico">
  
  <!-- Shared layout styles -->
  <link rel="stylesheet" href="shared-styles.css">
  
  <!-- Ensure page is visible on load -->
  <style>
    /* Override shared-styles opacity to prevent blank page */
    html, body {
      opacity: 1 !important;
    }
  </style>
  
  <style>
    /* Page-specific styles for price API status */
    .status-section {
      margin-bottom: 30px;
    }
    
    .section-title {
      font-size: 1.1rem;
      font-weight: bold;
      color: white;
      margin-bottom: 20px;
      display: flex;
      align-items: center;
      gap: 10px;
      text-align: center;
      justify-content: center;
    }
    
    .api-grid {
      display: grid;
      grid-template-columns: repeat(5, 1fr);
      gap: 12px;
      margin-bottom: 30px;
    }
    
    .api-card {
      background: rgba(255, 255, 255, 0.2);
      border: 1px solid rgba(255, 255, 255, 0.3);
      border-radius: 12px;
      padding: 15px;
      transition: all 0.3s ease;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
      min-height: 120px;
    }
    
    .api-card.success {
      border-color: rgba(16, 185, 129, 0.6);
      background: rgba(16, 185, 129, 0.1);
    }
    
    .api-card.error {
      border-color: rgba(239, 68, 68, 0.6);
      background: rgba(239, 68, 68, 0.1);
    }
    
    .api-card.testing {
      border-color: rgba(251, 191, 36, 0.6);
      background: rgba(251, 191, 36, 0.1);
      animation: pulse 2s infinite;
    }
    
    .api-card.active {
      border-color: rgba(59, 130, 246, 0.8);
      background: rgba(59, 130, 246, 0.2);
      transform: scale(1.02);
    }
    
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }
    
    .api-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
    }
    
    .api-name {
      font-weight: bold;
      color: white;
      font-size: 14px;
    }
    
    .api-region {
      background: rgba(255, 255, 255, 0.2);
      padding: 2px 6px;
      border-radius: 8px;
      font-size: 10px;
      color: rgba(255, 255, 255, 0.8);
    }
    
    .api-status {
      display: flex;
      align-items: center;
      gap: 6px;
      margin-bottom: 6px;
    }
    
    .status-dot {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: #6b7280;
    }
    
    .status-dot.success {
      background: #10b981;
      box-shadow: 0 0 6px rgba(16, 185, 129, 0.4);
    }
    
    .status-dot.error {
      background: #ef4444;
      box-shadow: 0 0 6px rgba(239, 68, 68, 0.4);
    }
    
    .status-dot.testing {
      background: #fbbf24;
      box-shadow: 0 0 6px rgba(251, 191, 36, 0.4);
    }
    
    .status-text {
      color: rgba(255, 255, 255, 0.9);
      font-size: 12px;
    }
    
    .api-price {
      font-family: 'Courier New', monospace;
      color: #10b981;
      font-weight: bold;
      font-size: 13px;
    }
    
    .api-response-time {
      color: rgba(255, 255, 255, 0.6);
      font-size: 10px;
      margin-top: 3px;
    }
    
    .test-controls {
      text-align: center;
      margin-bottom: 30px;
    }
    
    .test-btn {
      background: linear-gradient(135deg, #3b82f6, #1d4ed8);
      color: white;
      border: none;
      border-radius: 25px;
      padding: 12px 25px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      margin: 0 8px;
    }
    
    .test-btn:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: 0 10px 25px rgba(59, 130, 246, 0.3);
    }
    
    .test-btn:disabled {
      background: rgba(108, 117, 125, 0.8);
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }
    
    /* Matrix Animation Button */
    .matrix-btn {
      background: linear-gradient(135deg, #00ff41, #00cc33);
      color: black;
      font-family: 'Courier New', monospace;
    }
    
    .matrix-btn:hover:not(:disabled) {
      box-shadow: 0 10px 25px rgba(0, 255, 65, 0.3);
    }
    
    /* Matrix Mode Styles */
    .matrix-mode {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: radial-gradient(ellipse at center, #001100 0%, #000000 70%);
      z-index: 1000;
      display: none;
      overflow: hidden;
    }
    
    .matrix-mode.active {
      display: block;
    }
    
    .matrix-controls {
      position: fixed;
      top: 20px;
      left: 20px;
      z-index: 1001;
      transition: opacity 1.5s ease-in-out;
      display: flex;
      gap: 12px;
    }
    
    .matrix-controls.hidden {
      opacity: 0;
      pointer-events: none;
    }
    
    .matrix-btn-control {
      background: rgba(0, 0, 0, 0.2);
      border: 1px solid rgba(0, 255, 65, 0.3);
      border-radius: 50%;
      width: 48px;
      height: 48px;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #00ff41;
      cursor: pointer;
      transition: all 0.3s ease;
      backdrop-filter: blur(4px);
      text-shadow: 0 0 8px currentColor;
    }
    
    .matrix-btn-control:hover {
      background: rgba(0, 0, 0, 0.4);
      border-color: rgba(0, 255, 65, 0.6);
      color: white;
      transform: scale(1.1);
    }
    
    .matrix-animation-container {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      pointer-events: none;
      z-index: 1000;
      overflow: hidden;
    }

    .falling-price {
      position: absolute;
      font-family: 'Courier New', 'Monaco', 'Consolas', 'Lucida Console', monospace;
      font-weight: bold;
      color: #00ff41;
      text-shadow: 0 0 8px #00ff41, 0 0 16px #00ff41;
      animation: smoothFall 8s linear forwards;
      pointer-events: none;
      font-size: 64px;
      letter-spacing: 0.15em;
      text-align: center;
      white-space: nowrap;
      left: 50%;
      transform: translateX(-50%);
    }

    @media (max-width: 768px) {
      .falling-price {
        font-size: 48px;
      }
    }

    @media (max-width: 480px) {
      .falling-price {
        font-size: 40px;
      }
    }

    @keyframes smoothFall {
      0% {
        transform: translateX(-50%) translateY(-100px);
        opacity: 1;
      }
      100% {
        transform: translateX(-50%) translateY(100vh);
        opacity: 0;
      }
    }

    @media (max-width: 1200px) {
      .api-grid {
        grid-template-columns: repeat(3, 1fr);
      }
    }
    
    @media (max-width: 768px) {
      .api-grid {
        grid-template-columns: repeat(2, 1fr);
      }
    }
    
    @media (max-width: 480px) {
      .api-grid {
        grid-template-columns: 1fr;
      }
    }

    /* Center Mode Styles */
    .center-mode {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: radial-gradient(circle at center, #000000 0%, #001111 70%);
      z-index: 1000;
      display: none;
      overflow: hidden;
    }
    .center-mode.active {
      display: block;
    }
    .center-price {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-family: 'Courier New', 'Monaco', 'Consolas', 'Lucida Console', monospace;
      font-weight: bold;
      font-size: 12vw;
      line-height: 1;
      white-space: nowrap;
      color: #ffffff;
      text-shadow: none;
      transition: color 0.6s ease;
    }
    .center-price.animate {
      /* ÂèñÊ∂àË∑≥Âä®Âä®Áîª */
      animation: none;
    }

    /* Simulated fullscreen removed */
  </style>
</head>

<body>
  <div class="container">
    <div class="header-controls">
      <a href="index.html" class="back-btn" title="Back">‚Üê</a>
      <div style="color: white; font-size: 16px; font-weight: 600; position: absolute; left: 50%; transform: translateX(-50%); white-space: nowrap;" data-i18n="title">üí∞ Bitcoin Price API</div>
      <button class="language-toggle" onclick="toggleLanguage()">EN</button>
    </div>
    
    <div class="header">
      <p class="subtitle" data-i18n="subtitle">Real-time Bitcoin price from multiple APIs</p>
    </div>
    
    <div class="content-section">
      <!-- Test Controls -->
      <div class="test-controls">
        <button id="testAllBtn" class="test-btn" onclick="testAllAPIs()" data-i18n="testAll">Test All APIs</button>
        <button id="refreshBtn" class="test-btn" onclick="refreshPrice()" data-i18n="refresh">Refresh Price</button>
        <button id="matrixBtn" class="test-btn matrix-btn" onclick="enterMatrixMode()" data-i18n="matrixMode">Matrix Mode</button>
        <button id="centerBtn" class="test-btn" onclick="enterCenterMode()" data-i18n="centerMode">Center Mode</button>
    </div>

      <!-- API Status Section -->
      <div class="status-section">
        <div class="section-title">
          <span data-i18n="currentPrice">Current Bitcoin Price</span>
      </div>
        <div id="apiGrid" class="api-grid">
          <!-- API cards will be populated by JavaScript -->
    </div>
    </div>
    </div>
  </div>
    
  <!-- Matrix Mode Overlay -->
  <div id="matrixMode" class="matrix-mode">
    <div id="matrixControls" class="matrix-controls">
      <button class="matrix-btn-control" onclick="exitMatrixMode()" title="Exit Matrix Mode">
        ‚úï
      </button>
      <button class="matrix-btn-control" onclick="toggleFullscreen()" title="Toggle Fullscreen">
        ‚õ∂
      </button>
    </div>
    <div id="matrixAnimationContainer" class="matrix-animation-container">
      <!-- Falling price animations will be added here -->
    </div>
  </div>

  <!-- Center Mode Overlay -->
  <div id="centerMode" class="center-mode">
    <div id="centerControls" class="matrix-controls">
      <button class="matrix-btn-control" onclick="exitCenterMode()" title="Exit Center Mode">‚úï</button>
      <button class="matrix-btn-control" onclick="toggleFullscreen()" title="Toggle Fullscreen">‚õ∂</button>
    </div>
    <div id="centerPrice" class="center-price">--</div>
  </div>

  <script>
    // Language translations
    const translations = {
      en: {
        title: "üí∞ Bitcoin Price API",
        subtitle: "Real-time Bitcoin price from multiple APIs",
        currentPrice: "Current Bitcoin Price",
        loading: "Fetching price data...",
        testAll: "Test All APIs",
        refresh: "Refresh Price",
        matrixMode: "Matrix Mode",
        centerMode: "Center Mode",
        apiStatus: "API Status",
        connected: "Connected",
        failed: "Failed",
        testing: "Testing...",
        notTested: "Not tested",
        activeApi: "Active API",
        responseTime: "Response time"
      },
      zh: {
        title: "üí∞ ÊØîÁâπÂ∏Å‰ª∑Ê†ºAPI",
        subtitle: "Êù•Ëá™Â§ö‰∏™APIÁöÑÂÆûÊó∂ÊØîÁâπÂ∏Å‰ª∑Ê†º",
        currentPrice: "ÂΩìÂâçÊØîÁâπÂ∏Å‰ª∑Ê†º",
        loading: "Ëé∑Âèñ‰ª∑Ê†ºÊï∞ÊçÆ‰∏≠...",
        testAll: "ÊµãËØïÊâÄÊúâAPI",
        refresh: "Âà∑Êñ∞‰ª∑Ê†º",
        matrixMode: "Áü©ÈòµÊ®°Âºè",
        centerMode: "‰∏≠ÂøÉÊ®°Âºè",
        apiStatus: "APIÁä∂ÊÄÅ",
        connected: "Â∑≤ËøûÊé•",
        failed: "Â§±Ë¥•",
        testing: "ÊµãËØï‰∏≠...",
        notTested: "Êú™ÊµãËØï",
        activeApi: "ÂΩìÂâçAPI",
        responseTime: "ÂìçÂ∫îÊó∂Èó¥"
      }
    };

    let currentLanguage = 'en';
    let activeAPIIndex = 0;
    let testResults = {};
    
    // Matrix mode variables
    let matrixMode = false;
    let matrixInterval = null;
    let matrixAnimationCount = 0;
    let matrixHideTimeout = null;
    let isFullscreen = false;

    // Center mode variables
    let centerMode = false;
    let centerInterval = null;
    let centerPreviousPrice = null;
    let centerHideTimeout = null;

         // Multiple API endpoints
    const apiEndpoints = [
      {
        name: 'OKX',
        region: 'CN',
        url: 'https://www.okx.com/api/v5/market/ticker?instId=BTC-USDT',
        parser: (data) => parseFloat(data.data[0].last),
        enabled: true
      },
      {
        name: 'Huobi',
        region: 'CN', 
        url: 'https://api.huobi.pro/market/detail/merged?symbol=btcusdt',
        parser: (data) => parseFloat(data.tick.close),
        enabled: true
      },
      {
        name: 'CoinGecko',
        region: 'Global',
        url: 'https://api.coingecko.com/api/v3/simple/price?ids=bitcoin&vs_currencies=usd',
        parser: (data) => data.bitcoin.usd,
        enabled: true
      },
      {
        name: 'Coinbase',
        region: 'US',
        url: 'https://api.exchange.coinbase.com/products/BTC-USD/ticker',
        parser: (data) => parseFloat(data.price),
        enabled: true
      },
      {
        name: 'Kraken',
        region: 'US',
        url: 'https://api.kraken.com/0/public/Ticker?pair=XBTUSD',
        parser: (data) => parseFloat(data.result.XXBTZUSD.c[0]),
        enabled: true
       }
     ];

    function updateLanguage() {
      const elements = document.querySelectorAll('[data-i18n]');
      elements.forEach(element => {
        const key = element.getAttribute('data-i18n');
        if (translations[currentLanguage] && translations[currentLanguage][key]) {
          element.textContent = translations[currentLanguage][key];
        }
      });
      
      const langBtn = document.querySelector('.language-toggle');
      langBtn.textContent = currentLanguage === 'en' ? 'EN' : '‰∏≠';
      
      // Update API status texts
      updateAPIStatusTexts();
    }

    function toggleLanguage() {
      currentLanguage = currentLanguage === 'en' ? 'zh' : 'en';
      updateLanguage();
    }

    function initializeAPIGrid() {
      const grid = document.getElementById('apiGrid');
      grid.innerHTML = '';
      
      apiEndpoints.forEach((api, index) => {
        const card = document.createElement('div');
        card.className = 'api-card';
        card.id = `api-${index}`;
        
        card.innerHTML = `
          <div class="api-header">
          <div class="api-name">${api.name}</div>
          <div class="api-region">${api.region}</div>
          </div>
          <div class="api-status">
            <div class="status-dot" id="status-dot-${index}"></div>
            <div class="status-text" id="status-text-${index}">${translations[currentLanguage].notTested}</div>
          </div>
          <div class="api-price" id="api-price-${index}">-</div>
          <div class="api-response-time" id="response-time-${index}"></div>
        `;
        
        grid.appendChild(card);
      });
    }

    function updateAPIStatusTexts() {
      apiEndpoints.forEach((api, index) => {
        const statusText = document.getElementById(`status-text-${index}`);
        if (statusText) {
          const result = testResults[index];
          if (!result) {
            statusText.textContent = translations[currentLanguage].notTested;
          } else if (result.status === 'success') {
            statusText.textContent = translations[currentLanguage].connected;
          } else if (result.status === 'error') {
            statusText.textContent = translations[currentLanguage].failed;
          } else if (result.status === 'testing') {
            statusText.textContent = translations[currentLanguage].testing;
          }
        }
      });
    }

    async function testAPI(index) {
      const api = apiEndpoints[index];
      if (!api.enabled) {
        return { success:false, disabled:true };
      }
      const card = document.getElementById(`api-${index}`);
      const statusDot = document.getElementById(`status-dot-${index}`);
      const statusText = document.getElementById(`status-text-${index}`);
      const priceElement = document.getElementById(`api-price-${index}`);
      const responseTimeElement = document.getElementById(`response-time-${index}`);
      
      // Set testing status
      testResults[index] = { status: 'testing' };
      card.className = 'api-card testing';
      statusDot.className = 'status-dot testing';
      statusText.textContent = translations[currentLanguage].testing;
      priceElement.textContent = '-';
      responseTimeElement.textContent = '';
      
      const startTime = Date.now();
      
      try {
          const response = await fetch(api.url);
        const responseTime = Date.now() - startTime;
          
          if (!response.ok) {
          throw new Error(`HTTP ${response.status}`);
          }
          
          const data = await response.json();
          const price = api.parser(data);
          
          if (price && !isNaN(price)) {
          testResults[index] = { 
            status: 'success', 
            price: price, 
            responseTime: responseTime 
          };
          
          card.className = 'api-card success';
          statusDot.className = 'status-dot success';
          statusText.textContent = translations[currentLanguage].connected;
          priceElement.textContent = `$${price.toLocaleString()}`;
          responseTimeElement.textContent = `${responseTime}ms`;
          
          return { success: true, price: price, responseTime: responseTime };
          } else {
            throw new Error('Invalid price data');
          }
        } catch (error) {
        // Disable API permanently on error
        api.enabled = false;
        testResults[index] = { status: 'error', error: error.message };
        
        card.className = 'api-card error';
        statusDot.className = 'status-dot error';
        statusText.textContent = translations[currentLanguage].failed;
        priceElement.textContent = 'Error';
        responseTimeElement.textContent = error.message;
        
        return { success: false, error: error.message };
      }
    }

    async function testAllAPIs() {
      const testBtn = document.getElementById('testAllBtn');
      const refreshBtn = document.getElementById('refreshBtn');
      
      testBtn.disabled = true;
      refreshBtn.disabled = true;
      testBtn.textContent = 'Testing...';
      
      // Clear previous active status
      document.querySelectorAll('.api-card').forEach(card => {
        card.classList.remove('active');
      });
      
      // Test all APIs
      for (let i = 0; i < apiEndpoints.length; i++) {
        if (apiEndpoints[i].enabled) {
          await testAPI(i);
        }
        await new Promise(resolve => setTimeout(resolve, 200)); // Small delay between tests
      }
      
      // Find the best working API (fastest response)
      let bestAPI = null;
      let bestResponseTime = Infinity;
      
      Object.keys(testResults).forEach(index => {
        const result = testResults[index];
        if (result.status === 'success' && result.responseTime < bestResponseTime) {
          bestResponseTime = result.responseTime;
          bestAPI = parseInt(index);
        }
      });
      
      if (bestAPI !== null) {
        activeAPIIndex = bestAPI;
        const activeCard = document.getElementById(`api-${bestAPI}`);
        activeCard.classList.add('active');
      }
      
      testBtn.disabled = false;
      refreshBtn.disabled = false;
      testBtn.textContent = translations[currentLanguage].testAll;
    }

    async function refreshPrice() {
      if (activeAPIIndex !== null && testResults[activeAPIIndex]?.status === 'success') {
        const result = await testAPI(activeAPIIndex);
      } else {
        await testAllAPIs();
      }
    }

    // Matrix Mode Functions
    function enterMatrixMode() {
      matrixMode = true;
      const matrixOverlay = document.getElementById('matrixMode');
      matrixOverlay.classList.add('active');
      
      // Start matrix animations
      startMatrixAnimations();
      
      // Auto-hide controls after 5 seconds
      resetMatrixHideTimer();
      
      // Add interaction listeners to show controls
      setupMatrixInteractionListeners();
    }

    function exitMatrixMode() {
      matrixMode = false;
      const matrixOverlay = document.getElementById('matrixMode');
      matrixOverlay.classList.remove('active');
      
      // Exit fullscreen if currently in fullscreen mode
      if (isFullscreen) {
        exitFullscreen();
      }
      
      // Stop matrix animations
      stopMatrixAnimations();
      
      // Clear timers
      if (matrixHideTimeout) {
        clearTimeout(matrixHideTimeout);
      }
    }

    function startMatrixAnimations() {
      // Stop any existing interval
      stopMatrixAnimations();
      
      // Start price fetching and animation
      matrixInterval = setInterval(async () => {
        // Get price from active API or test a random one
        let price = null;
        
        if (activeAPIIndex !== null && testResults[activeAPIIndex]?.status === 'success') {
          try {
            const api = apiEndpoints[activeAPIIndex];
            const response = await fetch(api.url);
            if (response.ok) {
              const data = await response.json();
              price = api.parser(data);
            }
          } catch (error) {
            console.log('Matrix mode API fetch failed:', error);
          }
        }
        
        // If no price or error, use a recent successful price
        if (!price) {
          const successfulResults = Object.values(testResults).filter(r => r.status === 'success' && r.price);
          if (successfulResults.length > 0) {
            price = successfulResults[Math.floor(Math.random() * successfulResults.length)].price;
          } else {
            // Fallback to a reasonable BTC price
            price = 45000 + Math.random() * 10000;
          }
        }
        
        if (price) {
          createMatrixFallingPrice(price);
        }
      }, 2000); // Every 2 seconds
    }

    function stopMatrixAnimations() {
      if (matrixInterval) {
        clearInterval(matrixInterval);
        matrixInterval = null;
      }
      
      // Clear all animations
      const container = document.getElementById('matrixAnimationContainer');
      if (container) {
        container.innerHTML = '';
        matrixAnimationCount = 0;
      }
    }

    function createMatrixFallingPrice(price) {
      const container = document.getElementById('matrixAnimationContainer');
      
      // Limit concurrent animations
      if (matrixAnimationCount > 5) {
        const existingElements = container.querySelectorAll('.falling-price');
        if (existingElements.length > 0) {
          container.removeChild(existingElements[0]);
          matrixAnimationCount--;
        }
      }
      
      const priceElement = document.createElement('div');
      priceElement.className = 'falling-price';
      priceElement.textContent = Math.round(price).toLocaleString('en-US');
      
      container.appendChild(priceElement);
      matrixAnimationCount++;
      
      // Remove element after animation completes (8 seconds)
      setTimeout(() => {
        if (container.contains(priceElement)) {
          container.removeChild(priceElement);
          matrixAnimationCount = Math.max(0, matrixAnimationCount - 1);
        }
      }, 8000);
    }

    function resetMatrixHideTimer() {
      const controls = document.getElementById('matrixControls');
      controls.classList.remove('hidden');
      
      if (matrixHideTimeout) {
        clearTimeout(matrixHideTimeout);
      }
      
      matrixHideTimeout = setTimeout(() => {
        controls.classList.add('hidden');
      }, 5000);
    }

    function setupMatrixInteractionListeners() {
      const events = ['mousedown', 'mousemove', 'touchstart', 'keydown'];
      
      const handleInteraction = () => {
        if (matrixMode) {
          resetMatrixHideTimer();
        }
      };
      
      events.forEach(eventType => {
        document.addEventListener(eventType, handleInteraction, { passive: true });
      });
    }

    // Fullscreen functionality
    function toggleFullscreen() {
      if (!isFullscreen) {
        enterFullscreen();
      } else {
        exitFullscreen();
      }
    }

    function enterFullscreen() {
      const element = document.documentElement;
      
      if (element.requestFullscreen) {
        element.requestFullscreen().catch(()=>{});
      } else if (element.webkitRequestFullscreen) { // Safari
        element.webkitRequestFullscreen();
      } else if (element.msRequestFullscreen) { // IE11
        element.msRequestFullscreen();
      } else if (element.mozRequestFullScreen) { // Firefox
        element.mozRequestFullScreen();
      }
      
      // Ëã• 300ms Âêé‰ªçÊú™Â§Ñ‰∫éÂÖ®Â±èÔºåÂàôËÆ§‰∏∫ÊµèËßàÂô®‰∏çÊîØÊåÅÔºåÂêØÁî®Ê®°ÊãüÂÖ®Â±è
      setTimeout(()=>{
        isFullscreen = true;
        document.body.classList.toggle('sim-fullscreen', false);
        if (centerMode) adjustCenterPrice();
      },300);
    }

    function exitFullscreen() {
      if (document.exitFullscreen) {
        document.exitFullscreen();
      } else if (document.webkitExitFullscreen) { // Safari
        document.webkitExitFullscreen();
      } else if (document.msExitFullscreen) { // IE11
        document.msExitFullscreen();
      } else if (document.mozCancelFullScreen) { // Firefox
        document.mozCancelFullScreen();
      }
      
      isFullscreen = false;
      document.body.classList.remove('sim-fullscreen');
      if (centerMode) adjustCenterPrice();
    }

    function updateFullscreenButton() {
      const fullscreenBtn = document.querySelector('[onclick="toggleFullscreen()"]');
      if (fullscreenBtn) {
        fullscreenBtn.textContent = isFullscreen ? '‚õ∂' : '‚õ∂';
        fullscreenBtn.title = isFullscreen ? 'Exit Fullscreen' : 'Enter Fullscreen';
      }
    }

    // Listen for fullscreen changes
    function handleFullscreenChange() {
      isFullscreen = !!(document.fullscreenElement || 
                       document.webkitFullscreenElement || 
                       document.msFullscreenElement || 
                       document.mozFullScreenElement);
      updateFullscreenButton();
      if (centerMode) adjustCenterPrice();
    }

    // Add fullscreen event listeners
    document.addEventListener('fullscreenchange', handleFullscreenChange);
    document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
    document.addEventListener('msfullscreenchange', handleFullscreenChange);
    document.addEventListener('mozfullscreenchange', handleFullscreenChange);

    // Center Mode Functions
    function enterCenterMode() {
      // If matrix mode active, exit it first
      if (matrixMode) {
        exitMatrixMode();
      }
      centerMode = true;
      const overlay = document.getElementById('centerMode');
      overlay.classList.add('active');
      startCenterUpdates();
      adjustCenterPrice();
      resetCenterHideTimer();
      setupCenterInteractionListeners();
    }

    function exitCenterMode() {
      centerMode = false;
      const overlay = document.getElementById('centerMode');
      overlay.classList.remove('active');
      // Exit fullscreen if active
      if (isFullscreen) {
        exitFullscreen();
      }
      stopCenterUpdates();
      if (centerHideTimeout) clearTimeout(centerHideTimeout);
    }

    function startCenterUpdates() {
      stopCenterUpdates();
      updateCenterPriceDisplay();
      centerInterval = setInterval(updateCenterPriceDisplay, 2000);
    }

    function stopCenterUpdates() {
      if (centerInterval) {
        clearInterval(centerInterval);
        centerInterval = null;
      }
    }

    async function updateCenterPriceDisplay() {
      let price = null;
      // Try active API first
      if (activeAPIIndex !== null && testResults[activeAPIIndex]?.status === 'success') {
        try {
          const api = apiEndpoints[activeAPIIndex];
          const response = await fetch(api.url);
          if (response.ok) {
            const data = await response.json();
            price = api.parser(data);
          }
        } catch (err) {}
      }
      // fallback to successful cached
      if (!price) {
        const successful = Object.values(testResults).filter(r => r.status === 'success' && r.price);
        if (successful.length) {
          price = successful[Math.floor(Math.random()*successful.length)].price;
        }
      }
      // fallback to pseudo price
      if (!price) {
        price = 45000 + Math.random()*10000;
      }
      if (price) {
        updateCenterPrice(price);
      }
    }

    function updateCenterPrice(price) {
      const priceInt = Math.round(price);
      const priceEl = document.getElementById('centerPrice');
      if (!priceEl) return;
      priceEl.textContent = priceInt.toLocaleString('en-US');
      // Determine color
      if (centerPreviousPrice !== null) {
        if (priceInt > centerPreviousPrice) {
          priceEl.style.color = '#10b981';
        } else if (priceInt < centerPreviousPrice) {
          priceEl.style.color = '#ef4444';
        }
      }
      centerPreviousPrice = priceInt;
      adjustCenterPrice();
    }

    // ËÆ°ÁÆóÂπ∂Ë∞ÉÊï¥‰∏≠Â§Æ‰ª∑Ê†ºÂ≠ó‰ΩìÂ§ßÂ∞èÂèäÊóãËΩ¨
    function adjustCenterPrice() {
      const priceEl = document.getElementById('centerPrice');
      if (!priceEl || !centerMode) return;
      if (!isFullscreen) {
        // ÈÄÄÂá∫ÂÖ®Â±èÊó∂ÊÅ¢Â§çÈªòËÆ§ 12vw Â≠óÂè∑ÔºåÁî± CSS ÊéßÂà∂
        priceEl.style.fontSize = '';
      } else {
        const txt = priceEl.textContent || '88888';
        const chars = txt.length;
        const shortSide = Math.min(window.innerWidth, window.innerHeight);
        // ÂÖ®Â±èÊó∂Â∞ΩÈáèÂ°´Êª° 90% Áü≠Ëæπ
        let fontSize = (shortSide * 0.9) / (chars * 0.45);
        const maxHeight = window.innerHeight * 0.9;
        if (fontSize > maxHeight) fontSize = maxHeight;
        priceEl.style.fontSize = `${fontSize}px`;
      }
      // ‰ªÖÂú®ÂÖ®Â±èÊó∂ÂÖÅËÆ∏ÊóãËΩ¨
      if (isFullscreen) {
        if (window.innerHeight > window.innerWidth) {
          priceEl.style.transform = 'translate(-50%, -50%) rotate(90deg)';
        } else {
          priceEl.style.transform = 'translate(-50%, -50%)';
        }
      } else {
        priceEl.style.transform = 'translate(-50%, -50%)';
      }
    }

    // Âú®Á™óÂè£ÂèòÂä®Êó∂ÈáçÊñ∞Ë∞ÉÊï¥
    window.addEventListener('resize', () => {
      if (centerMode) adjustCenterPrice();
    });
    window.addEventListener('orientationchange', () => {
      if (centerMode) {
        // ÈÉ®ÂàÜÁßªÂä®ÊµèËßàÂô® orientationchange ‰∏ç‰ºöËß¶Âèë resize
        setTimeout(adjustCenterPrice, 300);
      }
    });

    function resetCenterHideTimer() {
      const controls = document.getElementById('centerControls');
      controls.classList.remove('hidden');
      if (centerHideTimeout) clearTimeout(centerHideTimeout);
      centerHideTimeout = setTimeout(()=>{controls.classList.add('hidden');},5000);
    }

    function setupCenterInteractionListeners() {
      const events=['mousedown','mousemove','touchstart','keydown'];
      const handler=()=>{if(centerMode) resetCenterHideTimer();};
      events.forEach(evt=>{document.addEventListener(evt,handler,{passive:true});});
    }

    // Initialize page
    function initializePage() {
      updateLanguage();
      initializeAPIGrid();
      
      // Show content with smooth fade-in
      setTimeout(() => {
        document.documentElement.classList.add('loaded');
        document.body.classList.add('loaded');
      }, 100);
      
      // Auto-test APIs on load
      setTimeout(() => {
        testAllAPIs();
      }, 500);
    }

    // Initialize as soon as DOM is ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initializePage);
    } else {
      initializePage();
    }
    
    // Fallback: ensure page is visible
    setTimeout(() => {
      if (!document.documentElement.classList.contains('loaded')) {
        document.documentElement.classList.add('loaded');
        document.body.classList.add('loaded');
      }
    }, 500);
  </script>
</body>
</html>
